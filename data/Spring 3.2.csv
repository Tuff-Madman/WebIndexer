paragraphs,link
"Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/
"@import ""manual.css"";body.firstpage{background:url(../images/background.png) no-repeat center top}div.part h1{border-top:none}",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/css/manual-multipage.css
The Spring MVC programming model now provides explicit Servlet 3 async support. @RequestMapping methods can return one of:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
java.util.concurrent.Callable to complete processing in a separate thread managed by a task executor within Spring MVC.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"org.springframework.web.context.request.async.DeferredResult to complete processing at a later time from a thread not known to Spring MVC — for example, in response to some external event (JMS, AMQP, etc.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
org.springframework.web.context.request.async.AsyncTask to wrap a Callable and customize the timeout value or the task executor to use.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"See Section 17.3.4, “Asynchronous Request Processing”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"First-class support for testing Spring MVC applications with a fluent API and without a Servlet container. Server-side tests involve use of the DispatcherServlet while client-side REST tests rely on the RestTemplate. See Section 11.3.6, “Spring MVC Test Framework”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"A ContentNegotiationStrategy is now available for resolving the requested media types from an incoming request. The available implementations are based on the file extension, query parameter, the 'Accept' header, or a fixed content type. Equivalent options were previously available only in the ContentNegotiatingViewResolver but are now available throughout.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"ContentNegotiationManager is the central class to use when configuring content negotiation options. For more details see Section 17.15.4, “Configuring Content Negotiation”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"The introduction of ContentNegotiationManger also enables selective suffix pattern matching for incoming requests. For more details, see the Javadoc of RequestMappingHandlerMapping.setUseRegisteredSuffixPatternMatch.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Classes annotated with @ControllerAdvice can contain @ExceptionHandler, @InitBinder, and @ModelAttribute methods and those will apply to @RequestMapping methods across controller hierarchies as opposed to the controller hierarchy within which they are declared. @ControllerAdvice is a component annotation allowing implementation classes to be auto-detected through classpath scanning.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
A new @MatrixVariable annotation adds support for extracting matrix variables from the request URI. For more details see the section called “Matrix Variables”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"An abstract base class implementation of the WebApplicationInitializer interface is provided to simplify code-based registration of a DispatcherServlet and filters mapped to it. The new class is named AbstractDispatcherServletInitializer and its sub-class AbstractAnnotationConfigDispatcherServletInitializer can be used with Java-based Spring configuration. For more details see Section 17.14, “Code-based Servlet container initialization”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"A convenient base class with an @ExceptionHandler method that handles standard Spring MVC exceptions and returns a ResponseEntity that allowing customizing and writing the response with HTTP message converters. This serves as an alternative to the DefaultHandlerExceptionResolver, which does the same but returns a ModelAndView instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"See the revised Section 17.11, “Handling exceptions” including information on customizing the default Servlet container error page.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"The RestTemplate can now read an HTTP response to a generic type (e.g. List<Account>). There are three new exchange() methods that accept ParameterizedTypeReference, a new class that enables capturing and passing generic type info.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"In support of this feature, the HttpMessageConverter is extended by GenericHttpMessageConverter adding a method for reading content given a specified parameterized type. The new interface is implemented by the MappingJacksonHttpMessageConverter and also by a new Jaxb2CollectionHttpMessageConverter that can read read a generic Collection where the generic type is a JAXB type annotated with @XmlRootElement or @XmlType.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"The Jackson JSON 2 library is now supported. Due to packaging changes in the Jackson library, there are separate classes in Spring MVC as well. Those are MappingJackson2HttpMessageConverter and MappingJackson2JsonView. Other related configuration improvements include support for pretty printing as well as a JacksonObjectMapperFactoryBean for convenient customization of an ObjectMapper in XML configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Tiles 3 is now supported in addition to Tiles 2.x. Configuring it should be very similar to the Tiles 2 configuration, i.e. the combination of TilesConfigurer, TilesViewResolver and TilesView except using the tiles3 instead of the tiles2 package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Also note that besides the version number change, the tiles dependencies have also changed. You will need to have a subset or all of tiles-request-api, tiles-api, tiles-core, tiles-servlet, tiles-jsp, tiles-el.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
An @RequestBody or an @RequestPart argument can now be followed by an Errors argument making it possible to handle validation errors (as a result of an @Valid annotation) locally within the @RequestMapping method. @RequestBody now also supports a required flag.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
The HTTP request method PATCH may now be used in @RequestMapping methods as well as in the RestTemplate in conjunction with Apache HttpComponents HttpClient version 4.2 or later. The JDK HttpURLConnection does not support the PATCH method.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
Mapped interceptors now support URL patterns to be excluded. The MVC namespace and the MVC JavaConfig both expose these options.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"As of 3.2, Spring allows for @Autowired and @Value to be used as meta-annotations, e.g. to build custom injection annotations in combination with specific qualifiers. Analogously, you may build custom @Bean definition annotations for @Configuration classes, e.g. in combination with specific qualifiers, @Lazy, @Primary, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Spring provides a CacheManager adapter for JCache, building against the JCache 0.5 preview release. Full JCache support is coming next year, along with Java EE 7 final.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
The @DateTimeFormat annotation can now be used without needing a dependency on the Joda Time library. If Joda Time is not present the JDK SimpleDateFormat will be used to parse and print date patterns. When Joda Time is present it will continue to be used in preference to SimpleDateFormat.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"It is now possible to define global formats that will be used when parsing and printing date and time types. See Section 7.7, “Configuring a global date & time format” for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"In addition to the aforementioned inclusion of the Spring MVC Test Framework in the spring-test module, the Spring TestContext Framework has been revised with support for integration testing web applications as well as configuring application contexts with context initializers. For further details, consult the following.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Spring Framework 3.2 includes fine-tuning of concurrent data structures in many parts of the framework, minimizing locks and generally improving the arrangements for highly concurrent creation of scoped/prototype beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
Building and contributing to the framework has never been simpler with our move to a Gradle-based build system and source control at GitHub. See the building from source section of the README and the contributor guidelines for complete details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"Last but not least, Spring Framework 3.2 comes with refined Java 7 support within the framework as well as through upgraded third-party dependencies: specifically, CGLIB 3.0, ASM 4.0 (both of which come as inlined dependencies with Spring now) and AspectJ 1.7 support (next to the existing AspectJ 1.6 support).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.2.html
"The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications. However, Spring is modular, allowing you to use only those parts that you need, without having to bring in the rest. You can use the IoC container, with Struts on top, but you can also use only the Hibernate integration code or the JDBC abstraction layer. The Spring Framework supports declarative transaction management, remote access to your logic through RMI or web services, and various options for persisting your data. It offers a full-featured MVC framework, and enables you to integrate AOP transparently into your software.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-introduction.html
"Spring is designed to be non-intrusive, meaning that your domain logic code generally has no dependencies on the framework itself. In your integration layer (such as the data access layer), some dependencies on the data access technology and the Spring libraries will exist. However, it should be easy to isolate these dependencies from the rest of your code base.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-introduction.html
"This document is a reference guide to Spring Framework features. If you have any requests, comments, or questions on this document, please post them on the user mailing list or on the support forums at http://forum.springsource.org/.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-introduction.html
Spring Framework is a Java platform that provides comprehensive infrastructure support for developing Java applications. Spring handles the infrastructure so you can focus on your application.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Spring enables you to build applications from “plain old Java objects” (POJOs) and to apply enterprise services non-invasively to POJOs. This capability applies to the Java SE programming model and to full and partial Java EE.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Examples of how you, as an application developer, can use the Spring platform advantage:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Make a Java method execute in a database transaction without having to deal with transaction APIs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Make a local Java method a remote procedure without having to deal with remote APIs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Make a local Java method a management operation without having to deal with JMX APIs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Make a local Java method a message handler without having to deal with JMS APIs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"“The question is, what aspect of control are [they] inverting?” Martin Fowler posed this question about Inversion of Control (IoC) on his site in 2004. Fowler suggested renaming the principle to make it more self-explanatory and came up with Dependency Injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"For insight into IoC and DI, refer to Fowler's article at http://martinfowler.com/articles/injection.html.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Java applications -- a loose term that runs the gamut from constrained applets to n-tier server-side enterprise applications -- typically consist of objects that collaborate to form the application proper. Thus the objects in an application have dependencies on each other.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/#d5e121
Cache Abstraction (SpringSource team blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
XML profiles (SpringSource Team Blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
Introducing @Profile (SpringSource Team Blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
Environment Abstraction (SpringSource Team Blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
Unified Property Management (SpringSource Team Blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"Code-based equivalents to popular Spring XML namespace elements <context:component-scan/>, <tx:annotation-driven/> and <mvc:annotation-driven> have been developed, most in the form of @Enable annotations. These are designed for use in conjunction with Spring's @Configuration classes, which were introduced in Spring Framework 3.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"The @ContextConfiguration annotation now supports supplying @Configuration classes for configuring the Spring TestContext. In addition, a new @ActiveProfiles annotation has been introduced to support declarative configuration of active bean definition profiles in ApplicationContext integration tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
Spring 3.1 M2: Testing with @Configuration Classes and Profiles (SpringSource Team Blog),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"Prior to Spring Framework 3.1, in order to inject against a property method it had to conform strictly to JavaBeans property signature rules, namely that any 'setter' method must be void-returning. It is now possible in Spring XML to specify setter methods that return any object type. This is useful when considering designing APIs for method-chaining, where setter methods return a reference to 'this'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
The new WebApplicationInitializer builds atop Servlet 3.0's ServletContainerInitializer support to provide a programmatic alternative to the traditional web.xml.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"In standard JPA, persistence units get defined through META-INF/persistence.xml files in specific jar files which will in turn get searched for @Entity classes. In many cases, persistence.xml does not contain more than a unit name and relies on defaults and/or external setup for all other concerns (such as the DataSource to use, etc). For that reason, Spring Framework 3.1 provides an alternative: LocalContainerEntityManagerFactoryBean accepts a 'packagesToScan' property, specifying base packages to scan for @Entity classes. This is analogous to AnnotationSessionFactoryBean's property of the same name for native Hibernate setup, and also to Spring's component-scan feature for regular Spring beans. Effectively, this allows for XML-free JPA setup at the mere expense of specifying a base package for entity scanning: a particularly fine match for Spring applications which rely on component scanning for Spring beans as well, possibly even bootstrapped using a code-based Servlet 3.0 initializer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
Spring Framework 3.1 introduces a new set of support classes for processing requests with annotated controllers:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
These classes are a replacement for the existing:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"The new classes were developed in response to many requests to make annotation controller support classes more customizable and open for extension. Whereas previously you could configure a custom annotated controller method argument resolver, with the new support classes you can customize the processing for any supported method argument or return value type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"A second notable difference is the introduction of a HandlerMethod abstraction to represent an @RequestMapping method. This abstraction is used throughout by the new support classes as the handler instance. For example a HandlerInterceptor can cast the handler from Object to HandlerMethod and get access to the target controller method, its annotations, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/index.html
"Although the Java platform provides a wealth of application development functionality, it lacks the means to organize the basic building blocks into a coherent whole, leaving that task to architects and developers. True, you can use design patterns such as Factory, Abstract Factory, Builder, Decorator, and Service Locator to compose the various classes and object instances that make up an application. However, these patterns are simply that: best practices given a name, with a description of what the pattern does, where to apply it, the problems it addresses, and so forth. Patterns are formalized best practices that you must implement yourself in your application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Spring Framework Inversion of Control (IoC) component addresses this concern by providing a formalized means of composing disparate components into a fully working application ready for use. The Spring Framework codifies formalized design patterns as first-class objects that you can integrate into your own application(s). Numerous organizations and institutions use the Spring Framework in this manner to engineer robust, maintainable applications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Spring Framework consists of features organized into about 20 modules. These modules are grouped into Core Container, Data Access/Integration, Web, AOP (Aspect Oriented Programming), Instrumentation, and Test, as shown in the following diagram.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Core Container consists of the Core, Beans, Context, and Expression Language modules.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Core and Beans modules provide the fundamental parts of the framework, including the IoC and Dependency Injection features. The BeanFactory is a sophisticated implementation of the factory pattern. It removes the need for programmatic singletons and allows you to decouple the configuration and specification of dependencies from your actual program logic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Context module builds on the solid base provided by the Core and Beans modules: it is a means to access objects in a framework-style manner that is similar to a JNDI registry. The Context module inherits its features from the Beans module and adds support for internationalization (using, for example, resource bundles), event-propagation, resource-loading, and the transparent creation of contexts by, for example, a servlet container. The Context module also supports Java EE features such as EJB, JMX ,and basic remoting. The ApplicationContext interface is the focal point of the Context module.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Expression Language module provides a powerful expression language for querying and manipulating an object graph at runtime. It is an extension of the unified expression language (unified EL) as specified in the JSP 2.1 specification. The language supports setting and getting property values, property assignment, method invocation, accessing the context of arrays, collections and indexers, logical and arithmetic operators, named variables, and retrieval of objects by name from Spring's IoC container. It also supports list projection and selection as well as common list aggregations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Data Access/Integration layer consists of the JDBC, ORM, OXM, JMS and Transaction modules.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The JDBC module provides a JDBC-abstraction layer that removes the need to do tedious JDBC coding and parsing of database-vendor specific error codes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The ORM module provides integration layers for popular object-relational mapping APIs, including JPA, JDO, Hibernate, and iBatis. Using the ORM package you can use all of these O/R-mapping frameworks in combination with all of the other features Spring offers, such as the simple declarative transaction management feature mentioned previously.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The OXM module provides an abstraction layer that supports Object/XML mapping implementations for JAXB, Castor, XMLBeans, JiBX and XStream.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Java Messaging Service (JMS) module contains features for producing and consuming messages.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Transaction module supports programmatic and declarative transaction management for classes that implement special interfaces and for all your POJOs (plain old Java objects).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Web layer consists of the Web, Web-Servlet, Web-Struts, and Web-Portlet modules.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Spring's Web module provides basic web-oriented integration features such as multipart file-upload functionality and the initialization of the IoC container using servlet listeners and a web-oriented application context. It also contains the web-related parts of Spring's remoting support.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Web-Servlet module contains Spring's model-view-controller (MVC) implementation for web applications. Spring's MVC framework provides a clean separation between domain model code and web forms, and integrates with all the other features of the Spring Framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Web-Struts module contains the support classes for integrating a classic Struts web tier within a Spring application. Note that this support is now deprecated as of Spring 3.0. Consider migrating your application to Struts 2.0 and its Spring integration or to a Spring MVC solution.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Web-Portlet module provides the MVC implementation to be used in a portlet environment and mirrors the functionality of Web-Servlet module.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Spring's AOP module provides an AOP Alliance-compliant aspect-oriented programming implementation allowing you to define, for example, method-interceptors and pointcuts to cleanly decouple code that implements functionality that should be separated. Using source-level metadata functionality, you can also incorporate behavioral information into your code, in a manner similar to that of .NET attributes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The separate Aspects module provides integration with AspectJ.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Instrumentation module provides class instrumentation support and classloader implementations to be used in certain application servers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The Test module supports the testing of Spring components with JUnit or TestNG. It provides consistent loading of Spring ApplicationContexts and caching of those contexts. It also provides mock objects that you can use to test your code in isolation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The building blocks described previously make Spring a logical choice in many scenarios, from applets to full-fledged enterprise applications that use Spring's transaction management functionality and web framework integration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Spring's declarative transaction management features make the web application fully transactional, just as it would be if you used EJB container-managed transactions. All your custom business logic can be implemented with simple POJOs and managed by Spring's IoC container. Additional services include support for sending email and validation that is independent of the web layer, which lets you choose where to execute validation rules. Spring's ORM support is integrated with JPA, Hibernate, JDO and iBatis; for example, when using Hibernate, you can continue to use your existing mapping files and standard Hibernate SessionFactory configuration. Form controllers seamlessly integrate the web-layer with the domain model, removing the need for ActionForms or other classes that transform HTTP parameters to values for your domain model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The new classes are enabled by default by the MVC namespace and by Java-based configuration via @EnableWebMvc. The existing classes will continue to be available but use of the new classes is recommended going forward.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
See the section called “New Support Classes for @RequestMapping methods in Spring MVC 3.1” for additional details and a list of features not available with the new support classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"Flash attributes can now be stored in a FlashMap and saved in the HTTP session to survive a redirect. For an overview of the general support for flash attributes in Spring MVC see Section 17.6, “Using flash attributes”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"In annotated controllers, an @RequestMapping method can add flash attributes by declaring a method argument of type RedirectAttributes. This method argument can now also be used to get precise control over the attributes used in a redirect scenario. See the section called “Specifying redirect and flash attributes” for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
URI template variables from the current request are used in more places:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
URI template variables are used in addition to request parameters when binding a request to @ModelAttribute method arguments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"@PathVariable method argument values are merged into the model before rendering, except in views that generate content in an automated fashion such as JSON serialization or XML marshalling.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"A redirect string can contain placeholders for URI variables (e.g. ""redirect:/blog/{year}/{month}""). When expanding the placeholders, URI template variables from the current request are automatically considered.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
An @ModelAttribute method argument can be instantiated from a URI template variable provided there is a registered Converter or PropertyEditor to convert from a String to the target object type.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
An @RequestBody method argument can be annotated with @Valid to invoke automatic validation similar to the support for @ModelAttribute method arguments. A resulting MethodArgumentNotValidException is handled in the DefaultHandlerExceptionResolver and results in a 400 response code.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"This new annotation provides access to the content of a ""multipart/form-data"" request part. See Section 17.10.5, “Handling a file upload request from programmatic clients” and Section 17.10, “Spring's multipart (file upload) support”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"A new UriComponents class has been added, which is an immutable container of URI components providing access to all contained URI components. A new UriComponentsBuilder class is also provided to help create UriComponents instances. Together the two classes give fine-grained control over all aspects of preparing a URI including construction, expansion from URI template variables, and encoding.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
In most cases the new classes can be used as a more flexible alternative to the existing UriTemplate especially since UriTemplate relies on those same classes internally.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"A ServletUriComponentsBuilder sub-class provides static factory methods to copy information from a Servlet request. See Section 17.7, “Building URIs”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.1.html
"If you have been using the Spring Framework for some time, you will be aware that Spring has undergone two major revisions: Spring 2.0, released in October 2006, and Spring 2.5, released in November 2007. It is now time for a third overhaul resulting in Spring Framework 3.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"The Spring Framework is now based on Java 5, and Java 6 is fully supported.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Furthermore, Spring is compatible with J2EE 1.4 and Java EE 5, while at the same time introducing some early support for Java EE 6.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"The entire framework code has been revised to take advantage of Java 5 features like generics, varargs and other language improvements. We have done our best to still keep the code backwards compatible. We now have consistent use of generic Collections and Maps, consistent use of generic FactoryBeans, and also consistent resolution of bridge methods in the Spring AOP API. Generic ApplicationListeners automatically receive specific event types only. All callback interfaces such as TransactionCallback and HibernateCallback declare a generic result value now. Overall, the Spring core codebase is now freshly revised and optimized for Java 5.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Spring's TaskExecutor abstraction has been updated for close integration with Java 5's java.util.concurrent facilities. We provide first-class support for Callables and Futures now, as well as ExecutorService adapters, ThreadFactory integration, etc. This has been aligned with JSR-236 (Concurrency Utilities for Java EE 6) as far as possible. Furthermore, we provide support for asynchronous method invocations through the use of the new @Async annotation (or EJB 3.1's @Asynchronous annotation).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"The Spring reference documentation has also substantially been updated to reflect all of the changes and new features for Spring Framework 3.0. While every effort has been made to ensure that there are no errors in this documentation, some errors may nevertheless have crept in. If you do spot any typos or even more serious errors, and you can spare a few cycles during lunch, please do bring the error to the attention of the Spring team by raising an issue.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
There are many excellent articles and tutorials that show how to get started with Spring Framework 3 features. Read them at the Spring Documentation page.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"The samples have been improved and updated to take advantage of the new features in Spring Framework 3. Additionally, the samples have been moved out of the source tree into a dedicated SVN repository available at:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"As such, the samples are no longer distributed alongside Spring Framework 3 and need to be downloaded separately from the repository mentioned above. However, this documentation will continue to refer to some samples (in particular Petclinic) to illustrate various features.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"For more information on Subversion (or in short SVN), see the project homepage at: http://subversion.apache.org/",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
The framework modules have been revised and are now managed separately with one source-tree per module jar:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Sometimes circumstances do not allow you to completely switch to a different framework. The Spring Framework does not force you to use everything within it; it is not an all-or-nothing solution. Existing front-ends built with WebWork, Struts, Tapestry, or other UI frameworks can be integrated with a Spring-based middle-tier, which allows you to use Spring transaction features. You simply need to wire up your business logic using an ApplicationContext and use a WebApplicationContext to integrate your web layer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"When you need to access existing code through web services, you can use Spring's Hessian-, Burlap-, Rmi- or JaxRpcProxyFactory classes. Enabling remote access to existing applications is not difficult.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Spring Framework also provides an access and abstraction layer for Enterprise JavaBeans, enabling you to reuse your existing POJOs and wrap them in stateless session beans for use in scalable, fail-safe web applications that might need declarative security.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Dependency management and dependency injection are different things. To get those nice features of Spring into your application (like dependency injection) you need to assemble all the libraries needed (jar files) and get them onto your classpath at runtime, and possibly at compile time. These dependencies are not virtual components that are injected, but physical resources in a file system (typically). The process of dependency management involves locating those resources, storing them and adding them to classpaths. Dependencies can be direct (e.g. my application depends on Spring at runtime), or indirect (e.g. my application depends on commons-dbcp which depends on commons-pool). The indirect dependencies are also known as ""transitive"" and it is those dependencies that are hardest to identify and manage.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"If you are going to use Spring you need to get a copy of the jar libraries that comprise the pieces of Spring that you need. To make this easier Spring is packaged as a set of modules that separate the dependencies as much as possible, so for example if you don't want to write a web application you don't need the spring-web modules. To refer to Spring library modules in this guide we use a shorthand naming convention spring-* or spring-*.jar, where ""*"" represents the short name for the module (e.g. spring-core, spring-webmvc, spring-jms, etc.). The actual jar file name that you use may be in this form (see below) or it may not, and normally it also has a version number in the file name (e.g. spring-core-3.0.0.RELEASE.jar).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"In general, Spring publishes its artifacts to four different places:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
On the community download site http://www.springsource.org/download/community. Here you find all the Spring jars bundled together into a zip file for easy download. The names of the jars here since version 3.0 are in the form org.springframework.*-<version>.jar.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Maven Central, which is the default repository that Maven queries, and does not require any special configuration to use. Many of the common libraries that Spring depends on also are available from Maven Central and a large section of the Spring community uses Maven for dependency management, so this is convenient for them. The names of the jars here are in the form spring-*-<version>.jar and the Maven groupId is org.springframework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The Enterprise Bundle Repository (EBR), which is run by SpringSource and also hosts all the libraries that integrate with Spring. Both Maven and Ivy repositories are available here for all Spring jars and their dependencies, plus a large number of other common libraries that people use in applications with Spring. Both full releases and also milestones and development snapshots are deployed here. The names of the jar files are in the same form as the community download (org.springframework.*-<version>.jar), and the dependencies are also in this ""long"" form, with external libraries (not from SpringSource) having the prefix com.springsource. See the FAQ for more information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"In a public Maven repository hosted on Amazon S3 for development snapshots and milestone releases (a copy of the final releases is also held here). The jar file names are in the same form as Maven Central, so this is a useful place to get development versions of Spring to use with other libraries deployed in Maven Central.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"So the first thing you need to decide is how to manage your dependencies: most people use an automated system like Maven or Ivy, but you can also do it manually by downloading all the jars yourself. When obtaining Spring with Maven or Ivy you have then to decide which place you'll get it from. In general, if you care about OSGi, use the EBR, since it houses OSGi compatible artifacts for all of Spring's dependencies, such as Hibernate and Freemarker. If OSGi does not matter to you, either place works, though there are some pros and cons between them. In general, pick one place or the other for your project; do not mix them. This is particularly important since EBR artifacts necessarily use a different naming convention than Maven Central artifacts.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Although Spring provides integration and support for a huge range of enterprise and other external tools, it intentionally keeps its mandatory dependencies to an absolute minimum: you shouldn't have to locate and download (even automatically) a large number of jar libraries in order to use Spring for simple use cases. For basic dependency injection there is only one mandatory external dependency, and that is for logging (see below for a more detailed description of logging options).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Next we outline the basic steps needed to configure an application that depends on Spring, first with Maven and then with Ivy. In all cases, if anything is unclear, refer to the documentation of your dependency management system, or look at some sample code - Spring itself uses Ivy to manage dependencies when it is building, and our samples mostly use Maven.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"If you are using Maven for dependency management you don't even need to supply the logging dependency explicitly. For example, to create an application context and use dependency injection to configure an application, your Maven dependencies will look like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"That's it. Note the scope can be declared as runtime if you don't need to compile against Spring APIs, which is typically the case for basic dependency injection use cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"We used the Maven Central naming conventions in the example above, so that works with Maven Central or the SpringSource S3 Maven repository. To use the S3 Maven repository (e.g. for milestones or developer snapshots), you need to specify the repository location in your Maven configuration. For full releases:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
For milestones:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
And for snapshots:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"To use the SpringSource EBR you would need to use a different naming convention for the dependencies. The names are usually easy to guess, e.g. in this case it is:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
You also need to declare the location of the repository explicitly (only the URL is important):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"If you are managing your dependencies by hand, the URL in the repository declaration above is not browsable, but there is a user interface at http://www.springsource.com/repository that can be used to search for and download dependencies. It also has handy snippets of Maven and Ivy configuration that you can copy and paste if you are using those tools.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
If you prefer to use Ivy to manage dependencies then there are similar names and configuration options.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
To configure Ivy to point to the SpringSource EBR add the following resolvers to your ivysettings.xml:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The XML above is not valid because the lines are too long - if you copy-paste then remove the extra line endings in the middle of the url patterns.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Once Ivy is configured to look in the EBR adding a dependency is easy. Simply pull up the details page for the bundle in question in the repository browser and you'll find an Ivy snippet ready for you to include in your dependencies section. For example (in ivy.xml):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
The spring.jar artifact that contained almost the entire framework is no longer provided.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
We are now using a new Spring build system as known from Spring Web Flow 2.0. This gives us:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
This is a list of new features for Spring Framework 3.0. We will cover these features in more detail later in this section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
BeanFactory interface returns typed bean instances as far as possible:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
T getBean(Class<T> requiredType),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"T getBean(String name, Class<T> requiredType)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Map<String, T> getBeansOfType(Class<T> type)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Spring's TaskExecutor interface now extends java.util.concurrent.Executor:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
New Java 5 based converter API and SPI:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Typed ApplicationListener<E>,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Spring introduces an expression language which is similar to Unified EL in its syntax but offers significantly more features. The expression language can be used when defining XML and Annotation based bean definitions and also serves as the foundation for expression language support across the Spring portfolio. Details of this new functionality can be found in the chapter Spring Expression Language (SpEL).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"The Spring Expression Language was created to provide the Spring community a single, well supported expression language that can be used across all the products in the Spring portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the Eclipse based SpringSource Tool Suite.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
This functionality is also available if you prefer to configure your components using annotations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Some core features from the JavaConfig project have been added to the Spring Framework now. This means that the following annotations are now directly supported:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Here is an example of a Java class providing basic configuration using the new JavaConfig features:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
To get this to work you need to add the following component scanning entry in your minimal application context XML file.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Or you can bootstrap a @Configuration class directly using AnnotationConfigApplicationContext:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"See Section 5.12.2, “Instantiating the Spring container using AnnotationConfigApplicationContext” for full information on AnnotationConfigApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"A general purpose type conversion system has been introduced. The system is currently used by SpEL for type conversion, and may also be used by a Spring Container and DataBinder when binding bean property values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"In addition, a formatter SPI has been introduced for formatting field values. This SPI provides a simpler and more robust alternative to JavaBean PropertyEditors for use in client environments such as Spring MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Object to XML mapping functionality (OXM) from the Spring Web Services project has been moved to the core Spring Framework now. The functionality is found in the org.springframework.oxm package. More information on the use of the OXM module can be found in the Marshalling XML using O/X Mappers chapter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
The most exciting new feature for the Web Tier is the support for building RESTful web services and web applications. There are also some new annotations that can be used in any web application.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Server-side support for building RESTful applications has been provided as an extension of the existing annotation driven MVC web framework. Client-side support is provided by the RestTemplate class in the spirit of other template classes such as JdbcTemplate and JmsTemplate. Both server and client side REST functionality make use of HttpConverters to facilitate the conversion between objects and their representation in HTTP requests and responses.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
The MarshallingHttpMessageConverter uses the Object to XML mapping functionality mentioned earlier.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
Refer to the sections on MVC and the RestTemplate for more information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
A mvc namespace has been introduced that greatly simplifies Spring MVC configuration.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Logging is a very important dependency for Spring because a) it is the only mandatory external dependency, b) everyone likes to see some output from the tools they are using, and c) Spring integrates with lots of other tools all of which have also made a choice of logging dependency. One of the goals of an application developer is often to have unified logging configured in a central place for the whole application, including all external components. This is more difficult than it might have been since there are so many choices of logging framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The mandatory logging dependency in Spring is the Jakarta Commons Logging API (JCL). We compile against JCL and we also make JCL Log objects visible for classes that extend the Spring Framework. It's important to users that all versions of Spring use the same logging library: migration is easy because backwards compatibility is preserved even with applications that extend Spring. The way we do this is to make one of the modules in Spring depend explicitly on commons-logging (the canonical implementation of JCL), and then make all the other modules depend on that at compile time. If you are using Maven for example, and wondering where you picked up the dependency on commons-logging, then it is from Spring and specifically from the central module called spring-core.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"The nice thing about commons-logging is that you don't need anything else to make your application work. It has a runtime discovery algorithm that looks for other logging frameworks in well known places on the classpath and uses one that it thinks is appropriate (or you can tell it which one if you need to). If nothing else is available you get pretty nice looking logs just from the JDK (java.util.logging or JUL for short). You should find that your Spring application works and logs happily to the console out of the box in most situations, and that's important.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Unfortunately, the runtime discovery algorithm in commons-logging, while convenient for the end-user, is problematic. If we could turn back the clock and start Spring now as a new project it would use a different logging dependency. The first choice would probably be the Simple Logging Facade for Java (SLF4J), which is also used by a lot of other tools that people use with Spring inside their applications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Switching off commons-logging is easy: just make sure it isn't on the classpath at runtime. In Maven terms you exclude the dependency, and because of the way that the Spring dependencies are declared, you only have to do that once.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Now this application is probably broken because there is no implementation of the JCL API on the classpath, so to fix it a new one has to be provided. In the next section we show you how to provide an alternative implementation of JCL using SLF4J as an example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"SLF4J is a cleaner dependency and more efficient at runtime than commons-logging because it uses compile-time bindings instead of runtime discovery of the other logging frameworks it integrates. This also means that you have to be more explicit about what you want to happen at runtime, and declare it or configure it accordingly. SLF4J provides bindings to many common logging frameworks, so you can usually choose one that you already use, and bind to that for configuration and management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"SLF4J provides bindings to many common logging frameworks, including JCL, and it also does the reverse: bridges between other logging frameworks and itself. So to use SLF4J with Spring you need to replace the commons-logging dependency with the SLF4J-JCL bridge. Once you have done that then logging calls from within Spring will be translated into logging calls to the SLF4J API, so if other libraries in your application use that API, then you have a single place to configure and manage logging.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"That might seem like a lot of dependencies just to get some logging. Well it is, but it is optional, and it should behave better than the vanilla commons-logging with respect to classloader issues, notably if you are in a strict container like an OSGi platform. Allegedly there is also a performance benefit because the bindings are at compile-time not runtime.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"A more common choice amongst SLF4J users, which uses fewer steps and generates fewer dependencies, is to bind directly to Logback. This removes the extra binding step because Logback implements SLF4J directly, so you only need to depend on two libraries not four (jcl-over-slf4j and logback). If you do that you might also need to exclude the slf4j-api dependency from other external dependencies (not Spring), because you only want one version of that API on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Many people use Log4j as a logging framework for configuration and management purposes. It's efficient and well-established, and in fact it's what we use at runtime when we build and test Spring. Spring also provides some utilities for configuring and initializing Log4j, so it has an optional compile-time dependency on Log4j in some modules.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"To make Log4j work with the default JCL dependency (commons-logging) all you need to do is put Log4j on the classpath, and provide it with a configuration file (log4j.properties or log4j.xml in the root of the classpath). So for Maven users this is your dependency declaration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
And here's a sample log4j.properties for logging to the console:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"Many people run their Spring applications in a container that itself provides an implementation of JCL. IBM Websphere Application Server (WAS) is the archetype. This often causes problems, and unfortunately there is no silver bullet solution; simply excluding commons-logging from your application is not enough in most situations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"To be clear about this: the problems reported are usually not with JCL per se, or even with commons-logging: rather they are to do with binding commons-logging to another framework (often Log4J). This can fail because commons-logging changed the way they do the runtime discovery in between the older versions (1.0) found in some containers and the modern versions that most people use now (1.1). Spring does not use any unusual parts of the JCL API, so nothing breaks there, but as soon as Spring or your application tries to do any logging you can find that the bindings to Log4J are not working.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
"In such cases with WAS the easiest thing to do is to invert the class loader hierarchy (IBM calls it ""parent last"") so that the application controls the JCL dependency, not the container. That option isn't always open, but there are plenty of other suggestions in the public domain for alternative approaches, and your mileage may vary depending on the exact version and feature set of the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/overview.html
Additional annotations such as @CookieValue and @RequestHeaders have been added. See Mapping cookie values with the @CookieValue annotation and Mapping request header attributes with the @RequestHeader annotation for more information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Several validation enhancements, including JSR 303 support that uses Hibernate Validator as the default provider.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
We provide support for asynchronous method invocations through the use of the new @Async annotation (or EJB 3.1's @Asynchronous annotation).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
"Convenient support for embedded Java database engines, including HSQL, H2, and Derby, is now provided.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html
The Spring Framework supports JSR-303 Bean Validation adapting it to Spring's Validator interface.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) [1]principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the Service Locator pattern.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Java's standard java.net.URL class and standard handlers for various URL prefixes unfortunately are not quite adequate enough for all access to low-level resources. For example, there is no standardized URL implementation that may be used to access a resource that needs to be obtained from the classpath, or relative to a ServletContext. While it is possible to register new handlers for specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally quite complicated, and the URL interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Spring's Resource interface is meant to be a more capable interface for abstracting access to low-level resources.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Some of the most important methods from the Resource interface are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"getInputStream(): locates and opens the resource, returning an InputStream for reading from the resource. It is expected that each invocation returns a fresh InputStream. It is the responsibility of the caller to close the stream.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
exists(): returns a boolean indicating whether this resource actually exists in physical form.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"isOpen(): returns a boolean indicating whether this resource represents a handle with an open stream. If true, the InputStream cannot be read multiple times, and must be read once only and then closed to avoid resource leaks. Will be false for all usual resource implementations, with the exception of InputStreamResource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"getDescription(): returns a description for this resource, to be used for error output when working with the resource. This is often the fully qualified file name or the actual URL of the resource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Other methods allow you to obtain an actual URL or File object representing the resource (if the underlying implementation is compatible, and supports that functionality).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The Resource abstraction is used extensively in Spring itself, as an argument type in many method signatures when a resource is needed. Other methods in some Spring APIs (such as the constructors to various ApplicationContext implementations), take a String which in unadorned or simple form is used to create a Resource appropriate to that context implementation, or via special prefixes on the String path, allow the caller to specify that a specific Resource implementation must be created and used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"While the Resource interface is used a lot with Spring and by Spring, it's actually very useful to use as a general utility class by itself in your own code, for access to resources, even when your code doesn't know or care about any other parts of Spring. While this couples your code to Spring, it really only couples it to this small set of utility classes, which are serving as a more capable replacement for URL, and can be considered equivalent to any other library you would use for this purpose.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"It is important to note that the Resource abstraction does not replace functionality: it wraps it where possible. For example, a UrlResource wraps a URL, and uses the wrapped URL to do its work.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
There are a number of Resource implementations that come supplied straight out of the box in Spring:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The UrlResource wraps a java.net.URL, and may be used to access any object that is normally accessible via a URL, such as files, an HTTP target, an FTP target, etc. All URLs have a standardized String representation, such that appropriate standardized prefixes are used to indicate one URL type from another. This includes file: for accessing filesystem paths, http: for accessing resources via the HTTP protocol, ftp: for accessing resources via FTP, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"A UrlResource is created by Java code explicitly using the UrlResource constructor, but will often be created implicitly when you call an API method which takes a String argument which is meant to represent a path. For the latter case, a JavaBeans PropertyEditor will ultimately decide which type of Resource to create. If the path string contains a few well-known (to it, that is) prefixes such as classpath:, it will create an appropriate specialized Resource for that prefix. However, if it doesn't recognize the prefix, it will assume the this is just a standard URL string, and will create a UrlResource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The Spring Expression Language (SpEL for short) is a powerful expression language that supports querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL but offers additional features, most notably method invocation and basic string templating functionality.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"While there are several other Java expression languages available, OGNL, MVEL, and JBoss EL, to name a few, the Spring Expression Language was created to provide the Spring community with a single well supported expression language that can be used across all the products in the Spring portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the eclipse based SpringSource Tool Suite. That said, SpEL is based on a technology agnostic API allowing other expression language implementations to be integrated should the need arise.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"While SpEL serves as the foundation for expression evaluation within the Spring portfolio, it is not directly tied to Spring and can be used independently. In order to be self contained, many of the examples in this chapter use SpEL as if it were an independent expression language. This requires creating a few bootstrapping infrastructure classes such as the parser. Most Spring users will not need to deal with this infrastructure and will instead only author expression strings for evaluation. An example of this typical use is the integration of SpEL into creating XML or annotated based bean definitions as shown in the section Expression support for defining bean definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"This chapter covers the features of the expression language, its API, and its language syntax. In several places an Inventor and Inventor's Society class are used as the target objects for expression evaluation. These class declarations and the data used to populate them are listed at the end of the chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The previous chapter described the Spring 2.0 and later version's support for AOP using @AspectJ and schema-based aspect definitions. In this chapter we discuss the lower-level Spring AOP APIs and the AOP support used in Spring 1.2 applications. For new applications, we recommend the use of the Spring 2.0 and later AOP support described in the previous chapter, but when working with existing applications, or when reading books and articles, you may come across Spring 1.2 style examples. Spring 3.0 is backwards compatible with Spring 1.2 and everything described in this chapter is fully supported in Spring 3.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Testing is an integral part of enterprise software development. This chapter focuses on the value-add of the IoC principle to unit testing and on the benefits of the Spring Framework's support for integration testing. (A thorough treatment of testing in the enterprise is beyond the scope of this reference manual.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
This part of the reference documentation covers all of those technologies that are absolutely integral to the Spring Framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-core.html
"Foremost amongst these is the Spring Framework's Inversion of Control (IoC) container. A thorough treatment of the Spring Framework's IoC container is closely followed by comprehensive coverage of Spring's Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand, and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-core.html
Coverage of Spring's integration with AspectJ (currently the richest - in terms of features - and certainly most mature AOP implementation in the Java enterprise space) is also provided.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-core.html
"Finally, the adoption of the test-driven-development (TDD) approach to software development is certainly advocated by the Spring team, and so coverage of Spring's support for integration testing is covered (alongside best practices for unit testing). The Spring team has found that the correct use of IoC certainly does make both unit and integration testing easier (in that the presence of setter methods and appropriate constructors on classes makes them easier to wire together in a test without having to set up service locator registries and suchlike)... the chapter dedicated solely to testing will hopefully convince you of this as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-core.html
"Chapter 8, Spring Expression Language (SpEL)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-core.html
"Aspect-Oriented Programming (AOP) complements Object-Oriented Programming (OOP) by providing another way of thinking about program structure. The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns such as transaction management that cut across multiple types and objects. (Such concerns are often termed crosscutting concerns in AOP literature.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"An application can choose to enable JSR-303 Bean Validation once globally, as described in Section 7.8, “Spring 3 Validation”, and use it exclusively for all validation needs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"An application can also register additional Spring Validator instances per DataBinder instance, as described in Section 7.8.3, “Configuring a DataBinder”. This may be useful for plugging in validation logic without the use of annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"There are pros and cons for considering validation as business logic, and Spring offers a design for validation (and data binding) that does not exclude either one of them. Specifically validation should not be tied to the web tier, should be easy to localize and it should be possible to plug in any validator available. Considering the above, Spring has come up with a Validator interface that is both basic ands eminently usable in every layer of an application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Data binding is useful for allowing user input to be dynamically bound to the domain model of an application (or whatever objects you use to process user input). Spring provides the so-called DataBinder to do exactly that. The Validator and the DataBinder make up the validation package, which is primarily used in but not limited to the MVC framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The BeanWrapper is a fundamental concept in the Spring Framework and is used in a lot of places. However, you probably will not have the need to use the BeanWrapper directly. Because this is reference documentation however, we felt that some explanation might be in order. We will explain the BeanWrapper in this chapter since, if you were going to use it at all, you would most likely do so when trying to bind data to objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring's DataBinder and the lower-level BeanWrapper both use PropertyEditors to parse and format property values. The PropertyEditor concept is part of the JavaBeans specification, and is also explained in this chapter. Spring 3 introduces a ""core.convert"" package that provides a general type conversion facility, as well as a higher-level ""format"" package for formatting UI field values. These new packages may be used as simpler alternatives to PropertyEditors, and will also be discussed in this chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring features a Validator interface that you can use to validate objects. The Validator interface works using an Errors object so that while validating, validators can report validation failures to the Errors object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Let's consider a small data object:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
We're going to provide validation behavior for the Person class by implementing the following two methods of the org.springframework.validation.Validator interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
supports(Class) - Can this Validator validate instances of the supplied Class?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Implementing a Validator is fairly straightforward, especially when you know of the ValidationUtils helper class that the Spring Framework also provides.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"As you can see, the static rejectIfEmpty(..) method on the ValidationUtils class is used to reject the 'name' property if it is null or the empty string. Have a look at the Javadoc for the ValidationUtils class to see what functionality it provides besides the example shown previously.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"While it is certainly possible to implement a single Validator class to validate each of the nested objects in a rich object, it may be better to encapsulate the validation logic for each nested class of object in its own Validator implementation. A simple example of a 'rich' object would be a Customer that is composed of two String properties (a first and second name) and a complex Address object. Address objects may be used independently of Customer objects, and so a distinct AddressValidator has been implemented. If you want your CustomerValidator to reuse the logic contained within the AddressValidator class without resorting to copy-and-paste, you can dependency-inject or instantiate an AddressValidator within your CustomerValidator, and use it like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Validation errors are reported to the Errors object passed to the validator. In case of Spring Web MVC you can use <spring:bind/> tag to inspect the error messages, but of course you can also inspect the errors object yourself. More information about the methods it offers can be found from the Javadoc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"We've talked about databinding and validation. Outputting messages corresponding to validation errors is the last thing we need to discuss. In the example we've shown above, we rejected the name and the age field. If we're going to output the error messages by using a MessageSource, we will do so using the error code we've given when rejecting the field ('name' and 'age' in this case). When you call (either directly, or indirectly, using for example the ValidationUtils class) rejectValue or one of the other reject methods from the Errors interface, the underlying implementation will not only register the code you've passed in, but also a number of additional error codes. What error codes it registers is determined by the MessageCodesResolver that is used. By default, the DefaultMessageCodesResolver is used, which for example not only registers a message with the code you gave, but also messages that include the field name you passed to the reject method. So in case you reject a field using rejectValue(""age"", ""too.darn.old""), apart from the too.darn.old code, Spring will also register too.darn.old.age and too.darn.old.age.int (so the first will include the field name and the second will include the type of the field); this is done as a convenience to aid developers in targeting error messages and suchlike.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
More information on the MessageCodesResolver and the default strategy can be found online with the Javadocs for MessageCodesResolver and DefaultMessageCodesResolver respectively.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The org.springframework.beans package adheres to the JavaBeans standard provided by Sun. A JavaBean is simply a class with a default no-argument constructor, which follows a naming convention where (by way of an example) a property named bingoMadness would have a setter method setBingoMadness(..) and a getter method getBingoMadness(). For more information about JavaBeans and the specification, please refer to Sun's website ( java.sun.com/products/javabeans).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"One quite important class in the beans package is the BeanWrapper interface and its corresponding implementation (BeanWrapperImpl). As quoted from the Javadoc, the BeanWrapper offers functionality to set and get property values (individually or in bulk), get property descriptors, and to query properties to determine if they are readable or writable. Also, the BeanWrapper offers support for nested properties, enabling the setting of properties on sub-properties to an unlimited depth. Then, the BeanWrapper supports the ability to add standard JavaBeans PropertyChangeListeners and VetoableChangeListeners, without the need for supporting code in the target class. Last but not least, the BeanWrapper provides support for the setting of indexed properties. The BeanWrapper usually isn't used by application code directly, but by the DataBinder and the BeanFactory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The way the BeanWrapper works is partly indicated by its name: it wraps a bean to perform actions on that bean, like setting and retrieving properties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework's IoC container. The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object. ApplicationContext is a sub-interface of BeanFactory. It adds easier integration with Spring's AOP features; message resource handling (for use in internationalization), event publication; and application-layer specific contexts such as the WebApplicationContext for use in web applications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext adds more enterprise-specific functionality. The ApplicationContext is a complete superset of the BeanFactory, and is used exclusively in this chapter in descriptions of Spring's IoC container. For more information on using the BeanFactory instead of the ApplicationContext, refer to Section 5.15, “The BeanFactory”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The interface org.springframework.context.ApplicationContext represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the aforementioned beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It allows you to express the objects that compose your application and the rich interdependencies between such objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Several implementations of the ApplicationContext interface are supplied out-of-the-box with Spring. In standalone applications it is common to create an instance of ClassPathXmlApplicationContext or FileSystemXmlApplicationContext. While XML has been the traditional format for defining configuration metadata you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate J2EE web descriptor XML in the web.xml file of the application will typically suffice (see Section 5.14.4, “Convenient ApplicationContext instantiation for web applications”). If you are using the SpringSource Tool Suite Eclipse-powered development environment or Spring Roo this boilerplate configuration can be easily created with few mouse clicks or keystrokes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following diagram is a high-level view of how Spring works. Your application classes are combined with configuration metadata so that after the ApplicationContext is created and initialized, you have a fully configured and executable system or application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata; this configuration metadata represents how you as an application developer tell the Spring container to instantiate, configure, and assemble the objects in your application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For information about using other forms of metadata with the Spring container, see:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Annotation-based configuration: Spring 2.5 introduced support for annotation-based configuration metadata.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Java-based configuration: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the @Configuration, @Bean, @Import and @DependsOn annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata shows these beans configured as <bean/> elements inside a top-level <beans/> element.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"These bean definitions correspond to the actual objects that make up your application. Typically you define service layer objects, data access objects (DAOs), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so forth. Typically one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring's integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows the basic structure of XML-based configuration metadata:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The id attribute is a string that you use to identify the individual bean definition. The class attribute defines the type of the bean and uses the fully qualified classname. The value of the id attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example; see Dependencies for more information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Instantiating a Spring IoC container is straightforward. The location path or paths supplied to an ApplicationContext constructor are actually resource strings that allow the container to load configuration metadata from a variety of external resources such as the local file system, from the Java CLASSPATH, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"After you learn about Spring's IoC container, you may want to know more about Spring's Resource abstraction, as described in Chapter 6, Resources, which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, Resource paths are used to construct applications contexts as described in Section 6.7, “Application contexts and Resource paths”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows the service layer objects (services.xml) configuration file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows the data access objects daos.xml file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the preceding example, the service layer consists of the class PetStoreServiceImpl, and two data access objects of the type SqlMapAccountDao and SqlMapItemDao are based on the iBatis Object/Relational mapping framework. The property name element refers to the name of the JavaBean property, and the ref element refers to the name of another bean definition. This linkage between id and ref elements expresses the dependency between collaborating objects. For details of configuring an object's dependencies, see Dependencies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
It can be useful to have bean definitions span multiple XML files. Often each individual XML configuration file represents a logical layer or module in your architecture.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This class represents a resource which should be obtained from the classpath. This uses either the thread context class loader, a given class loader, or a given class for loading resources.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"This Resource implementation supports resolution as java.io.File if the class path resource resides in the file system, but not for classpath resources which reside in a jar and have not been expanded (by the servlet engine, or whatever the environment is) to the filesystem. To address this the various Resource implementations always support resolution as a java.net.URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"A ClassPathResource is created by Java code explicitly using the ClassPathResource constructor, but will often be created implicitly when you call an API method which takes a String argument which is meant to represent a path. For the latter case, a JavaBeans PropertyEditor will recognize the special prefix classpath:on the string path, and create a ClassPathResource in that case.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"This is a Resource implementation for java.io.File handles. It obviously supports resolution as a File, and as a URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"This is a Resource implementation for ServletContext resources, interpreting relative paths within the relevant web application's root directory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"This always supports stream access and URL access, but only allows java.io.File access when the web application archive is expanded and the resource is physically on the filesystem. Whether or not it's expanded and on the filesystem like this, or accessed directly from the JAR or somewhere else like a DB (it's conceivable) is actually dependent on the Servlet container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"A Resource implementation for a given InputStream. This should only be used if no specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any of the file-based Resource implementations where possible.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"In contrast to other Resource implementations, this is a descriptor for an already opened resource - therefore returning true from isOpen(). Do not use it if you need to keep the resource descriptor somewhere, or if you need to read a stream multiple times.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
This is a Resource implementation for a given byte array. It creates a ByteArrayInputStream for the given byte array.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"It's useful for loading content from any given byte array, without having to resort to a single-use InputStreamResource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
The ResourceLoader interface is meant to be implemented by objects that can return (i.e. load) Resource instances.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"All application contexts implement the ResourceLoader interface, and therefore all application contexts may be used to obtain Resource instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"When you call getResource() on a specific application context, and the location path specified doesn't have a specific prefix, you will get back a Resource type that is appropriate to that particular application context. For example, assume the following snippet of code was executed against a ClassPathXmlApplicationContext instance:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"What would be returned would be a ClassPathResource; if the same method was executed against a FileSystemXmlApplicationContext instance, you'd get back a FileSystemResource. For a WebApplicationContext, you'd get back a ServletContextResource, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"As such, you can load resources in a fashion appropriate to the particular application context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"On the other hand, you may also force ClassPathResource to be used, regardless of the application context type, by specifying the special classpath: prefix:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Similarly, one can force a UrlResource to be used by specifying any of the standard java.net.URL prefixes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
The following table summarizes the strategy for converting Strings to Resources:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Loaded from the classpath.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Loaded as a URL, from the filesystem. [1]",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Loaded as a URL.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Depends on the underlying ApplicationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"[1] But see also Section 6.7.3, “FileSystemResource caveats”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The ResourceLoaderAware interface is a special marker interface, identifying objects that expect to be provided with a ResourceLoader reference.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
This section introduces the simple use of SpEL interfaces and its expression language. The complete language reference can be found in the section Language Reference.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The following code introduces the SpEL API to evaluate the literal string expression 'Hello World'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The value of the message variable is simply 'Hello World'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The SpEL classes and interfaces you are most likely to use are located in the packages org.springframework.expression and its sub packages and spel.support.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The interface ExpressionParser is responsible for parsing an expression string. In this example the expression string is a string literal denoted by the surrounding single quotes. The interface Expression is responsible for evaluating the previously defined expression string. There are two exceptions that can be thrown, ParseException and EvaluationException when calling 'parser.parseExpression' and 'exp.getValue' respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"SpEL supports a wide range of features, such as calling methods, accessing properties, and calling constructors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"As an example of method invocation, we call the 'concat' method on the string literal.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The value of message is now 'Hello World!'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"As an example of calling a JavaBean property, the String property 'Bytes' can be called as shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Public fields may also be accessed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The String's constructor can be called instead of using a string literal.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Note the use of the generic method public <T> T getValue(Class<T> desiredResultType). Using this method removes the need to cast the value of the expression to the desired result type. An EvaluationException will be thrown if the value cannot be cast to the type T or converted using the registered type converter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The more common usage of SpEL is to provide an expression string that is evaluated against a specific object instance (called the root object). There are two options here and which to choose depends on whether the object against which the expression is being evaluated will be changing with each call to evaluate the expression. In the following example we retrieve the name property from an instance of the Inventor class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"In the last line, the value of the string variable 'name' will be set to ""Nikola Tesla"". The class StandardEvaluationContext is where you can specify which object the ""name"" property will be evaluated against. This is the mechanism to use if the root object is unlikely to change, it can simply be set once in the evaluation context. If the root object is likely to change repeatedly, it can be supplied on each call to getValue, as this next example shows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
In this case the inventor tesla has been supplied directly to getValue and the expression evaluation infrastructure creates and manages a default evaluation context internally - it did not require one to be supplied.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The StandardEvaluationContext is relatively expensive to construct and during repeated usage it builds up cached state that enables subsequent expression evaluations to be performed more quickly. For this reason it is better to cache and reuse them where possible, rather than construct a new one for each expression evaluation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
In some cases it can be desirable to use a configured evaluation context and yet still supply a different root object on each call to getValue. getValue allows both to be specified on the same call. In these situations the root object passed on the call is considered to override any (which maybe null) specified on the evaluation context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"In standalone usage of SpEL there is a need to create the parser, parse expressions and perhaps provide evaluation contexts and a root context object. However, more common usage is to provide only the SpEL expression string as part of a configuration file, for example for Spring bean or Spring Web Flow definitions. In this case, the parser, evaluation context, root object and any predefined variables are all set up implicitly, requiring the user to specify nothing other than the expressions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"As a final introductory example, the use of a boolean operator is shown using the Inventor object in the previous example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The interface EvaluationContext is used when evaluating an expression to resolve properties, methods, fields, and to help perform type conversion. The out-of-the-box implementation, StandardEvaluationContext, uses reflection to manipulate the object, caching java.lang.reflect's Method, Field, and Constructor instances for increased performance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The StandardEvaluationContext is where you may specify the root object to evaluate against via the method setRootObject() or passing the root object into the constructor. You can also specify variables and functions that will be used in the expression using the methods setVariable() and registerFunction(). The use of variables and functions are described in the language reference sections Variables and Functions. The StandardEvaluationContext is also where you can register custom ConstructorResolvers, MethodResolvers, and PropertyAccessors to extend how SpEL evaluates expressions. Please refer to the JavaDoc of these classes for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"By default SpEL uses the conversion service available in Spring core (org.springframework.core.convert.ConversionService). This conversion service comes with many converters built in for common conversions but is also fully extensible so custom conversions between types can be added. Additionally it has the key capability that it is generics aware. This means that when working with generic types in expressions, SpEL will attempt conversions to maintain type correctness for any objects it encounters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"What does this mean in practice? Suppose assignment, using setValue(), is being used to set a List property. The type of the property is actually List<Boolean>. SpEL will recognize that the elements of the list need to be converted to Boolean before being placed in it. A simple example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
SpEL expressions can be used with XML or annotation based configuration metadata for defining BeanDefinitions. In both cases the syntax to define the expression is of the form #{ <expression string> }.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The variable 'systemProperties' is predefined, so you can use it in your expressions as shown below. Note that you do not have to prefix the predefined variable with the '#' symbol in this context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Let's look at how Spring handles the crucial pointcut concept.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Spring's pointcut model enables pointcut reuse independent of advice types. It's possible to target different advice using the same pointcut.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The org.springframework.aop.Pointcut interface is the central interface, used to target advices to particular classes and methods. The complete interface is shown below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Splitting the Pointcut interface into two parts allows reuse of class and method matching parts, and fine-grained composition operations (such as performing a ""union"" with another method matcher).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The ClassFilter interface is used to restrict the pointcut to a given set of target classes. If the matches() method always returns true, all target classes will be matched:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The MethodMatcher interface is normally more important. The complete interface is shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The matches(Method, Class) method is used to test whether this pointcut will ever match a given method on a target class. This evaluation can be performed when an AOP proxy is created, to avoid the need for a test on every method invocation. If the 2-argument matches method returns true for a given method, and the isRuntime() method for the MethodMatcher returns true, the 3-argument matches method will be invoked on every method invocation. This enables a pointcut to look at the arguments passed to the method invocation immediately before the target advice is to execute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Most MethodMatchers are static, meaning that their isRuntime() method returns false. In this case, the 3-argument matches method will never be invoked.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If possible, try to make pointcuts static, allowing the AOP framework to cache the results of pointcut evaluation when an AOP proxy is created.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring supports operations on pointcuts: notably, union and intersection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Union means the methods that either pointcut matches.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Intersection means the methods that both pointcuts match.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Union is usually more useful.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Pointcuts can be composed using the static methods in the org.springframework.aop.support.Pointcuts class, or using the ComposablePointcut class in the same package. However, using AspectJ pointcut expressions is usually a simpler approach.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Since 2.0, the most important type of pointcut used by Spring is org.springframework.aop.aspectj.AspectJExpressionPointcut. This is a pointcut that uses an AspectJ supplied library to parse an AspectJ pointcut expression string.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
See the previous chapter for a discussion of supported AspectJ pointcut primitives.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Spring provides several convenient pointcut implementations. Some can be used out of the box; others are intended to be subclassed in application-specific pointcuts.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Static pointcuts are based on method and target class, and cannot take into account the method's arguments. Static pointcuts are sufficient - and best - for most usages. It's possible for Spring to evaluate a static pointcut only once, when a method is first invoked: after that, there is no need to evaluate the pointcut again with each method invocation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Let's consider some static pointcut implementations included with Spring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"One obvious way to specify static pointcuts is regular expressions. Several AOP frameworks besides Spring make this possible. org.springframework.aop.support.JdkRegexpMethodPointcut is a generic regular expression pointcut, using the regular expression support in JDK 1.4+.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Using the JdkRegexpMethodPointcut class, you can provide a list of pattern Strings. If any of these is a match, the pointcut will evaluate to true. (So the result is effectively the union of these pointcuts.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The usage is shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring provides a convenience class, RegexpMethodPointcutAdvisor, that allows us to also reference an Advice (remember that an Advice can be an interceptor, before advice, throws advice etc.). Behind the scenes, Spring will use a JdkRegexpMethodPointcut. Using RegexpMethodPointcutAdvisor simplifies wiring, as the one bean encapsulates both pointcut and advice, as shown below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
RegexpMethodPointcutAdvisor can be used with any Advice type.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An important type of static pointcut is a metadata-driven pointcut. This uses the values of metadata attributes: typically, source-level metadata.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account method arguments, as well as static information. This means that they must be evaluated with every method invocation; the result cannot be cached, as arguments will vary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Dependency Injection should make your code less dependent on the container than it would be with traditional Java EE development. The POJOs that make up your application should be testable in JUnit or TestNG tests, with objects simply instantiated using the new operator, without Spring or any other container. You can use mock objects (in conjunction with other valuable testing techniques) to test your code in isolation. If you follow the architecture recommendations for Spring, the resulting clean layering and componentization of your codebase will facilitate easier unit testing. For example, you can test service layer objects by stubbing or mocking DAO or Repository interfaces, without needing to access persistent data while running unit tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"True unit tests typically run extremely quickly, as there is no runtime infrastructure to set up. Emphasizing true unit tests as part of your development methodology will boost your productivity. You may not need this section of the testing chapter to help you write effective unit tests for your IoC-based applications. For certain unit testing scenarios, however, the Spring Framework provides the following mock objects and testing support classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.mock.env package contains mock implementations of the Environment and PropertySource abstractions introduced in Spring 3.1 (see Section 3.3, “Environment Abstraction” and Section 3.4, “PropertySource Abstraction”). MockEnvironment and MockPropertySource are useful for developing out-of-container tests for code that depends on environment-specific properties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.mock.jndi package contains an implementation of the JNDI SPI, which you can use to set up a simple JNDI environment for test suites or stand-alone applications. If, for example, JDBC DataSources get bound to the same JNDI names in test code as within a Java EE container, you can reuse both application code and configuration in testing scenarios without modification.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.mock.web package contains a comprehensive set of Servlet API mock objects, targeted at usage with Spring's Web MVC framework, which are useful for testing web contexts and controllers. These mock objects are generally more convenient to use than dynamic mock objects such as EasyMock or existing Servlet API mock objects such as MockObjects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.mock.web.portlet package contains a set of Portlet API mock objects, targeted at usage with Spring's Portlet MVC framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.test.util package contains ReflectionTestUtils, which is a collection of reflection-based utility methods. Developers use these methods in unit and integration testing scenarios in which they need to set a non-public field or invoke a non-public setter method when testing application code involving, for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
ORM frameworks such as JPA and Hibernate that condone private or protected field access as opposed to public setter methods for properties in a domain entity.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring's support for annotations such as @Autowired, @Inject, and @Resource, which provides dependency injection for private or protected fields, setter methods, and configuration methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.test.web package contains ModelAndViewAssert, which you can use in combination with JUnit, TestNG, or any other testing framework for unit tests dealing with Spring MVC ModelAndView objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To test your Spring MVC Controllers, use ModelAndViewAssert combined with MockHttpServletRequest, MockHttpSession, and so on from the org.springframework.mock.web package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
It is important to be able to perform some integration testing without requiring deployment to your application server or connecting to other enterprise infrastructure. This will enable you to test things such as:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The correct wiring of your Spring IoC container contexts.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Data access using JDBC or an ORM tool. This would include such things as the correctness of SQL statements, Hibernate queries, JPA entity mappings, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring Framework provides first-class support for integration testing in the spring-test module. The name of the actual JAR file might include the release version and might also be in the long org.springframework.test form, depending on where you get it from (see the section on Dependency Management for an explanation). This library includes the org.springframework.test package, which contains valuable classes for integration testing with a Spring container. This testing does not rely on an application server or other deployment environment. Such tests are slower to run than unit tests but much faster than the equivalent Cactus tests or remote tests that rely on deployment to an application server.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In Spring 2.5 and later, unit and integration testing support is provided in the form of the annotation-driven Spring TestContext Framework. The TestContext framework is agnostic of the actual testing framework in use, thus allowing instrumentation of tests in various environments including JUnit, TestNG, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As of Spring 3.0, the legacy JUnit 3.8 base class hierarchy (i.e., AbstractDependencyInjectionSpringContextTests, AbstractTransactionalDataSourceSpringContextTests, etc.) is officially deprecated and will be removed in a later release. Any test classes based on this code should be migrated to the Spring TestContext Framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As of Spring 3.1, the JUnit 3.8 base classes in the Spring TestContext Framework (i.e., AbstractJUnit38SpringContextTests and AbstractTransactionalJUnit38SpringContextTests) and @ExpectedException have been officially deprecated and will be removed in a later release. Any test classes based on this code should be migrated to the JUnit 4 or TestNG support provided by the Spring TestContext Framework. Similarly, any test methods annotated with @ExpectedException should be modified to use the built-in support for expected exceptions in JUnit and TestNG.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Spring's integration testing support has the following primary goals:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
To manage Spring IoC container caching between test execution.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
To provide Dependency Injection of test fixture instances.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
To provide transaction management appropriate to integration testing.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
To supply Spring-specific base classes that assist developers in writing integration tests.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The next few sections describe each goal and provide links to implementation and configuration details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring TestContext Framework provides consistent loading of Spring ApplicationContexts and WebApplicationContexts as well as caching of those contexts. Support for the caching of loaded contexts is important, because startup time can become an issue — not because of the overhead of Spring itself, but because the objects instantiated by the Spring container take time to instantiate. For example, a project with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to load the mapping files, and incurring that cost before running every test in every test fixture leads to slower overall test runs that reduce developer productivity.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Test classes typically declare either an array of resource locations for XML configuration metadata — often in the classpath — or an array of annotated classes that is used to configure the application. These locations or classes are the same as or similar to those specified in web.xml or other deployment configuration files.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"One of the key components of Spring is the AOP framework. While the Spring IoC container does not depend on AOP, meaning you do not need to use AOP if you don't want to, AOP complements Spring IoC to provide a very capable middleware solution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring 2.0 introduces a simpler and more powerful way of writing custom aspects using either a schema-based approach or the @AspectJ annotation style. Both of these styles offer fully typed advice and use of the AspectJ pointcut language, while still using Spring AOP for weaving.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The Spring 2.0 schema- and @AspectJ-based AOP support is discussed in this chapter. Spring 2.0 AOP remains fully backwards compatible with Spring 1.2 AOP, and the lower-level AOP support offered by the Spring 1.2 APIs is discussed in the following chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
AOP is used in the Spring Framework to...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"... provide declarative enterprise services, especially as a replacement for EJB declarative services. The most important such service is declarative transaction management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"... allow users to implement custom aspects, complementing their use of OOP with AOP.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are interested only in generic declarative services or other pre-packaged declarative middleware services such as pooling, you do not need to work directly with Spring AOP, and can skip most of this chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Let us begin by defining some central AOP concepts and terminology. These terms are not Spring-specific... unfortunately, AOP terminology is not particularly intuitive; however, it would be even more confusing if Spring used its own terminology.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Advice: action taken by an aspect at a particular join point. Different types of advice include ""around,"" ""before"" and ""after"" advice. (Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors around the join point.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented using runtime proxies, this object will always be a proxied object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Types of advice:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After throwing advice: Advice to be executed if a method exits by throwing an exception.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the proceed() method on the JoinPoint used for around advice, and hence cannot fail to invoke it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In Spring 2.0, all advice parameters are statically typed, so that you work with advice parameters of the appropriate type (the type of the return value from a method execution for example) rather than Object arrays.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The concept of join points, matched by pointcuts, is the key to AOP which distinguishes it from older technologies offering only interception. Pointcuts enable advice to be targeted independently of the Object-Oriented hierarchy. For example, an around advice providing declarative transaction management can be applied to a set of methods spanning multiple objects (such as all business operations in the service layer).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Setting and getting properties is done using the setPropertyValue(s) and getPropertyValue(s) methods that both come with a couple of overloaded variants. They're all described in more detail in the Javadoc Spring comes with. What's important to know is that there are a couple of conventions for indicating properties of an object. A couple of examples:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Below you'll find some examples of working with the BeanWrapper to get and set properties.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"(This next section is not vitally important to you if you're not planning to work with the BeanWrapper directly. If you're just using the DataBinder and the BeanFactory and their out-of-the-box implementation, you should skip ahead to the section about PropertyEditors.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Consider the following two classes:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The following code snippets show some examples of how to retrieve and manipulate some of the properties of instantiated Companies and Employees:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring uses the concept of PropertyEditors to effect the conversion between an Object and a String. If you think about it, it sometimes might be handy to be able to represent properties in a different way than the object itself. For example, a Date can be represented in a human readable way (as the String '2007-14-09'), while we're still able to convert the human readable form back to the original date (or even better: convert any date entered in a human readable form, back to Date objects). This behavior can be achieved by registering custom editors, of type java.beans.PropertyEditor. Registering custom editors on a BeanWrapper or alternately in a specific IoC container as mentioned in the previous chapter, gives it the knowledge of how to convert properties to the desired type. Read more about PropertyEditors in the Javadoc of the java.beans package provided by Sun.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
A couple of examples where property editing is used in Spring:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"setting properties on beans is done using PropertyEditors. When mentioning java.lang.String as the value of a property of some bean you're declaring in XML file, Spring will (if the setter of the corresponding property has a Class-parameter) use the ClassEditor to try to resolve the parameter to a Class object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
parsing HTTP request parameters in Spring's MVC framework is done using all kinds of PropertyEditors that you can manually bind in all subclasses of the CommandController.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring has a number of built-in PropertyEditors to make life easy. Each of those is listed below and they are all located in the org.springframework.beans.propertyeditors package. Most, but not all (as indicated below), are registered by default by BeanWrapperImpl. Where the property editor is configurable in some fashion, you can of course still register your own variant to override the default one:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring uses the java.beans.PropertyEditorManager to set the search path for property editors that might be needed. The search path also includes sun.bean.editors, which includes PropertyEditor implementations for types such as Font, Color, and most of the primitive types. Note also that the standard JavaBeans infrastructure will automatically discover PropertyEditor classes (without you having to register them explicitly) if they are in the same package as the class they handle, and have the same name as that class, with 'Editor' appended; for example, one could have the following class and package structure, which would be sufficient for the FooEditor class to be recognized and used as the PropertyEditor for Foo-typed properties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Note that you can also use the standard BeanInfo JavaBeans mechanism here as well (described in not-amazing-detail here). Find below an example of using the BeanInfo mechanism for explicitly registering one or more PropertyEditor instances with the properties of an associated class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Here is the Java source code for the referenced FooBeanInfo class. This would associate a CustomNumberEditor with the age property of the Foo class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When setting bean properties as a string value, a Spring IoC container ultimately uses standard JavaBeans PropertyEditors to convert these Strings to the complex type of the property. Spring pre-registers a number of custom PropertyEditors (for example, to convert a classname expressed as a string into a real Class object). Additionally, Java's standard JavaBeans PropertyEditor lookup mechanism allows a PropertyEditor for a class simply to be named appropriately and placed in the same package as the class it provides support for, to be found automatically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"If there is a need to register other custom PropertyEditors, there are several mechanisms available. The most manual approach, which is not normally convenient or recommended, is to simply use the registerCustomEditor() method of the ConfigurableBeanFactory interface, assuming you have a BeanFactory reference. Another, slightly more convenient, mechanism is to use a special bean factory post-processor called CustomEditorConfigurer. Although bean factory post-processors can be used with BeanFactory implementations, the CustomEditorConfigurer has a nested property setup, so it is strongly recommended that it is used with the ApplicationContext, where it may be deployed in similar fashion to any other bean, and automatically detected and applied.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Note that all bean factories and application contexts automatically use a number of built-in property editors, through their use of something called a BeanWrapper to handle property conversions. The standard property editors that the BeanWrapper registers are listed in the previous section. Additionally, ApplicationContexts also override or add an additional number of editors to handle resource lookups in a manner appropriate to the specific application context type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Standard JavaBeans PropertyEditor instances are used to convert property values expressed as strings to the actual complex type of the property. CustomEditorConfigurer, a bean factory post-processor, may be used to conveniently add support for additional PropertyEditor instances to an ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Consider a user class ExoticType, and another class DependsOnExoticType which needs ExoticType set as a property:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When things are properly set up, we want to be able to assign the type property as a string, which a PropertyEditor will behind the scenes convert into an actual ExoticType instance:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The PropertyEditor implementation could look similar to this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Finally, we use CustomEditorConfigurer to register the new PropertyEditor with the ApplicationContext, which will then be able to use it as needed:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Another mechanism for registering property editors with the Spring container is to create and use a PropertyEditorRegistrar. This interface is particularly useful when you need to use the same set of property editors in several different situations: write a corresponding registrar and reuse that in each case. PropertyEditorRegistrars work in conjunction with an interface called PropertyEditorRegistry, an interface that is implemented by the Spring BeanWrapper (and DataBinder). PropertyEditorRegistrars are particularly convenient when used in conjunction with the CustomEditorConfigurer (introduced here), which exposes a property called setPropertyEditorRegistrars(..): PropertyEditorRegistrars added to a CustomEditorConfigurer in this fashion can easily be shared with DataBinder and Spring MVC Controllers. Furthermore, it avoids the need for synchronization on custom editors: a PropertyEditorRegistrar is expected to create fresh PropertyEditor instances for each bean creation attempt.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Using a PropertyEditorRegistrar is perhaps best illustrated with an example. First off, you need to create your own PropertyEditorRegistrar implementation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
See also the org.springframework.beans.support.ResourceEditorRegistrar for an example PropertyEditorRegistrar implementation. Notice how in its implementation of the registerCustomEditors(..) method it creates new instances of each property editor.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Next we configure a CustomEditorConfigurer and inject an instance of our CustomPropertyEditorRegistrar into it:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple Resource locations, as was shown in the previous section. Alternatively, use one or more occurrences of the <import/> element to load bean definitions from another file or files. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the preceding example, external bean definitions are loaded from three files, services.xml, messageSource.xml, and themeSource.xml. All location paths are relative to the definition file doing the importing, so services.xml must be in the same directory or classpath location as the file doing the importing, while messageSource.xml and themeSource.xml must be in a resources location below the location of the importing file. As you can see, a leading slash is ignored, but given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <beans/> element, must be valid XML bean definitions according to the Spring Schema or DTD.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It is possible, but not recommended, to reference files in parent directories using a relative ""../"" path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for ""classpath:"" URLs (for example, ""classpath:../services.xml""), where the runtime resolution process chooses the ""nearest"" classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can always use fully qualified resource locations instead of relative paths: for example, ""file:C:/config/services.xml"" or ""classpath:/config/services.xml"". However, be aware that you are coupling your application's configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations, for example, through ""${...}"" placeholders that are resolved against JVM system properties at runtime.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. Using the method T getBean(String name, Class<T> requiredType) you can retrieve instances of your beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The ApplicationContext enables you to read bean definitions and access them as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You use getBean() to retrieve instances of your beans. The ApplicationContext interface has a few other methods for retrieving beans, but ideally your application code should never use them. Indeed, your application code should have no calls to the getBean() method at all, and thus no dependency on Spring APIs at all. For example, Spring's integration with web frameworks provides for dependency injection for various web framework classes such as controllers and JSF-managed beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container, for example, in the form of XML <bean/> definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A package-qualified class name: typically the actual implementation class of the bean being defined.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
References to other beans that are needed for the bean to do its work; these references are also called collaborators or dependencies.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Other configuration settings to set in the newly created object, for example, the number of connections to use in a bean that manages a connection pool, or the size limit of the pool.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This metadata translates to a set of properties that make up each bean definition.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In addition to bean definitions that contain information on how to create a specific bean, the ApplicationContext implementations also permit the registration of existing objects that are created outside the container, by users. This is done by accessing the ApplicationContext's BeanFactory via the method getBeanFactory() which returns the BeanFactory implementation DefaultListableBeanFactory. DefaultListableBeanFactory supports this registration through the methods registerSingleton(..) and registerBeanDefinition(..). However, typical applications work solely with beans defined through metadata bean definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier, but if it requires more than one, the extra ones can be considered aliases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In XML-based configuration metadata, you use the id and/or name attributes to specify the bean identifier(s). The id attribute allows you to specify exactly one id. Conventionally these names are alphanumeric ('myBean', 'fooService', etc), but may special characters as well. If you want to introduce other aliases to the bean, you can also specify them in the name attribute, separated by a comma (,), semicolon (;), or white space. As a historical note, in versions prior to Spring 3.1, the id attribute was typed as an xsd:ID, which constrained possible characters. As of 3.1, it is now xsd:string. Note that bean id uniqueness is still enforced by the container, though no longer by XML parsers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You are not required to supply a name or id for a bean. If no name or id is supplied explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the ref element or Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using inner beans and autowiring collaborators.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter, and are camel-cased from then on. Examples of such names would be (without quotes) 'accountManager', 'accountService', 'userDao', 'loginController', and so forth.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Naming beans consistently makes your configuration easier to read and understand, and if you are using Spring AOP it helps a lot when applying advice to a set of beans related by name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the id attribute, and any number of other names in the name attribute. These names can be equivalent aliases to the same bean, and are useful for some situations, such as allowing each component in an application to refer to a common dependency by using a bean name that is specific to that component itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the <alias/> element to accomplish this.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In this case, a bean in the same container which is named fromName, may also after the use of this alias definition, be referred to as toName.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For example, the configuration metadata for subsystem A may refer to a DataSource via the name 'subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource via the name 'subsystemB-dataSource'. When composing the main application that uses both these subsystems the main application refers to the DataSource via the name 'myApp-dataSource'. To have all three names refer to the same object you add to the MyApp configuration metadata the following aliases definitions:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When a class implements ResourceLoaderAware and is deployed into an application context (as a Spring-managed bean), it is recognized as ResourceLoaderAware by the application context. The application context will then invoke the setResourceLoader(ResourceLoader), supplying itself as the argument (remember, all application contexts in Spring implement the ResourceLoader interface).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Of course, since an ApplicationContext is a ResourceLoader, the bean could also implement the ApplicationContextAware interface and use the supplied application context directly to load resources, but in general, it's better to use the specialized ResourceLoader interface if that's all that's needed. The code would just be coupled to the resource loading interface, which can be considered a utility interface, and not the whole Spring ApplicationContext interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"As of Spring 2.5, you can rely upon autowiring of the ResourceLoader as an alternative to implementing the ResourceLoaderAware interface. The ""traditional"" constructor and byType autowiring modes (as described in Section 5.4.5, “Autowiring collaborators”) are now capable of providing a dependency of type ResourceLoader for either a constructor argument or setter method parameter respectively. For more flexibility (including the ability to autowire fields and multiple parameter methods), consider using the new annotation-based autowiring features. In that case, the ResourceLoader will be autowired into a field, constructor argument, or method parameter that is expecting the ResourceLoader type as long as the field, constructor, or method in question carries the @Autowired annotation. For more information, see Section 5.9.2, “@Autowired”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"If the bean itself is going to determine and supply the resource path through some sort of dynamic process, it probably makes sense for the bean to use the ResourceLoader interface to load resources. Consider as an example the loading of a template of some sort, where the specific resource that is needed depends on the role of the user. If the resources are static, it makes sense to eliminate the use of the ResourceLoader interface completely, and just have the bean expose the Resource properties it needs, and expect that they will be injected into it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"What makes it trivial to then inject these properties, is that all application contexts register and use a special JavaBeans PropertyEditor which can convert String paths to Resource objects. So if myBean has a template property of type Resource, it can be configured with a simple string for that resource, as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Note that the resource path has no prefix, so because the application context itself is going to be used as the ResourceLoader, the resource itself will be loaded via a ClassPathResource, FileSystemResource, or ServletContextResource (as appropriate) depending on the exact type of the context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"If there is a need to force a specific Resource type to be used, then a prefix may be used. The following two examples show how to force a ClassPathResource and a UrlResource (the latter being used to access a filesystem file).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
An application context constructor (for a specific application context type) generally takes a string or array of strings as the location path(s) of the resource(s) such as XML files that make up the definition of the context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"When such a location path doesn't have a prefix, the specific Resource type built from that path and used to load the bean definitions, depends on and is appropriate to the specific application context. For example, if you create a ClassPathXmlApplicationContext as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The bean definitions will be loaded from the classpath, as a ClassPathResource will be used. But if you create a FileSystemXmlApplicationContext as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The bean definition will be loaded from a filesystem location, in this case relative to the current working directory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Note that the use of the special classpath prefix or a standard URL prefix on the location path will override the default type of Resource created to load the definition. So this FileSystemXmlApplicationContext...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"... will actually load its bean definitions from the classpath. However, it is still a FileSystemXmlApplicationContext. If it is subsequently used as a ResourceLoader, any unprefixed paths will still be treated as filesystem paths.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The ClassPathXmlApplicationContext exposes a number of constructors to enable convenient instantiation. The basic idea is that one supplies merely a string array containing just the filenames of the XML files themselves (without the leading path information), and one also supplies a Class; the ClassPathXmlApplicationContext will derive the path information from the supplied class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
An example will hopefully make this clear. Consider a directory layout that looks like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
A ClassPathXmlApplicationContext instance composed of the beans defined in the 'services.xml' and 'daos.xml' could be instantiated like so...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
Please do consult the Javadocs for the ClassPathXmlApplicationContext class for details of the various constructors.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"One use for this mechanism is when doing component-style application assembly. All components can 'publish' context definition fragments to a well-known location path, and when the final application context is created using the same path prefixed via classpath*:, all component fragments will be picked up automatically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Note that this wildcarding is specific to use of resource paths in application context constructors (or when using the PathMatcher utility class hierarchy directly), and is resolved at construction time. It has nothing to do with the Resource type itself. It's not possible to use the classpath*: prefix to construct an actual Resource, as a resource points to just one resource at a time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"When the path location contains an Ant-style pattern, for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"... the resolver follows a more complex but defined procedure to try to resolve the wildcard. It produces a Resource for the path up to the last non-wildcard segment and obtains a URL from it. If this URL is not a ""jar:"" URL or container-specific variant (e.g. ""zip:"" in WebLogic, ""wsjar"" in WebSphere, etc.), then a java.io.File is obtained from it and used to resolve the wildcard by traversing the filesystem. In the case of a jar URL, the resolver either gets a java.net.JarURLConnection from it or manually parses the jar URL and then traverses the contents of the jar file to resolve the wildcards.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"If the specified path is already a file URL (either explicitly, or implicitly because the base ResourceLoader is a filesystem one, then wildcarding is guaranteed to work in a completely portable fashion.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"If the specified path is a classpath location, then the resolver must obtain the last non-wildcard path segment URL via a Classloader.getResource() call. Since this is just a node of the path (not the file at the end) it is actually undefined (in the ClassLoader Javadocs) exactly what sort of a URL is returned in this case. In practice, it is always a java.io.File representing the directory, where the classpath resource resolves to a filesystem location, or a jar URL of some sort, where the classpath resource resolves to a jar location. Still, there is a portability concern on this operation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to get a java.net.JarURLConnection from it, or manually parse the jar URL, to be able to walk the contents of the jar, and resolve the wildcard. This will work in most environments, but will fail in others, and it is strongly recommended that the wildcard resolution of resources coming from jars be thoroughly tested in your specific environment before you rely on it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"When constructing an XML-based application context, a location string may use the special classpath*: prefix:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"This special prefix specifies that all classpath resources that match the given name must be obtained (internally, this essentially happens via a ClassLoader.getResources(...) call), and then merged to form the final application context definition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"You can also refer to other bean properties by name, for example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The @Value annotation can be placed on fields, methods and method/constructor parameters to specify a default value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Here is an example to set the default value of a field variable.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The equivalent but on a property setter method is shown below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Autowired methods and constructors can also use the @Value annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The types of literal expressions supported are strings, numeric values (int, real, hex), boolean and null. Strings are delimited by single quotes. To put a single quote itself in a string, use two single quote characters. The following listing shows simple usage of literals. Typically they would not be used in isolation like this but rather as part of a more complex expression, for example using a literal on one side of a logical comparison operator.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Numbers support the use of the negative sign, exponential notation, and decimal points. By default real numbers are parsed using Double.parseDouble().",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Navigating with property references is easy, just use a period to indicate a nested property value. The instances of Inventor class, pupin and tesla, were populated with data listed in the section Classes used in the examples. To navigate ""down"" and get Tesla's year of birth and Pupin's city of birth the following expressions are used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Case insensitivity is allowed for the first letter of property names. The contents of arrays and lists are obtained using square bracket notation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The contents of maps are obtained by specifying the literal key value within the brackets. In this case, because keys for the Officers map are strings, we can specify string literals.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Lists can be expressed directly in an expression using {} notation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"{} by itself means an empty list. For performance reasons, if the list is itself entirely composed of fixed literals then a constant list is created to represent the expression, rather than building a new list on each evaluation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Arrays can be built using the familiar Java syntax, optionally supplying an initializer to have the array populated at construction time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
It is not currently allowed to supply an initializer when constructing a multi-dimensional array.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Methods are invoked using typical Java programming syntax. You may also invoke methods on literals. Varargs are also supported.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The relational operators; equal, not equal, less than, less than or equal, greater than, and greater than or equal are supported using standard operator notation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Greater/less-than comparisons against `null` follow a simple rule: `null` is treated as nothing here (i.e. NOT as zero). As a consequence, any other value is always greater than `null` (`X > null` is always `true`) and no other value is ever less than nothing (`X < null` is always `false`). If you prefer numeric comparisons instead, please avoid number-based `null` comparisons in favor of comparisons against zero (e.g. `X > 0` or `X < 0`).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
In addition to standard relational operators SpEL supports the 'instanceof' and regular expression based 'matches' operator.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Each symbolic operator can also be specified as a purely alphabetic equivalent. This avoids problems where the symbols used have special meaning for the document type in which the expression is embedded (eg. an XML document). The textual equivalents are shown here: lt ('<'), gt ('>'), le ('<='), ge ('>='), eq ('=='), ne ('!='), div ('/'), mod ('%'), not ('!'). These are case insensitive.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The logical operators that are supported are and, or, and not. Their use is demonstrated below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The addition operator can be used on numbers, strings and dates. Subtraction can be used on numbers and dates. Multiplication and division can be used only on numbers. Other mathematical operators supported are modulus (%) and exponential power (^). Standard operator precedence is enforced. These operators are demonstrated below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Setting of a property is done by using the assignment operator. This would typically be done within a call to setValue but can also be done inside a call to getValue.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The special 'T' operator can be used to specify an instance of java.lang.Class (the 'type'). Static methods are invoked using this operator as well. The StandardEvaluationContext uses a TypeLocator to find types and the StandardTypeLocator (which can be replaced) is built with an understanding of the java.lang package. This means T() references to types within java.lang do not need to be fully qualified, but all other type references must be.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Constructors can be invoked using the new operator. The fully qualified class name should be used for all but the primitive type and String (where int, float, etc, can be used).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Variables can be referenced in the expression using the syntax #variableName. Variables are set using the method setVariable on the StandardEvaluationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The variable #this is always defined and refers to the current evaluation object (against which unqualified references are resolved). The variable #root is always defined and refers to the root context object. Although #this may vary as components of an expression are evaluated, #root always refers to the root.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
The main example is the control flow pointcut.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring control flow pointcuts are conceptually similar to AspectJ cflow pointcuts, although less powerful. (There is currently no way to specify that a pointcut executes below a join point matched by another pointcut.) A control flow pointcut matches the current call stack. For example, it might fire if the join point was invoked by a method in the com.mycompany.web package, or by the SomeCaller class. Control flow pointcuts are specified using the org.springframework.aop.support.ControlFlowPointcut class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Control flow pointcuts are significantly more expensive to evaluate at runtime than even other dynamic pointcuts. In Java 1.4, the cost is about 5 times that of other dynamic pointcuts.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Spring provides useful pointcut superclasses to help you to implement your own pointcuts.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Because static pointcuts are most useful, you'll probably subclass StaticMethodMatcherPointcut, as shown below. This requires implementing just one abstract method (although it's possible to override other methods to customize behavior):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
There are also superclasses for dynamic pointcuts.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
You can use custom pointcuts with any advice type in Spring 1.0 RC2 and above.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Because pointcuts in Spring AOP are Java classes, rather than language features (as in AspectJ) it's possible to declare custom pointcuts, whether static or dynamic. Custom pointcuts in Spring can be arbitrarily complex. However, using the AspectJ pointcut expression language is recommended if possible.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Later versions of Spring may offer support for ""semantic pointcuts"" as offered by JAC: for example, ""all methods that change instance variables in the target object.""",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Let's now look at how Spring AOP handles advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Each advice is a Spring bean. An advice instance can be shared across all advised objects, or unique to each advised object. This corresponds to per-class or per-instance advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Per-class advice is used most often. It is appropriate for generic advice such as transaction advisors. These do not depend on the state of the proxied object or add new state; they merely act on the method and arguments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Per-instance advice is appropriate for introductions, to support mixins. In this case, the advice adds state to the proxied object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
It's possible to use a mix of shared and per-instance advice in the same AOP proxy.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring provides several advice types out of the box, and is extensible to support arbitrary advice types. Let us look at the basic concepts and standard advice types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The most fundamental advice type in Spring is interception around advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Spring is compliant with the AOP Alliance interface for around advice using method interception. MethodInterceptors implementing around advice should implement the following interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The MethodInvocation argument to the invoke() method exposes the method being invoked; the target join point; the AOP proxy; and the arguments to the method. The invoke() method should return the invocation's result: the return value of the join point.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
A simple MethodInterceptor implementation looks as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note the call to the MethodInvocation's proceed() method. This proceeds down the interceptor chain towards the join point. Most interceptors will invoke this method, and return its return value. However, a MethodInterceptor, like any around advice, can return a different value or throw an exception rather than invoke the proceed method. However, you don't want to do this without good reason!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"MethodInterceptors offer interoperability with other AOP Alliance-compliant AOP implementations. The other advice types discussed in the remainder of this section implement common AOP concepts, but in a Spring-specific way. While there is an advantage in using the most specific advice type, stick with MethodInterceptor around advice if you are likely to want to run the aspect in another AOP framework. Note that pointcuts are not currently interoperable between frameworks, and the AOP Alliance does not currently define pointcut interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"A simpler advice type is a before advice. This does not need a MethodInvocation object, since it will only be called before entering the method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The main advantage of a before advice is that there is no need to invoke the proceed() method, and therefore no possibility of inadvertently failing to proceed down the interceptor chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The MethodBeforeAdvice interface is shown below. (Spring's API design would allow for field before advice, although the usual objects apply to field interception and it's unlikely that Spring will ever implement it).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note the return type is void. Before advice can insert custom behavior before the join point executes, but cannot change the return value. If a before advice throws an exception, this will abort further execution of the interceptor chain. The exception will propagate back up the interceptor chain. If it is unchecked, or on the signature of the invoked method, it will be passed directly to the client; otherwise it will be wrapped in an unchecked exception by the AOP proxy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An example of a before advice in Spring, which counts all method invocations:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Before advice can be used with any pointcut.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Throws advice is invoked after the return of the join point if the join point threw an exception. Spring offers typed throws advice. Note that this means that the org.springframework.aop.ThrowsAdvice interface does not contain any methods: It is a tag interface identifying that the given object implements one or more typed throws advice methods. These should be in the form of:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"By default, once loaded, the configured ApplicationContext is reused for each test. Thus the setup cost is incurred only once per test suite, and subsequent test execution is much faster. In this context, the term test suite means all tests run in the same JVM — for example, all tests run from an Ant, Maven, or Gradle build for a given project or module. In the unlikely case that a test corrupts the application context and requires reloading — for example, by modifying a bean definition or the state of an application object — the TestContext framework can be configured to reload the configuration and rebuild the application context before executing the next test.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See the section called “Context management” and the section called “Context caching” with the TestContext framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When the TestContext framework loads your application context, it can optionally configure instances of your test classes via Dependency Injection. This provides a convenient mechanism for setting up test fixtures using preconfigured beans from your application context. A strong benefit here is that you can reuse application contexts across various testing scenarios (e.g., for configuring Spring-managed object graphs, transactional proxies, DataSources, etc.), thus avoiding the need to duplicate complex test fixture setup for individual test cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As an example, consider the scenario where we have a class, HibernateTitleRepository, that implements data access logic for a Title domain entity. We want to write integration tests that test the following areas:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring configuration: basically, is everything related to the configuration of the HibernateTitleRepository bean correct and present?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Hibernate mapping file configuration: is everything mapped correctly, and are the correct lazy-loading settings in place?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The logic of the HibernateTitleRepository: does the configured instance of this class perform as anticipated?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See dependency injection of test fixtures with the TestContext framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"One common issue in tests that access a real database is their effect on the state of the persistence store. Even when you're using a development database, changes to the state may affect future tests. Also, many operations — such as inserting or modifying persistent data — cannot be performed (or verified) outside a transaction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The TestContext framework addresses this issue. By default, the framework will create and roll back a transaction for each test. You simply write code that can assume the existence of a transaction. If you call transactionally proxied objects in your tests, they will behave correctly, according to their configured transactional semantics. In addition, if a test method deletes the contents of selected tables while running within the transaction managed for the test, the transaction will roll back by default, and the database will return to its state prior to execution of the test. Transactional support is provided to a test via a PlatformTransactionManager bean defined in the test's application context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you want a transaction to commit — unusual, but occasionally useful when you want a particular test to populate or modify the database — the TestContext framework can be instructed to cause the transaction to commit instead of roll back via the @TransactionConfiguration and @Rollback annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See transaction management with the TestContext framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring TestContext Framework provides several abstract support classes that simplify the writing of integration tests. These base test classes provide well-defined hooks into the testing framework as well as convenient instance variables and methods, which enable you to access:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The ApplicationContext, for performing explicit bean lookups or testing the state of the context as a whole.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"A JdbcTemplate, for executing SQL statements to query the database. Such queries can be used to confirm database state both prior to and after execution of database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In addition, you may want to create your own custom, application-wide superclass with instance variables and methods specific to your project.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See support classes for the TestContext framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The org.springframework.test.jdbc package contains JdbcTestUtils, which is a collection of JDBC related utility functions intended to simplify standard database testing scenarios. Note that AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests provide convenience methods which delegate to JdbcTestUtils internally.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The spring-jdbc module provides support for configuring and launching an embedded database which can be used in integration tests that interact with a database. For details, see Section 14.8, “Embedded database support” and Section 14.8.8, “Testing data access logic with an embedded database”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring Framework provides the following set of Spring-specific annotations that you can use in your unit and integration tests in conjunction with the TestContext framework. Refer to the respective Javadoc for further information, including default attribute values, attribute aliases, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Defines class-level metadata that is used to determine how to load and configure an ApplicationContext for integration tests. Specifically, @ContextConfiguration declares either the application context resource locations or the annotated classes that will be used to load the context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Resource locations are typically XML configuration files located in the classpath; whereas, annotated classes are typically @Configuration classes. However, resource locations can also refer to files in the file system, and annotated classes can be component classes, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As an alternative or in addition to declaring resource locations or annotated classes, @ContextConfiguration may be used to declare ApplicationContextInitializer classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"@ContextConfiguration may optionally be used to declare the ContextLoader strategy as well. Note, however, that you typically do not need to explicitly configure the loader since the default loader supports either resource locations or annotated classes as well as initializers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
@ContextConfiguration provides support for inheriting resource locations or configuration classes as well as context initializers declared by superclasses by default.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See the section called “Context management” and the Javadoc for @ContextConfiguration for further details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring AOP is implemented in pure Java. There is no need for a special compilation process. Spring AOP does not need to control the class loader hierarchy, and is thus suitable for use in a Servlet container or application server.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. If you need to advise field access and update join points, consider a language such as AspectJ.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP's approach to AOP differs from that of most other AOP frameworks. The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable); it is rather to provide a close integration between AOP implementation and Spring IoC to help solve common problems in enterprise applications.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Thus, for example, the Spring Framework's AOP functionality is normally used in conjunction with the Spring IoC container. Aspects are configured using normal bean definition syntax (although this allows powerful ""autoproxying"" capabilities): this is a crucial difference from other AOP implementations. There are some things you cannot do easily or efficiently with Spring AOP, such as advise very fine-grained objects (such as domain objects typically): AspectJ is the best choice in such cases. However, our experience is that Spring AOP provides an excellent solution to most problems in enterprise Java applications that are amenable to AOP.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring AOP will never strive to compete with AspectJ to provide a comprehensive AOP solution. We believe that both proxy-based frameworks like Spring AOP and full-blown frameworks such as AspectJ are valuable, and that they are complementary, rather than in competition. Spring 2.0 seamlessly integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP to be catered for within a consistent Spring-based application architecture. This integration does not affect the Spring AOP API or the AOP Alliance API: Spring AOP remains backward-compatible. See the following chapter for a discussion of the Spring AOP APIs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"One of the central tenets of the Spring Framework is that of non-invasiveness; this is the idea that you should not be forced to introduce framework-specific classes and interfaces into your business/domain model. However, in some places the Spring Framework does give you the option to introduce Spring Framework-specific dependencies into your codebase: the rationale in giving you such options is because in certain scenarios it might be just plain easier to read or code some specific piece of functionality in such a way. The Spring Framework (almost) always offers you the choice though: you have the freedom to make an informed decision as to which option best suits your particular use case or scenario.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"One such choice that is relevant to this chapter is that of which AOP framework (and which AOP style) to choose. You have the choice of AspectJ and/or Spring AOP, and you also have the choice of either the @AspectJ annotation-style approach or the Spring XML configuration-style approach. The fact that this chapter chooses to introduce the @AspectJ-style approach first should not be taken as an indication that the Spring team favors the @AspectJ annotation-style approach over the Spring XML configuration-style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"See Section 9.4, “Choosing which AOP declaration style to use” for a more complete discussion of the whys and wherefores of each style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP defaults to using standard J2SE dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring AOP can also use CGLIB proxies. This is necessary to proxy classes, rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"It is important to grasp the fact that Spring AOP is proxy-based. See Section 9.6.1, “Understanding AOP proxies” for a thorough examination of exactly what this implementation detail actually means.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"@AspectJ refers to a style of declaring aspects as regular Java classes annotated with Java 5 annotations. The @AspectJ style was introduced by the AspectJ project as part of the AspectJ 5 release. Spring 2.0 interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut parsing and matching. The AOP runtime is still pure Spring AOP though, and there is no dependency on the AspectJ compiler or weaver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Using the AspectJ compiler and weaver enables use of the full AspectJ language, and is discussed in Section 9.8, “Using AspectJ with Spring applications”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To use @AspectJ aspects in a Spring configuration you need to enable Spring support for configuring Spring AOP based on @AspectJ aspects, and autoproxying beans based on whether or not they are advised by those aspects. By autoproxying we mean that if Spring determines that a bean is advised by one or more aspects, it will automatically generate a proxy for that bean to intercept method invocations and ensure that advice is executed as needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The @AspectJ support can be enabled with XML or Java style configuration. In either case you will also need to ensure that AspectJ's aspectjweaver.jar library is on the classpath of your application (version 1.6.8 or later). This library is available in the 'lib' directory of an AspectJ distribution or via the Maven Central repository.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
To enable @AspectJ support with Java @Configuration add the @EnableAspectJAutoProxy annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
To enable @AspectJ support with XML based configuration use the aop:aspectj-autoproxy element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"This assumes that you are using schema support as described in Appendix E, XML Schema-based configuration. See Section E.2.7, “The aop schema” for how to import the tags in the aop namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are using the DTD, it is still possible to enable @AspectJ support by adding the following definition to your application context:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"With the @AspectJ support enabled, any bean defined in your application context with a class that is an @AspectJ aspect (has the @Aspect annotation) will be automatically detected by Spring and used to configure Spring AOP. The following example shows the minimal definition required for a not-very-useful aspect:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"A regular bean definition in the application context, pointing to a bean class that has the @Aspect annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"And the NotVeryUsefulAspect class definition, annotated with org.aspectj.lang.annotation.Aspect annotation;",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Aspects (classes annotated with @Aspect) may have methods and fields just like any other class. They may also contain pointcut, advice, and introduction (inter-type) declarations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"You may register aspect classes as regular beans in your Spring XML configuration, or autodetect them through classpath scanning - just like any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath: For that purpose, you need to add a separate @Component annotation (or alternatively a custom stereotype annotation that qualifies, as per the rules of Spring's component scanner).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In Spring AOP, it is not possible to have aspects themselves be the target of advice from other aspects. The @Aspect annotation on a class marks it as an aspect, and hence excludes it from auto-proxying.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Recall that pointcuts determine join points of interest, and thus enable us to control when advice executes. Spring AOP only supports method execution join points for Spring beans, so you can think of a pointcut as matching the execution of methods on Spring beans. A pointcut declaration has two parts: a signature comprising a name and any parameters, and a pointcut expression that determines exactly which method executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut signature is provided by a regular method definition, and the pointcut expression is indicated using the @Pointcut annotation (the method serving as the pointcut signature must have a void return type).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
An example will help make this distinction between a pointcut signature and a pointcut expression clear. The following example defines a pointcut named 'anyOldTransfer' that will match the execution of any method named 'transfer':,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The pointcut expression that forms the value of the @Pointcut annotation is a regular AspectJ 5 pointcut expression. For a full discussion of AspectJ's pointcut language, see the AspectJ Programming Guide (and for Java 5 based extensions, the AspectJ 5 Developers Notebook) or one of the books on AspectJ such as “Eclipse AspectJ” by Colyer et. al. or “AspectJ in Action” by Ramnivas Laddad.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In this chapter, we will describe Spring's Object/XML Mapping support. Object/XML Mapping, or O/X mapping for short, is the act of converting an XML document to and from an object. This conversion process is also known as XML Marshalling, or XML Serialization. This chapter uses these terms interchangeably.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Within the field of O/X mapping, a marshaller is responsible for serializing an object (graph) to XML. In similar fashion, an unmarshaller deserializes the XML to an object graph. This XML can take the form of a DOM document, an input or output stream, or a SAX handler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
Some of the benefits of using Spring for your O/X mapping needs are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Ease of configuration.  Spring's bean factory makes it easy to configure marshallers, without needing to construct JAXB context, JiBX binding factories, etc. The marshallers can be configured as any other bean in your application context. Additionally, XML Schema-based configuration is available for a number of marshallers, making the configuration even simpler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Consistent Interfaces.  Spring's O/X mapping operates through two global interfaces: the Marshaller and Unmarshaller interface. These abstractions allow you to switch O/X mapping frameworks with relative ease, with little or no changes required on the classes that do the marshalling. This approach has the additional benefit of making it possible to do XML marshalling with a mix-and-match approach (e.g. some marshalling performed using JAXB, other using XMLBeans) in a non-intrusive fashion, leveraging the strength of each technology.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Consistent Exception Hierarchy.  Spring provides a conversion from exceptions from the underlying O/X mapping tool to its own exception hierarchy with the XmlMappingException as the root exception. As can be expected, these runtime exceptions wrap the original exception so no information is lost.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"As stated in the introduction, a marshaller serializes an object to XML, and an unmarshaller deserializes XML stream to an object. In this section, we will describe the two Spring interfaces used for this purpose.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"One of the areas in which Spring excels is in the separation of view technologies from the rest of the MVC framework. For example, deciding to use Velocity or XSLT in place of an existing JSP is primarily a matter of configuration. This chapter covers the major view technologies that work with Spring and touches briefly on how to add new ones. This chapter assumes you are already familiar with Section 17.5, “Resolving views” which covers the basics of how views in general are coupled to the MVC framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The Spring Framework supports integration with Hibernate, Java Persistence API (JPA), Java Data Objects (JDO) and iBATIS SQL Maps for resource management, data access object (DAO) implementations, and transaction strategies. For example, for Hibernate there is first-class support with several convenient IoC features that address many typical Hibernate integration issues. You can configure all of the supported features for O/R (object relational) mapping tools through Dependency Injection. They can participate in Spring's resource and transaction management, and they comply with Spring's generic transaction and DAO exception hierarchies. The recommended integration style is to code DAOs against plain Hibernate, JPA, and JDO APIs. The older style of using Spring's DAO templates is no longer recommended; however, coverage of this style can be found in the Section A.1, “Classic ORM usage” in the appendices.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The value-add provided by the Spring Framework JDBC abstraction is perhaps best shown by the sequence of actions outlined in the table below. The table shows what actions Spring will take care of and which actions are the responsibility of you, the application developer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet that dispatches requests to handlers, with configurable handler mappings, view resolution, locale and theme resolution as well as support for uploading files. The default handler is based on the @Controller and @RequestMapping annotations, offering a wide range of flexible handling methods. With the introduction of Spring 3.0, the @Controller mechanism also allows you to create RESTful Web sites and applications, through the @PathVariable annotation and other features.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This part of the reference documentation covers the Spring Framework's support for the presentation tier (and specifically web-based presentation tiers).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-web.html
"The Spring Framework's own web framework, Spring Web MVC, is covered in the first couple of chapters. A number of the remaining chapters in this part of the reference documentation are concerned with the Spring Framework's integration with other web technologies, such as Struts and JSF (to name but two).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-web.html
This section concludes with coverage of Spring's MVC portlet framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-web.html
Comprehensive transaction support is among the most compelling reasons to use the Spring Framework. The Spring Framework provides a consistent abstraction for transaction management that delivers the following benefits:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies like JDBC, Hibernate, JPA or JDO in a consistent way. This allows one to switch between the aforementioned persistence technologies fairly easily and it also allows one to code without worrying about catching exceptions that are specific to each technology.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
Spring provides a convenient translation from technology-specific exceptions like SQLException to its own exception class hierarchy with the DataAccessException as the root exception. These exceptions wrap the original exception so there is never any risk that one might lose any information as to what might have gone wrong.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
"In addition to JDBC exceptions, Spring can also wrap Hibernate-specific exceptions, converting them from proprietary, checked exceptions (in the case of versions of Hibernate prior to Hibernate 3.0), to a set of focused runtime exceptions (the same is true for JDO and JPA exceptions). This allows one to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without having annoying boilerplate catch-and-throw blocks and exception declarations in one's DAOs. (One can still trap and handle exceptions anywhere one needs to though.) As mentioned above, JDBC exceptions (including database-specific dialects) are also converted to the same hierarchy, meaning that one can perform some operations with JDBC within a consistent programming model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
"The above holds true for the various template classes in Springs support for various ORM frameworks. If one uses the interceptor-based classes then the application must care about handling HibernateExceptions and JDOExceptions itself, preferably via delegating to SessionFactoryUtils' convertHibernateAccessException(..) or convertJdoAccessException() methods respectively. These methods convert the exceptions to ones that are compatible with the exceptions in the org.springframework.dao exception hierarchy. As JDOExceptions are unchecked, they can simply get thrown too, sacrificing generic DAO abstraction in terms of exceptions though.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
The exception hierarchy that Spring provides can be seen below. (Please note that the class hierarchy detailed in the image shows only a subset of the entire DataAccessException hierarchy.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation is to use the @Repository annotation. This annotation also allows the component scanning support to find and configure your DAOs and repositories without having to provide XML configuration entries for them.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
"Any DAO or repository implementation will need to access to a persistence resource, depending on the persistence technology used; for example, a JDBC-based repository will need access to a JDBC DataSource; a JPA-based repository will need access to an EntityManager. The easiest way to accomplish this is to have this resource dependency injected using one of the @Autowired,, @Inject, @Resource or @PersistenceContext annotations. Here is an example for a JPA repository:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
If you are using the classic Hibernate APIs than you can inject the SessionFactory:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
Last example we will show here is for typical JDBC support. You would have the DataSource injected into an initialization method where you would create a JdbcTemplate and other data access support classes like SimpleJdbcCall etc using this DataSource.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
Please see the specific coverage of each persistence technology for details on how to configure the application context to take advantage of these annotations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/dao.html
"Finally, and in a bit of a departure from the focus of this chapter, for those of you using Spring's MVC web framework, using PropertyEditorRegistrars in conjunction with data-binding Controllers (such as SimpleFormController) can be very convenient. Find below an example of using a PropertyEditorRegistrar in the implementation of an initBinder(..) method:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"This style of PropertyEditor registration can lead to concise code (the implementation of initBinder(..) is just one line long!), and allows common PropertyEditor registration code to be encapsulated in a class and then shared amongst as many Controllers as needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring 3 introduces a core.convert package that provides a general type conversion system. The system defines an SPI to implement type conversion logic, as well as an API to execute type conversions at runtime. Within a Spring container, this system can be used as an alternative to PropertyEditors to convert externalized bean property value strings to required property types. The public API may also be used anywhere in your application where type conversion is needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The SPI to implement type conversion logic is simple and strongly typed:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To create your own Converter, simply implement the interface above. Parameterize S as the type you are converting from, and T as the type you are converting to. For each call to convert(S), the source argument is guaranteed to be NOT null. Your Converter may throw any Exception if conversion fails. An IllegalArgumentException should be thrown to report an invalid source value. Take care to ensure your Converter implementation is thread-safe.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Several converter implementations are provided in the core.convert.support package as a convenience. These include converters from Strings to Numbers and other common types. Consider StringToInteger as an example Converter implementation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When you need to centralize the conversion logic for an entire class hierarchy, for example, when converting from String to java.lang.Enum objects, implement ConverterFactory:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Parameterize S to be the type you are converting from and R to be the base type defining the range of classes you can convert to. Then implement getConverter(Class<T>), where T is a subclass of R.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Consider the StringToEnum ConverterFactory as an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When you require a sophisticated Converter implementation, consider the GenericConverter interface. With a more flexible but less strongly typed signature, a GenericConverter supports converting between multiple source and target types. In addition, a GenericConverter makes available source and target field context you can use when implementing your conversion logic. Such context allows a type conversion to be driven by a field annotation, or generic information declared on a field signature.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To implement a GenericConverter, have getConvertibleTypes() return the supported source->target type pairs. Then implement convert(Object, TypeDescriptor, TypeDescriptor) to implement your conversion logic. The source TypeDescriptor provides access to the source field holding the value being converted. The target TypeDescriptor provides access to the target field where the converted value will be set.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
A good example of a GenericConverter is a converter that converts between a Java Array and a Collection. Such an ArrayToCollectionConverter introspects the field that declares the target Collection type to resolve the Collection's element type. This allows each element in the source array to be converted to the Collection element type before the Collection is set on the target field.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Because GenericConverter is a more complex SPI interface, only use it when you need it. Favor Converter or ConverterFactory for basic type conversion needs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Sometimes you only want a Converter to execute if a specific condition holds true. For example, you might only want to execute a Converter if a specific annotation is present on the target field. Or you might only want to execute a Converter if a specific method, such as static valueOf method, is defined on the target class. ConditionalGenericConverter is an subinterface of GenericConverter that allows you to define such custom matching criteria:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A good example of a ConditionalGenericConverter is an EntityConverter that converts between an persistent entity identifier and an entity reference. Such a EntityConverter might only match if the target entity type declares a static finder method e.g. findAccount(Long). You would perform such a finder method check in the implementation of matches(TypeDescriptor, TypeDescriptor).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The ConversionService defines a unified API for executing type conversion logic at runtime. Converters are often executed behind this facade interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Most ConversionService implementations also implement ConverterRegistry, which provides an SPI for registering converters. Internally, a ConversionService implementation delegates to its registered converters to carry out type conversion logic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
A robust ConversionService implementation is provided in the core.convert.support package. GenericConversionService is the general-purpose implementation suitable for use in most environments. ConversionServiceFactory provides a convenient factory for creating common ConversionService configurations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A ConversionService is a stateless object designed to be instantiated at application startup, then shared between multiple threads. In a Spring application, you typically configure a ConversionService instance per Spring container (or ApplicationContext). That ConversionService will be picked up by Spring and then used whenever a type conversion needs to be performed by the framework. You may also inject this ConversionService into any of your beans and invoke it directly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"If no ConversionService is registered with Spring, the original PropertyEditor-based system is used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To register a default ConversionService with Spring, add the following bean definition with id conversionService:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A default ConversionService can convert between strings, numbers, enums, collections, maps, and other common types. To supplement or override the default converters with your own custom converter(s), set the converters property. Property values may implement either of the Converter, ConverterFactory, or GenericConverter interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"It is also common to use a ConversionService within a Spring MVC application. See Section 7.6.5, “Configuring Formatting in Spring MVC” for details on use with <mvc:annotation-driven/>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"In certain situations you may wish to apply formatting during conversion. See Section 7.6.3, “FormatterRegistry SPI” for details on using FormattingConversionServiceFactoryBean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To work with a ConversionService instance programmatically, simply inject a reference to it like you would for any other bean:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"As discussed in the previous section, core.convert is a general-purpose type conversion system. It provides a unified ConversionService API as well as a strongly-typed Converter SPI for implementing conversion logic from one type to another. A Spring Container uses this system to bind bean property values. In addition, both the Spring Expression Language (SpEL) and DataBinder use this system to bind field values. For example, when SpEL needs to coerce a Short to a Long to complete an expression.setValue(Object bean, Object value) attempt, the core.convert system performs the coercion.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Now consider the type conversion requirements of a typical client environment such as a web or desktop application. In such environments, you typically convert from String to support the client postback process, as well as back to String to support the view rendering process. In addition, you often need to localize String values. The more general core.convert Converter SPI does not address such formatting requirements directly. To directly address them, Spring 3 introduces a convenient Formatter SPI that provides a simple and robust alternative to PropertyEditors for client environments.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A bean definition essentially is a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked, and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the class attribute of the <bean/> element. This class attribute, which internally is a Class property on a BeanDefinition instance, is usually mandatory. (For exceptions, see the section called “Instantiation using an instance factory method” and Section 5.7, “Bean definition inheritance”.) You use the Class property in one of two ways:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code using the new operator.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To specify the actual class containing the static factory method that will be invoked to create the object, in the less common case where the container invokes a static, factory method on a class to create the bean. The object type returned from the invocation of the static factory method may be the same class or another class entirely.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you want to configure a bean definition for a static nested class, you have to use the binary name of the inner class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For example, if you have a class called Foo in the com.example package, and this Foo class has a static inner class called Bar, the value of the 'class' attribute on a bean definition would be...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Notice the use of the $ character in the name to separate the inner class name from the outer class name.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring IoC container can manage virtually any class you want it to manage; it is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
With XML-based configuration metadata you can specify your bean class as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see Injecting Dependencies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When defining a bean that you create with a static factory method, you use the class attribute to specify the class containing the static factory method and an attribute named factory-method to specify the name of the factory method itself. You should be able to call this method (with optional arguments as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call static factories in legacy code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following bean definition specifies that the bean will be created by calling a factory-method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the createInstance() method must be a static method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see Dependencies and configuration in detail.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the class attribute empty, and in the factory-bean attribute, specify the name of a bean in the current (or parent/ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the factory-method attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
One factory class can also hold more than one factory method as shown here:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See Dependencies and configuration in detail.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Spring documentation, factory bean refers to a bean that is configured in the Spring container that will create objects through an instance or static factory method. By contrast, FactoryBean (notice the capitalization) refers to a Spring-specific FactoryBean .",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Dependency injection (DI) is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name Inversion of Control (IoC), of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes, or the Service Locator pattern.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies, and does not know the location or class of the dependencies. As such, your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"DI exists in two major variants, Constructor-based dependency injection and Setter-based dependency injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a static factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a static factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection. Notice that there is nothing special about this class, it is a POJO that has no dependencies on container specific interfaces, base classes or annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Constructor argument resolution matching occurs using the argument's type. If no potential ambiguity exists in the constructor arguments of a bean definition, then the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"No potential ambiguity exists, assuming that Bar and Baz classes are not related by inheritance. Thus the following configuration works fine, and you do not need to specify the constructor argument indexes and/or types explicitly in the <constructor-arg/> element.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as <value>true<value>, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument using the type attribute. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Use the index attribute to specify explicitly the index of constructor arguments. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The wildcard classpath relies on the getResources() method of the underlying classloader. As most application servers nowadays supply their own classloader implementation, the behavior might differ especially when dealing with jar files. A simple test to check if classpath* works is to use the classloader to load a file from within a jar on the classpath: getClass().getClassLoader().getResources(""<someFileInsideTheJar>""). Try this test with files that have the same name but are placed inside two different locations. In case an inappropriate result is returned, check the application server documentation for settings that might affect the classloader behavior.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"The ""classpath*:"" prefix can also be combined with a PathMatcher pattern in the rest of the location path, for example ""classpath*:META-INF/*-beans.xml"". In this case, the resolution strategy is fairly simple: a ClassLoader.getResources() call is used on the last non-wildcard path segment to get all the matching resources in the class loader hierarchy, and then off each resource the same PathMatcher resolution strategy described above is used for the wildcard subpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"Please note that ""classpath*:"" when combined with Ant-style patterns will only work reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern like ""classpath*:*.xml"" will not retrieve files from the root of jar files but rather only from the root of expanded directories. This originates from a limitation in the JDK's ClassLoader.getResources() method which only returns file system locations for a passed-in empty string (indicating potential roots to search).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"is used to try to resolve it, the resolver will work off the (first) URL returned by getResource(""com/mycompany"");. If this base package node exists in multiple classloader locations, the actual end resource may not be underneath. Therefore, preferably, use ""classpath*:"" with the same Ant-style pattern in such a case, which will search all class path locations that contain the root package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"A FileSystemResource that is not attached to a FileSystemApplicationContext (that is, a FileSystemApplicationContext is not the actual ResourceLoader) will treat absolute vs. relative paths as you would expect. Relative paths are relative to the current working directory, while absolute paths are relative to the root of the filesystem.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"For backwards compatibility (historical) reasons however, this changes when the FileSystemApplicationContext is the ResourceLoader. The FileSystemApplicationContext simply forces all attached FileSystemResource instances to treat all location paths as relative, whether they start with a leading slash or not. In practice, this means the following are equivalent:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"As are the following: (Even though it would make sense for them to be different, as one case is relative and the other absolute.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
"In practice, if true absolute filesystem paths are needed, it is better to forgo the use of absolute paths with FileSystemResource / FileSystemXmlApplicationContext, and just force the use of a UrlResource, by using the file: URL prefix.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/resources.html
You can extend SpEL by registering user defined functions that can be called within the expression string. The function is registered with the StandardEvaluationContext using the method.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"A reference to a Java Method provides the implementation of the function. For example, a utility method to reverse a string is shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
This method is then registered with the evaluation context and can be used within an expression string.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
If the evaluation context has been configured with a bean resolver it is possible to lookup beans from an expression using the (@) symbol.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
You can use the ternary operator for performing if-then-else conditional logic inside the expression. A minimal example is:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"In this case, the boolean false results in returning the string value 'falseExp'. A more realistic example is shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Also see the next section on the Elvis operator for an even shorter syntax for the ternary operator.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The Elvis operator is a shortening of the ternary operator syntax and is used in the Groovy language. With the ternary operator syntax you usually have to repeat a variable twice, for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Instead you can use the Elvis operator, named for the resemblance to Elvis' hair style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Here is a more complex example.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The Safe Navigation operator is used to avoid a NullPointerException and comes from the Groovy language. Typically when you have a reference to an object you might need to verify that it is not null before accessing methods or properties of the object. To avoid this, the safe navigation operator will simply return null instead of throwing an exception.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The Elvis operator can be used to apply default values in expressions, e.g. in an @Value expression:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
This will inject a system property pop3.port if it is defined or 25 if not.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Selection is a powerful expression language feature that allows you to transform some source collection into another by selecting from its entries.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Selection uses the syntax ?[selectionExpression]. This will filter the collection and return a new collection containing a subset of the original elements. For example, selection would allow us to easily get a list of Serbian inventors:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
Selection is possible upon both lists and maps. In the former case the selection criteria is evaluated against each individual list element whilst against a map the selection criteria is evaluated against each map entry (objects of the Java type Map.Entry). Map entries have their key and value accessible as properties for use in the selection.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
This expression will return a new map consisting of those elements of the original map where the entry value is less than 27.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"In addition to returning all the selected elements, it is possible to retrieve just the first or the last value. To obtain the first entry matching the selection the syntax is ^[...] whilst to obtain the last matching selection the syntax is $[...].",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Projection allows a collection to drive the evaluation of a sub-expression and the result is a new collection. The syntax for projection is ![projectionExpression]. Most easily understood by example, suppose we have a list of inventors but want the list of cities where they were born. Effectively we want to evaluate 'placeOfBirth.city' for every entry in the inventor list. Using projection:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
A map can also be used to drive projection and in this case the projection expression is evaluated against each entry in the map (represented as a Java Map.Entry). The result of a projection across a map is a list consisting of the evaluation of the projection expression against each map entry.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Expression templates allow a mixing of literal text with one or more evaluation blocks. Each evaluation block is delimited with prefix and suffix characters that you can define, a common choice is to use #{ } as the delimiters. For example,",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"The string is evaluated by concatenating the literal text 'random number is ' with the result of evaluating the expression inside the #{ } delimiter, in this case the result of calling that random() method. The second argument to the method parseExpression() is of the type ParserContext. The ParserContext interface is used to influence how the expression is parsed in order to support the expression templating functionality. The definition of TemplateParserContext is shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/expressions.html
"Only the last argument is required. The method signatures may have either one or four arguments, depending on whether the advice method is interested in the method and arguments. The following classes are examples of throws advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The advice below is invoked if a RemoteException is thrown (including subclasses):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The following advice is invoked if a ServletException is thrown. Unlike the above advice, it declares 4 arguments, so that it has access to the invoked method, method arguments and target object:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The final example illustrates how these two methods could be used in a single class, which handles both RemoteException and ServletException. Any number of throws advice methods can be combined in a single class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note: If a throws-advice method throws an exception itself, it will override the original exception (i.e. change the exception thrown to the user). The overriding exception will typically be a RuntimeException; this is compatible with any method signature. However, if a throws-advice method throws a checked exception, it will have to match the declared exceptions of the target method and is hence to some degree coupled to specific target method signatures. Do not throw an undeclared checked exception that is incompatible with the target method's signature!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Throws advice can be used with any pointcut.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An after returning advice in Spring must implement the org.springframework.aop.AfterReturningAdvice interface, shown below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An after returning advice has access to the return value (which it cannot modify), invoked method, methods arguments and target.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The following after returning advice counts all successful method invocations that have not thrown exceptions:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This advice doesn't change the execution path. If it throws an exception, this will be thrown up the interceptor chain instead of the return value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
After returning advice can be used with any pointcut.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Spring treats introduction advice as a special kind of interception advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Introduction requires an IntroductionAdvisor, and an IntroductionInterceptor, implementing the following interface:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The invoke() method inherited from the AOP Alliance MethodInterceptor interface must implement the introduction: that is, if the invoked method is on an introduced interface, the introduction interceptor is responsible for handling the method call - it cannot invoke proceed().",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Introduction advice cannot be used with any pointcut, as it applies only at class, rather than method, level. You can only use introduction advice with the IntroductionAdvisor, which has the following methods:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"There is no MethodMatcher, and hence no Pointcut, associated with introduction advice. Only class filtering is logical.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The getInterfaces() method returns the interfaces introduced by this advisor.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The validateInterfaces() method is used internally to see whether or not the introduced interfaces can be implemented by the configured IntroductionInterceptor.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Let's look at a simple example from the Spring test suite. Let's suppose we want to introduce the following interface to one or more objects:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This illustrates a mixin. We want to be able to cast advised objects to Lockable, whatever their type, and call lock and unlock methods. If we call the lock() method, we want all setter methods to throw a LockedException. Thus we can add an aspect that provides the ability to make objects immutable, without them having any knowledge of it: a good example of AOP.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Firstly, we'll need an IntroductionInterceptor that does the heavy lifting. In this case, we extend the org.springframework.aop.support.DelegatingIntroductionInterceptor convenience class. We could implement IntroductionInterceptor directly, but using DelegatingIntroductionInterceptor is best for most cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The DelegatingIntroductionInterceptor is designed to delegate an introduction to an actual implementation of the introduced interface(s), concealing the use of interception to do so. The delegate can be set to any object using a constructor argument; the default delegate (when the no-arg constructor is used) is this. Thus in the example below, the delegate is the LockMixin subclass of DelegatingIntroductionInterceptor. Given a delegate (by default itself), a DelegatingIntroductionInterceptor instance looks for all interfaces implemented by the delegate (other than IntroductionInterceptor), and will support introductions against any of them. It's possible for subclasses such as LockMixin to call the suppressInterface(Class intf) method to suppress interfaces that should not be exposed. However, no matter how many interfaces an IntroductionInterceptor is prepared to support, the IntroductionAdvisor used will control which interfaces are actually exposed. An introduced interface will conceal any implementation of the same interface by the target.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Thus LockMixin subclasses DelegatingIntroductionInterceptor and implements Lockable itself. The superclass automatically picks up that Lockable can be supported for introduction, so we don't need to specify that. We could introduce any number of interfaces in this way.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Note the use of the locked instance variable. This effectively adds additional state to that held in the target object.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Often it isn't necessary to override the invoke() method: the DelegatingIntroductionInterceptor implementation - which calls the delegate method if the method is introduced, otherwise proceeds towards the join point - is usually sufficient. In the present case, we need to add a check: no setter method can be invoked if in locked mode.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"A class-level annotation that is used to declare that the ApplicationContext loaded for an integration test should be a WebApplicationContext. The mere presence of @WebAppConfiguration on a test class ensures that a WebApplicationContext will be loaded for the test, using the default value of ""file:src/main/webapp"" for the path to the root of the web application (i.e., the resource base path). The resource base path is used behind the scenes to create a MockServletContext which serves as the ServletContext for the test's WebApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To override the default, specify a different base resource path via the implicit value attribute. Both classpath: and file: resource prefixes are supported. If no resource prefix is supplied the path is assumed to be a file system resource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Note that @WebAppConfiguration must be used in conjunction with @ContextConfiguration, either within a single test class or within a test class hierarchy. See the Javadoc for @WebAppConfiguration for further details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"A class-level annotation that is used to define a hierarchy of ApplicationContexts for integration tests. @ContextHierarchy should be declared with a list of one or more @ContextConfiguration instances, each of which defines a level in the context hierarchy. The following examples demonstrate the use of @ContextHierarchy within a single test class; however, @ContextHierarchy can also be used within a test class hierarchy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy, you must explicitly name that level by supplying the same value to the name attribute in @ContextConfiguration at each corresponding level in the class hierarchy. See the section called “Context hierarchies” and the Javadoc for @ContextHierarchy for further examples.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
A class-level annotation that is used to declare which bean definition profiles should be active when loading an ApplicationContext for test classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
@ActiveProfiles provides support for inheriting active bean definition profiles declared by superclasses by default.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
See the section called “Context configuration with environment profiles” and the Javadoc for @ActiveProfiles for examples and further details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Indicates that the underlying Spring ApplicationContext has been dirtied during the execution of a test (i.e., modified or corrupted in some manner — for example, by changing the state of a singleton bean) and should be closed, regardless of whether the test passed. When an application context is marked dirty, it is removed from the testing framework's cache and closed. As a consequence, the underlying Spring container will be rebuilt for any subsequent test that requires a context with the same configuration metadata.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"@DirtiesContext can be used as both a class-level and method-level annotation within the same test class. In such scenarios, the ApplicationContext is marked as dirty after any such annotated method as well as after the entire class. If the ClassMode is set to AFTER_EACH_TEST_METHOD, the context is marked dirty after each test method in the class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following examples explain when the context would be dirtied for various configuration scenarios:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"After the current test class, when declared on a class with class mode set to AFTER_CLASS (i.e., the default class mode).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"After each test method in the current test class, when declared on a class with class mode set to AFTER_EACH_TEST_METHOD.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"After the current test, when declared on a method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If @DirtiesContext is used in a test whose context is configured as part of a context hierarchy via @ContextHierarchy, the hierarchyMode flag can be used to control how the context cache is cleared. By default an exhaustive algorithm will be used that clears the context cache including not only the current level but also all other context hierarchies that share an ancestor context common to the current test; all ApplicationContexts that reside in a sub-hierarchy of the common ancestor context will be removed from the context cache and closed. If the exhaustive algorithm is overkill for a particular use case, the simpler current level algorithm can be specified instead, as seen below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
For further details regarding the EXHAUSTIVE and CURRENT_LEVEL algorithms see the Javadoc for DirtiesContext.HierarchyMode.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Defines class-level metadata for configuring which TestExecutionListeners should be registered with the TestContextManager. Typically, @TestExecutionListeners is used in conjunction with @ContextConfiguration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
@TestExecutionListeners supports inherited listeners by default. See the Javadoc for an example and further details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Defines class-level metadata for configuring transactional tests. Specifically, the bean name of the PlatformTransactionManager that should be used to drive transactions can be explicitly specified if there are multiple beans of type PlatformTransactionManager in the test's ApplicationContext and if the bean name of the desired PlatformTransactionManager is not ""transactionManager"". In addition, you can change the defaultRollback flag to false. Typically, @TransactionConfiguration is used in conjunction with @ContextConfiguration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If the default conventions are sufficient for your test configuration, you can avoid using @TransactionConfiguration altogether. In other words, if you have only one transaction manger — or if you have multiple transaction mangers but the transaction manager for tests is named ""transactionManager"" or specified via a TransactionManagementConfigurer — and if you want transactions to roll back automatically, then there is no need to annotate your test class with @TransactionConfiguration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Indicates whether the transaction for the annotated test method should be rolled back after the test method has completed. If true, the transaction is rolled back; otherwise, the transaction is committed. Use @Rollback to override the default rollback flag configured at the class level.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Indicates that the annotated public void method should be executed before a transaction is started for test methods configured to run within a transaction via the @Transactional annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Indicates that the annotated public void method should be executed after a transaction has ended for test methods configured to run within a transaction via the @Transactional annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The presence of this annotation indicates that the annotated test method must not execute in a transactional context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The full AspectJ pointcut language supports additional pointcut designators that are not supported in Spring. These are: call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, and @withincode. Use of these pointcut designators in pointcut expressions interpreted by Spring AOP will result in an IllegalArgumentException being thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The set of pointcut designators supported by Spring AOP may be extended in future releases to support more of the AspectJ pointcut designators.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
@args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
@within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Because Spring AOP limits matching to only method execution join points, the discussion of the pointcut designators above gives a narrower definition than you will find in the AspectJ programming guide. In addition, AspectJ itself has type-based semantics and at an execution join point both 'this' and 'target' refer to the same object - the object executing the method. Spring AOP is a proxy-based system and differentiates between the proxy object itself (bound to 'this') and the target object behind the proxy (bound to 'target').",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Due to the proxy-based nature of Spring's AOP framework, protected methods are by definition not intercepted, neither for JDK proxies (where this isn't applicable) nor for CGLIB proxies (where this is technically possible but not recommendable for AOP purposes). As a consequence, any given pointcut will be matched against public methods only!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If your interception needs include protected/private methods or even constructors, consider the use of Spring-driven native AspectJ weaving instead of Spring's proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving first before making a decision.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring AOP also supports an additional PCD named 'bean'. This PCD allows you to limit the matching of join points to a particular named Spring bean, or to a set of named Spring beans (when using wildcards). The 'bean' PCD has the following form:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The 'idOrNameOfBean' token can be the name of any Spring bean: limited wildcard support using the '*' character is provided, so if you establish some naming conventions for your Spring beans you can quite easily write a 'bean' PCD expression to pick them out. As is the case with other pointcut designators, the 'bean' PCD can be &&'ed, ||'ed, and ! (negated) too.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Please note that the 'bean' PCD is only supported in Spring AOP - and not in native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that AspectJ defines.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The 'bean' PCD operates at the instance level (building on the Spring bean name concept) rather than at the type level only (which is what weaving-based AOP is limited to). Instance-based pointcut designators are a special capability of Spring's proxy-based AOP framework and its close integration with the Spring bean factory, where it is natural and straightforward to identify specific beans by name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Pointcut expressions can be combined using '&&', '||' and '!'. It is also possible to refer to pointcut expressions by name. The following example shows three pointcut expressions: anyPublicOperation (which matches if a method execution join point represents the execution of any public method); inTrading (which matches if a method execution is in the trading module), and tradingOperation (which matches if a method execution represents any public method in the trading module).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"It is a best practice to build more complex pointcut expressions out of smaller named components as shown above. When referring to pointcuts by name, normal Java visibility rules apply (you can see private pointcuts in the same type, protected pointcuts in the hierarchy, public pointcuts anywhere and so on). Visibility does not affect pointcut matching.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When working with enterprise applications, you often want to refer to modules of the application and particular sets of operations from within several aspects. We recommend defining a ""SystemArchitecture"" aspect that captures common pointcut expressions for this purpose. A typical such aspect would look as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The pointcuts defined in such an aspect can be referred to anywhere that you need a pointcut expression. For example, to make the service layer transactional, you could write:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The <aop:config> and <aop:advisor> elements are discussed in Section 9.3, “Schema-based AOP support”. The transaction elements are discussed in Chapter 12, Transaction Management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP users are likely to use the execution pointcut designator the most often. The format of an execution expression is:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"All parts except the returning type pattern (ret-type-pattern in the snippet above), name pattern, and parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. Most frequently you will use * as the returning type pattern, which matches any return type. A fully-qualified type name will match only when the method returns the given type. The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern. The parameters pattern is slightly more complex: () matches a method that takes no parameters, whereas (..) matches any number of parameters (zero or more). The pattern (*) matches a method taking one parameter of any type, (*,String) matches a method taking two parameters, the first can be of any type, the second must be a String. Consult the Language Semantics section of the AspectJ Programming Guide for more information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Some examples of common pointcut expressions are given below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
the execution of any public method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"the execution of any method with a name beginning with ""set"":",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
the execution of any method defined by the AccountService interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
the execution of any method defined in the service package:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring abstracts all marshalling operations behind the org.springframework.oxm.Marshaller interface, the main methods of which is listed below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The Marshaller interface has one main method, which marshals the given object to a given javax.xml.transform.Result. Result is a tagging interface that basically represents an XML output abstraction: concrete implementations wrap various XML representations, as indicated in the table below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Although the marshal() method accepts a plain object as its first parameter, most Marshaller implementations cannot handle arbitrary objects. Instead, an object class must be mapped in a mapping file, marked with an annotation, registered with the marshaller, or have a common base class. Refer to the further sections in this chapter to determine how your O/X technology of choice manages this.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Similar to the Marshaller, there is the org.springframework.oxm.Unmarshaller interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"This interface also has one method, which reads from the given javax.xml.transform.Source (an XML input abstraction), and returns the object read. As with Result, Source is a tagging interface that has three concrete implementations. Each wraps a different XML representation, as indicated in the table below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Even though there are two separate marshalling interfaces (Marshaller and Unmarshaller), all implementations found in Spring-WS implement both in one class. This means that you can wire up one marshaller class and refer to it both as a marshaller and an unmarshaller in your applicationContext.xml.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Spring converts exceptions from the underlying O/X mapping tool to its own exception hierarchy with the XmlMappingException as the root exception. As can be expected, these runtime exceptions wrap the original exception so no information will be lost.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Additionally, the MarshallingFailureException and UnmarshallingFailureException provide a distinction between marshalling and unmarshalling operations, even though the underlying O/X mapping tool does not do so.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The O/X Mapping exception hierarchy is shown in the following figure:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Spring's OXM can be used for a wide variety of situations. In the following example, we will use it to marshal the settings of a Spring-managed application as an XML file. We will use a simple JavaBean to represent the settings:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The application class uses this bean to store its settings. Besides a main method, the class has two methods: saveSettings() saves the settings bean to a file named settings.xml, and loadSettings() loads these settings again. A main() method constructs a Spring application context, and calls these two methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The Application requires both a marshaller and unmarshaller property to be set. We can do so using the following applicationContext.xml:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"This application context uses Castor, but we could have used any of the other marshaller instances described later in this chapter. Note that Castor does not require any further configuration by default, so the bean definition is rather simple. Also note that the CastorMarshaller implements both Marshaller and Unmarshaller, so we can refer to the castorMarshaller bean in both the marshaller and unmarshaller property of the application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
This sample application produces the following settings.xml file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Marshallers could be configured more concisely using tags from the OXM namespace. To make these tags available, the appropriate schema has to be referenced first in the preamble of the XML configuration file. Note the 'oxm' related text below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Currently, the following tags are available:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Each tag will be explained in its respective marshaller's section. As an example though, here is how the configuration of a JAXB2 marshaller might look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a jaxb.properties file, and possibly some resource files. JAXB also offers a way to generate a schema from annotated Java classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Spring supports the JAXB 2.0 API as XML marshalling strategies, following the Marshaller and Unmarshaller interfaces described in Section 16.2, “Marshaller and Unmarshaller”. The corresponding integration classes reside in the org.springframework.oxm.jaxb package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The Jaxb2Marshaller class implements both the Spring Marshaller and Unmarshallerinterface. It requires a context path to operate, which you can set using the contextPath property. The context path is a list of colon (:) separated Java package names that contain schema derived classes. It also offers a classesToBeBound property, which allows you to set an array of classes to be supported by the marshaller. Schema validation is performed by specifying one or more schema resource to the bean, like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The jaxb2-marshaller tag configures a org.springframework.oxm.jaxb.Jaxb2Marshaller. Here is an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Alternatively, the list of classes to bind can be provided to the marshaller via the class-to-be-bound child tag:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
Available attributes are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Castor XML mapping is an open source XML binding framework. It allows you to transform the data contained in a java object model into/from an XML document. By default, it does not require any further configuration, though a mapping file can be used to have more control over the behavior of Castor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"For more information on Castor, refer to the Castor web site. The Spring integration classes reside in the org.springframework.oxm.castor package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Spring provides a couple of out-of-the-box solutions for JSP and JSTL views. Using JSP or JSTL is done using a normal view resolver defined in the WebApplicationContext. Furthermore, of course you need to write some JSPs that will actually render the view.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Setting up your application to use JSTL is a common source of error, mainly caused by confusion over the different servlet spec., JSP and JSTL version numbers, what they mean and how to declare the taglibs correctly. The article How to Reference and Use JSTL in your Web Application provides a useful guide to the common pitfalls and how to avoid them. Note that as of Spring 3.0, the minimum supported servlet version is 2.4 (JSP 2.0 and JSTL 1.1), which reduces the scope for confusion somewhat.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Just as with any other view technology you're integrating with Spring, for JSPs you'll need a view resolver that will resolve your views. The most commonly used view resolvers when developing with JSPs are the InternalResourceViewResolver and the ResourceBundleViewResolver. Both are declared in the WebApplicationContext:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As you can see, the ResourceBundleViewResolver needs a properties file defining the view names mapped to 1) a class and 2) a URL. With a ResourceBundleViewResolver you can mix different types of views using only one resolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The InternalResourceBundleViewResolver can be configured for using JSPs as described above. As a best practice, we strongly encourage placing your JSP files in a directory under the 'WEB-INF' directory, so there can be no direct access by clients.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"When using the Java Standard Tag Library you must use a special view class, the JstlView, as JSTL needs some preparation before things such as the I18N features will work.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Spring provides data binding of request parameters to command objects as described in earlier chapters. To facilitate the development of JSP pages in combination with those data binding features, Spring provides a few tags that make things even easier. All Spring tags have HTML escaping features to enable or disable escaping of characters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The tag library descriptor (TLD) is included in the spring-webmvc.jar. Further information about the individual tags can be found in the appendix entitled Appendix G, spring.tld.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for handling form elements when using JSP and Spring Web MVC. Each tag provides support for the set of attributes of its corresponding HTML tag counterpart, making the tags familiar and intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Unlike other form/input tag libraries, Spring's form tag library is integrated with Spring Web MVC, giving the tags access to the command object and reference data your controller deals with. As you will see in the following examples, the form tags make JSPs easier to develop, read and maintain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Let's go through the form tags and look at an example of how each tag is used. We have included generated HTML snippets where certain tags require further commentary.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The form tag library comes bundled in spring-webmvc.jar. The library descriptor is called spring-form.tld.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"To use the tags from this library, add the following directive to the top of your JSP page:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
... where form is the tag name prefix you want to use for the tags from this library.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'form' tag and exposes a binding path to inner tags for binding. It puts the command object in the PageContext so that the command object can be accessed by inner tags. All the other tags in this library are nested tags of the form tag.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Let's assume we have a domain object called User. It is a JavaBean with properties such as firstName and lastName. We will use it as the form backing object of our form controller which returns form.jsp. Below is an example of what form.jsp would look like:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The firstName and lastName values are retrieved from the command object placed in the PageContext by the page controller. Keep reading to see more complex examples of how inner tags are used with the form tag.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The generated HTML looks like a standard form:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The preceding JSP assumes that the variable name of the form backing object is 'command'. If you have put the form backing object into the model under another name (definitely a best practice), then you can bind the form to the named variable like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This tag renders an HTML 'input' tag using the bound value and type='text' by default. For an example of this tag, see the section called “The form tag”. Starting with Spring 3.1 you can use other types such HTML5-specific types like 'email', 'tel', 'date', and others.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'input' tag with type 'checkbox'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Let's assume our User has preferences such as newsletter subscription and a list of hobbies. Below is an example of the Preferences class:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The form.jsp would look like:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
There are 3 approaches to the checkbox tag which should meet all your checkbox needs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Approach One - When the bound value is of type java.lang.Boolean, the input(checkbox) is marked as 'checked' if the bound value is true. The value attribute corresponds to the resolved value of the setValue(Object) value property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Approach Two - When the bound value is of type array or java.util.Collection, the input(checkbox) is marked as 'checked' if the configured setValue(Object) value is present in the bound Collection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Approach Three - For any other bound value type, the input(checkbox) is marked as 'checked' if the configured setValue(Object) is equal to the bound value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Note that regardless of the approach, the same HTML structure is generated. Below is an HTML snippet of some checkboxes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"What you might not expect to see is the additional hidden field after each checkbox. When a checkbox in an HTML page is not checked, its value will not be sent to the server as part of the HTTP request parameters once the form is submitted, so we need a workaround for this quirk in HTML in order for Spring form data binding to work. The checkbox tag follows the existing Spring convention of including a hidden parameter prefixed by an underscore (""_"") for each checkbox. By doing this, you are effectively telling Spring that “ the checkbox was visible in the form and I want my object to which the form data will be bound to reflect the state of the checkbox no matter what ”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Spring adds significant enhancements to the ORM layer of your choice when you create data access applications. You can leverage as much of the integration support as you wish, and you should compare this integration effort with the cost and risk of building a similar infrastructure in-house. You can use much of the ORM support as you would a library, regardless of technology, because everything is designed as a set of reusable JavaBeans. ORM in a Spring IoC container facilitates configuration and deployment. Thus most examples in this section show configuration inside a Spring container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Benefits of using the Spring Framework to create your ORM DAOs include:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Easier testing. Spring's IoC approach makes it easy to swap the implementations and configuration locations of Hibernate SessionFactory instances, JDBC DataSource instances, transaction managers, and mapped object implementations (if needed). This in turn makes it much easier to test each piece of persistence-related code in isolation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Common data access exceptions. Spring can wrap exceptions from your ORM tool, converting them from proprietary (potentially checked) exceptions to a common runtime DataAccessException hierarchy. This feature allows you to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without annoying boilerplate catches, throws, and exception declarations. You can still trap and handle exceptions as necessary. Remember that JDBC exceptions (including DB-specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"General resource management. Spring application contexts can handle the location and configuration of Hibernate SessionFactory instances, JPA EntityManagerFactory instances, JDBC DataSource instances, iBATIS SQL Maps configuration objects, and other related resources. This makes these values easy to manage and change. Spring offers efficient, easy, and safe handling of persistence resources. For example, related code that uses Hibernate generally needs to use the same Hibernate Session to ensure efficiency and proper transaction handling. Spring makes it easy to create and bind a Session to the current thread transparently, by exposing a current Session through the Hibernate SessionFactory. Thus Spring solves many chronic problems of typical Hibernate usage, for any local or JTA transaction environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Integrated transaction management. You can wrap your ORM code with a declarative, aspect-oriented programming (AOP) style method interceptor either through the @Transactional annotation or by explicitly configuring the transaction AOP advice in an XML configuration file. In both cases, transaction semantics and exception handling (rollback, and so on) are handled for you. As discussed below, in Resource and transaction management, you can also swap various transaction managers, without affecting your ORM-related code. For example, you can swap between local transactions and JTA, with the same full services (such as declarative transactions) available in both scenarios. Additionally, JDBC-related code can fully integrate transactionally with the code you use to do ORM. This is useful for data access that is not suitable for ORM, such as batch processing and BLOB streaming, which still need to share common transactions with ORM operations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This section highlights considerations that apply to all ORM technologies. The Section 15.3, “Hibernate” section provides more details and also show these features and configurations in a concrete context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The major goal of Spring's ORM integration is clear application layering, with any data access and transaction technology, and for loose coupling of application objects. No more business service dependencies on the data access or transaction strategy, no more hard-coded resource lookups, no more hard-to-replace singletons, no more custom service registries. One simple and consistent approach to wiring up application objects, keeping them as reusable and free from container dependencies as possible. All the individual data access features are usable on their own but integrate nicely with Spring's application context concept, providing XML-based configuration and cross-referencing of plain JavaBean instances that need not be Spring-aware. In a typical Spring application, many important objects are JavaBeans: data access templates, data access objects, transaction managers, business services that use the data access objects and transaction managers, web view resolvers, web controllers that use the business services,and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Typical business applications are cluttered with repetitive resource management code. Many projects try to invent their own solutions, sometimes sacrificing proper handling of failures for programming convenience. Spring advocates simple solutions for proper resource handling, namely IoC through templating in the case of JDBC and applying AOP interceptors for the ORM technologies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The infrastructure provides proper resource handling and appropriate conversion of specific API exceptions to an unchecked infrastructure exception hierarchy. Spring introduces a DAO exception hierarchy, applicable to any data access strategy. For direct JDBC, the JdbcTemplate class mentioned in a previous section provides connection handling and proper conversion of SQLException to the DataAccessException hierarchy, including translation of database-specific SQL error codes to meaningful exception classes. For ORM technologies, see the next section for how to get the same exception translation benefits.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"When it comes to transaction management, the JdbcTemplate class hooks in to the Spring transaction support and supports both JTA and JDBC transactions, through respective Spring transaction managers. For the supported ORM technologies Spring offers Hibernate, JPA and JDO support through the Hibernate, JPA, and JDO transaction managers as well as JTA support. For details on transaction support, see the Chapter 12, Transaction Management chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"When you use Hibernate, JPA, or JDO in a DAO, you must decide how to handle the persistence technology's native exception classes. The DAO throws a subclass of a HibernateException, PersistenceException or JDOException depending on the technology. These exceptions are all run-time exceptions and do not have to be declared or caught. You may also have to deal with IllegalArgumentException and IllegalStateException. This means that callers can only treat exceptions as generally fatal, unless they want to depend on the persistence technology's own exception structure. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly ORM-based and/or do not need any special exception treatment. However, Spring enables exception translation to be applied transparently through the @Repository annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The postprocessor automatically looks for all exception translators (implementations of the PersistenceExceptionTranslator interface) and advises all beans marked with the @Repository annotation so that the discovered translators can intercept and apply the appropriate translation on the thrown exceptions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In summary: you can implement DAOs based on the plain persistence technology's API and annotations, while still benefiting from Spring-managed transactions, dependency injection, and transparent exception conversion (if desired) to Spring's custom exception hierarchies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"We will start with a coverage of Hibernate 3 in a Spring environment, using it to demonstrate the approach that Spring takes towards integrating O/R mappers. This section will cover many issues in detail and show different variations of DAO implementations and transaction demarcation. Most of these patterns can be directly translated to all other supported ORM tools. The following sections in this chapter will then cover the other ORM technologies, showing briefer examples there.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As of Spring 3.0, Spring requires Hibernate 3.2 or later.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"To avoid tying application objects to hard-coded resource lookups, you can define resources such as a JDBC DataSource or a Hibernate SessionFactory as beans in the Spring container. Application objects that need to access resources receive references to such predefined instances through bean references, as illustrated in the DAO definition in the next section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The following excerpt from an XML application context definition shows how to set up a JDBC DataSource and a Hibernate SessionFactory on top of it:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Switching from a local Jakarta Commons DBCP BasicDataSource to a JNDI-located DataSource (usually managed by an application server) is just a matter of configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You can also access a JNDI-located SessionFactory, using Spring's JndiObjectFactoryBean / <jee:jndi-lookup> to retrieve and expose it. However, that is typically not common outside of an EJB context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Hibernate 3 has a feature called contextual sessions, wherein Hibernate itself manages one current Session per transaction. This is roughly equivalent to Spring's synchronization of one Hibernate Session per transaction. A corresponding DAO implementation resembles the following example, based on the plain Hibernate API:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This style is similar to that of the Hibernate reference documentation and examples, except for holding the SessionFactory in an instance variable. We strongly recommend such an instance-based setup over the old-school static HibernateUtil class from Hibernate's CaveatEmptor sample application. (In general, do not keep any resources in static variables unless absolutely necessary.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The above DAO follows the dependency injection pattern: it fits nicely into a Spring IoC container, just as it would if coded against Spring's HibernateTemplate. Of course, such a DAO can also be set up in plain Java (for example, in unit tests). Simply instantiate it and call setSessionFactory(..) with the desired factory reference. As a Spring bean definition, the DAO would resemble the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Table 14.1. Spring JDBC - who does what?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The Spring Framework takes care of all the low-level details that can make JDBC such a tedious API to develop with.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You can choose among several approaches to form the basis for your JDBC database access. In addition to three flavors of the JdbcTemplate, a new SimpleJdbcInsert and SimplejdbcCall approach optimizes database metadata, and the RDBMS Object style takes a more object-oriented approach similar to that of JDO Query design. Once you start using one of these approaches, you can still mix and match to include a feature from a different approach. All approaches require a JDBC 2.0-compliant driver, and some advanced features require a JDBC 3.0 driver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Spring 3.0 updates all of the following approaches with Java 5 support such as generics and varargs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"JdbcTemplate is the classic Spring JDBC approach and the most popular. This ""lowest level"" approach and all others use a JdbcTemplate under the covers, and all are updated with Java 5 support such as generics and varargs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"NamedParameterJdbcTemplate wraps a JdbcTemplate to provide named parameters instead of the traditional JDBC ""?"" placeholders. This approach provides better documentation and ease of use when you have multiple parameters for an SQL statement.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"SimpleJdbcInsert and SimpleJdbcCall optimize database metadata to limit the amount of necessary configuration. This approach simplifies coding so that you only need to provide the name of the table or procedure and provide a map of parameters matching the column names. This only works if the database provides adequate metadata. If the database doesn't provide this metadata, you will have to provide explicit configuration of the parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"RDBMS Objects including MappingSqlQuery, SqlUpdate and StoredProcedure requires you to create reusable and thread-safe objects during initialization of your data access layer. This approach is modeled after JDO Query wherein you define your query string, declare parameters, and compile the query. Once you do that, execute methods can be called multiple times with various parameter values passed in.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The Spring Framework's JDBC abstraction framework consists of four different packages, namely core, datasource, object, and support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The org.springframework.jdbc.object package contains classes that represent RDBMS queries, updates, and stored procedures as thread safe, reusable objects. See Section 14.6, “Modeling JDBC operations as Java objects”.This approach is modeled by JDO, although of course objects returned by queries are “disconnected” from the database. This higher level of JDBC abstraction depends on the lower-level abstraction in the org.springframework.jdbc.core package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The org.springframework.jdbc.support package provides SQLException translation functionality and some utility classes. Exceptions thrown during JDBC processing are translated to exceptions defined in the org.springframework.dao package. This means that code using the Spring JDBC abstraction layer does not need to implement JDBC or RDBMS-specific error handling. All translated exceptions are unchecked, which gives you the option of catching the exceptions from which you can recover while allowing other exceptions to be propagated to the caller. See Section 14.2.3, “SQLExceptionTranslator”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The JdbcTemplate class is the central class in the JDBC core package. It handles the creation and release of resources, which helps you avoid common errors such as forgetting to close the connection. It performs the basic tasks of the core JDBC workflow such as statement creation and execution, leaving application code to provide SQL and extract results. The JdbcTemplate class executes SQL queries, update statements and stored procedure calls, performs iteration over ResultSets and extraction of returned parameter values. It also catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"When you use the JdbcTemplate for your code, you only need to implement callback interfaces, giving them a clearly defined contract. The PreparedStatementCreator callback interface creates a prepared statement given a Connection provided by this class, providing SQL and any necessary parameters. The same is true for the CallableStatementCreator interface, which creates callable statements. The RowCallbackHandler interface extracts values from each row of a ResultSet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The JdbcTemplate can be used within a DAO implementation through direct instantiation with a DataSource reference, or be configured in a Spring IoC container and given to DAOs as a bean reference.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The DataSource should always be configured as a bean in the Spring IoC container. In the first case the bean is given to the service directly; in the second case it is given to the prepared template.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"All SQL issued by this class is logged at the DEBUG level under the category corresponding to the fully qualified class name of the template instance (typically JdbcTemplate, but it may be different if you are using a custom subclass of the JdbcTemplate class).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
This section provides some examples of JdbcTemplate class usage. These examples are not an exhaustive list of all of the functionality exposed by the JdbcTemplate; see the attendant Javadocs for that.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Here is a simple query for getting the number of rows in a relation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
A simple query using a bind variable:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Querying for a String:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Querying and populating a single domain object:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Querying and populating a number of domain objects:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If the last two snippets of code actually existed in the same application, it would make sense to remove the duplication present in the two RowMapper anonymous inner classes, and extract them out into a single class (typically a static inner class) that can then be referenced by DAO methods as needed. For example, it may be better to write the last code snippet as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You use the update(..) method to perform insert, update and delete operations. Parameter values are usually provided as var args or alternatively as an object array.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"A key design principle in Spring Web MVC and in Spring in general is the “Open for extension, closed for modification” principle.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Some methods in the core classes of Spring Web MVC are marked final. As a developer you cannot override these methods to supply your own behavior. This has not been done arbitrarily, but specifically with this principle in mind.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Bob Martin, The Open-Closed Principle (PDF)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You cannot add advice to final methods when you use Spring MVC. For example, you cannot add advice to the AbstractController.setSynchronizeOnSession() method. Refer to Section 9.6.1, “Understanding AOP proxies” for more information on AOP proxies and why you cannot add advice to final methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In Spring Web MVC you can use any object as a command or form-backing object; you do not need to implement a framework-specific interface or base class. Spring's data binding is highly flexible: for example, it treats type mismatches as validation errors that can be evaluated by the application, not as system errors. Thus you need not duplicate your business objects' properties as simple, untyped strings in your form objects simply to handle invalid submissions, or to convert the Strings properly. Instead, it is often preferable to bind directly to your business objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring's view resolution is extremely flexible. A Controller is typically responsible for preparing a model Map with data and selecting a view name but it can also write directly to the response stream and complete the request. View name resolution is highly configurable through file extension or Accept header content type negotiation, through bean names, a properties file, or even a custom ViewResolver implementation. The model (the M in MVC) is a Map interface, which allows for the complete abstraction of the view technology. You can integrate directly with template based rendering technologies such as JSP, Velocity and Freemarker, or directly generate XML, JSON, Atom, and many other types of content. The model Map is simply transformed into an appropriate format, such as JSP request attributes, a Velocity template model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring Web Flow (SWF) aims to be the best solution for the management of web application page flow.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"SWF integrates with existing frameworks like Spring MVC, Struts, and JSF, in both servlet and portlet environments. If you have a business process (or processes) that would benefit from a conversational model as opposed to a purely request model, then SWF may be the solution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"SWF allows you to capture logical page flows as self-contained modules that are reusable in different situations, and as such is ideal for building web application modules that guide the user through controlled navigations that drive business processes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"For more information about SWF, consult the Spring Web Flow website.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring's web module includes many unique web support features:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Clear separation of roles. Each role — controller, validator, command object, form object, model object, DispatcherServlet, handler mapping, view resolver, and so on — can be fulfilled by a specialized object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Powerful and straightforward configuration of both framework and application classes as JavaBeans. This configuration capability includes easy referencing across contexts, such as from web controllers to business objects and validators.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Adaptability, non-intrusiveness, and flexibility. Define any controller method signature you need, possibly using one of the parameter annotations (such as @RequestParam, @RequestHeader, @PathVariable, and more) for a given scenario.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Reusable business code, no need for duplication. Use existing business objects as command or form objects instead of mirroring them to extend a particular framework base class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Customizable binding and validation. Type mismatches as application-level validation errors that keep the offending value, localized date and number binding, and so on instead of String-only form objects with manual parsing and conversion to business objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Customizable handler mapping and view resolution. Handler mapping and view resolution strategies range from simple URL-based configuration, to sophisticated, purpose-built resolution strategies. Spring is more flexible than web MVC frameworks that mandate a particular technique.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Flexible model transfer. Model transfer with a name/value Map supports easy integration with any view technology.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Customizable locale and theme resolution, support for JSPs with or without Spring tag library, support for JSTL, support for Velocity without the need for extra bridges, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Non-Spring MVC implementations are preferable for some projects. Many teams expect to leverage their existing investment in skills and tools. A large body of knowledge and experience exist for the Struts framework. If you can abide Struts' architectural flaws, it can be a viable choice for the web layer; the same applies to WebWork and other web MVC frameworks.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you do not want to use Spring's web MVC, but intend to leverage other solutions that Spring offers, you can integrate the web MVC framework of your choice with Spring easily. Simply start up a Spring root application context through its ContextLoaderListener, and access it through its ServletContext attribute (or Spring's respective helper method) from within a Struts or WebWork action. No ""plug-ins"" are involved, so no dedicated integration is necessary. From the web layer's point of view, you simply use Spring as a library, with the root application context instance as the entry point.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Your registered beans and Spring's services can be at your fingertips even without Spring's Web MVC. Spring does not compete with Struts or WebWork in this scenario. It simply addresses the many areas that the pure web MVC frameworks do not, from bean configuration to data access and transaction handling. So you can enrich your application with a Spring middle tier and/or data access tier, even if you just want to use, for example, the transaction abstraction with JDBC or Hibernate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring's web MVC framework is, like many other web MVC frameworks, request-driven, designed around a central Servlet that dispatches requests to controllers and offers other functionality that facilitates the development of web applications. Spring's DispatcherServlet however, does more than just that. It is completely integrated with the Spring IoC container and as such allows you to use every other feature that Spring has.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The request processing workflow of the Spring Web MVC DispatcherServlet is illustrated in the following diagram. The pattern-savvy reader will recognize that the DispatcherServlet is an expression of the “Front Controller” design pattern (this is a pattern that Spring Web MVC shares with many other leading web frameworks).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The request processing workflow in Spring Web MVC (high level),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The DispatcherServlet is an actual Servlet (it inherits from the HttpServlet base class), and as such is declared in the web.xml of your web application. You need to map requests that you want the DispatcherServlet to handle, by using a URL mapping in the same web.xml file. This is standard Java EE Servlet configuration; the following example shows such a DispatcherServlet declaration and mapping:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the preceding example, all requests starting with /example will be handled by the DispatcherServlet instance named example. In a Servlet 3.0+ environment, you also have the option of configuring the Servlet container programmatically. Below is the code based equivalent of the above web.xml example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Consistent programming model across different transaction APIs such as Java Transaction API (JTA), JDBC, Hibernate, Java Persistence API (JPA), and Java Data Objects (JDO).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Support for declarative transaction management.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Simpler API for programmatic transaction management than complex transaction APIs such as JTA.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Excellent integration with Spring's data access abstractions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The following sections describe the Spring Framework's transaction value-adds and technologies. (The chapter also includes discussions of best practices, application server integration, and solutions to common problems.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Advantages of the Spring Framework's transaction support model describes why you would use the Spring Framework's transaction abstraction instead of EJB Container-Managed Transactions (CMT) or choosing to drive local transactions through a proprietary API such as Hibernate.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Understanding the Spring Framework transaction abstraction outlines the core classes and describes how to configure and obtain DataSource instances from a variety of sources.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Synchronizing resources with transactions describes how the application code ensures that resources are created, reused, and cleaned up properly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Declarative transaction management describes support for declarative transaction management.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Programmatic transaction management covers support for programmatic (that is, explicitly coded) transaction management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Traditionally, Java EE developers have had two choices for transaction management: global or local transactions, both of which have profound limitations. Global and local transaction management is reviewed in the next two sections, followed by a discussion of how the Spring Framework's transaction management support addresses the limitations of the global and local transaction models.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API to use (partly due to its exception model). Furthermore, a JTA UserTransaction normally needs to be sourced from JNDI, meaning that you also need to use JNDI in order to use JTA. Obviously the use of global transactions would limit any potential reuse of application code, as JTA is normally only available in an application server environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Previously, the preferred way to use global transactions was via EJB CMT (Container Managed Transaction): CMT is a form of declarative transaction management (as distinguished from programmatic transaction management). EJB CMT removes the need for transaction-related JNDI lookups, although of course the use of EJB itself necessitates the use of JNDI. It removes most but not all of the need to write Java code to control transactions. The significant downside is that CMT is tied to JTA and an application server environment. Also, it is only available if one chooses to implement business logic in EJBs, or at least behind a transactional EJB facade. The negatives of EJB in general are so great that this is not an attractive proposition, especially in the face of compelling alternatives for declarative transaction management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources. For example, code that manages transactions using a JDBC connection cannot run within a global JTA transaction. Because the application server is not involved in transaction management, it cannot help ensure correctness across multiple resources. (It is worth noting that most applications use a single transaction resource.) Another downside is that local transactions are invasive to the programming model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Spring resolves the disadvantages of global and local transactions. It enables application developers to use a consistent programming model in any environment. You write your code once, and it can benefit from different transaction management strategies in different environments. The Spring Framework provides both declarative and programmatic transaction management. Most users prefer declarative transaction management, which is recommended in most cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"With programmatic transaction management, developers work with the Spring Framework transaction abstraction, which can run over any underlying transaction infrastructure. With the preferred declarative model, developers typically write little or no code related to transaction management, and hence do not depend on the Spring Framework transaction API, or any other transaction API.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Do you need an application server for transaction management?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The Spring Framework's transaction management support changes traditional rules as to when an enterprise Java application requires an application server.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In particular, you do not need an application server simply for declarative transactions through EJBs. In fact, even if your application server has powerful JTA capabilities, you may decide that the Spring Framework's declarative transactions offer more power and a more productive programming model than EJB CMT.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Typically you need an application server's JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. Many high-end applications use a single, highly scalable database (such as Oracle RAC) instead. Standalone transaction managers such as Atomikos Transactions and JOTM are other options. Of course, you may need other application server capabilities such as Java Message Service (JMS) and J2EE Connector Architecture (JCA).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring Framework gives you the choice of when to scale your application to a fully loaded application server. Gone are the days when the only alternative to using EJB CMT or JTA was to write code with local transactions such as those on JDBC connections, and face a hefty rework if you need that code to run within global, container-managed transactions. With the Spring Framework, only some of the bean definitions in your configuration file, rather than your code, need to change.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The key to the Spring transaction abstraction is the notion of a transaction strategy. A transaction strategy is defined by the org.springframework.transaction.PlatformTransactionManager interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"This is primarily a service provider interface (SPI), although it can be used programmatically from your application code. Because PlatformTransactionManager is an interface, it can be easily mocked or stubbed as necessary. It is not tied to a lookup strategy such as JNDI. PlatformTransactionManager implementations are defined like any other object (or bean) in the Spring Framework IoC container. This benefit alone makes Spring Framework transactions a worthwhile abstraction even when you work with JTA. Transactional code can be tested much more easily than if it used JTA directly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
This part of the reference documentation covers the Spring Framework's integration with a number of Java EE (and related) technologies.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-integration.html
"Chapter 23, JMS (Java Message Service)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/spring-integration.html
"Certain inter-module dependencies are now optional at the Maven POM level where they were once required. For example, spring-tx and its dependence on spring-context. This may result in ClassNotFoundErrors or other similar problems for users that have been relying on transitive dependency management to pull in affected downstream spring-* . To resolve this problem, simply add the appropriate missing jars to your build configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"Along with Spring's new JCache support, the EHCache support classes in the org.springframework.cache.ehcache package moved from the spring-context module to spring-context-support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"In versions 3.0 and 3.1, we published a discrete spring-asm containing repackaged org.objectweb.asm 3.x sources. As of Spring Framework 3.2, we have upgraded to org.objectweb.asm 4.0 and done away with the separate module jar, favoring inlining these classes directly within spring-core. This should cause no migration issue for most users; but on the off chance that you have spring-asm declared directly within your project's build script, you'll want to remove it when upgrading to Spring Framework 3.2.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"In prior versions, users of Spring's subclass-based AOP proxies (e.g. via proxy-target-class=""true"") and @Configuration class support were required to declare an explicit dependency on CGLIB 2.2. As of Spring Framework 3.2, we now repackage and inline the newly-released CGLIB 3.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"This means greater convenience for users, as well as correct functionality for Java 7 users who are creating subclass proxies of types that contain invokedynamic bytecode instructions. Repackaging CGLIB internally ensures no classpath conflicts with other third party frameworks that may depend on other versions of CGLIB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
OSGi metadata is no longer published within individual Spring Framework jar MANIFEST.MF files. Please see this announcement for more information about how users can get OSGi-ready versions of Spring Framework 3.2 jars.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"As explained in Section 17.15.4, “Configuring Content Negotiation”, both the MVC Java config and the MVC namespace register extensions such as .json and .xml if the corresponding classpath dependencies are present. That means controller methods may now return JSON or XML formatted content if those extensions are present in the request URI, even if the 'Accept' header doesn't request those media types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"The newly added support for matrix variables is explained in the section called “Matrix Variables”. To preserve backward compatibility, by default, semicolon content is removed from incoming request URIs and therefore @MatrixVariable cannot be used without additional configuration. However, when using the MVC Java config and the MVC namespace, semicolon content is left in the URI so that matrix variables are automatically supported. The removal of semicolon content is controlled through the UrlPathHelper property of RequestMappingHandlerMapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
URI variable values now get decoded when UrlPathHelper.setUrlDecode is set to false. See SPR-9098.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
The DispatcherServlet now allows the HTTP PATCH method where previously it didn't.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"Besides the version number change, the set of Tiles dependencies has also changed. You will need to have a subset or all of tiles-request-api, tiles-api, tiles-core, tiles-servlet, tiles-jsp, tiles-el.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"If migrating from the spring-test-mvc standalone project to the spring-test module in Spring Framework 3.2, you will need to adjust the root package to be org.springframework.test.web.servlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"You will no longer be able to use the MockMvcBuilders annotationConfigSetup and xmlConfigSetup options. Instead you'll need to switch to using the @WebAppConfiguration support of spring-test for loading Spring configuration, then inject a WebApplicationContext into the test and use it to create a MockMvc. See Section 11.3.6, “Spring MVC Test Framework” for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"The spring-test module has been upgraded to depend on JUnit 4.11 (junit:junit), TestNG 6.5.2 (org.testng:testng), and Hamcrest Core 1.3 (org.hamcrest:hamcrest-core). Each of these dependencies is declared as an optional dependency in the Maven POM. Furthermore, it is important to note that the JUnit team has stopped inlining Hamcrest Core within the junit:junit Maven artifact as of JUnit 4.11. Hamcrest Core is now a required transitive dependency of junit, and users may therefore need to remove any exclusions on hamcrest-core that they had previously configured for their build.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"Select JDiff reports are now being published to provide users with a convenient means of understanding what's changed between versions. Going forward these will be published between each minor version, e.g. from 3.1.3.RELEASE to 3.1.4.RELEASE; from the latest maintenance version to the latest GA release, e.g. 3.1.3.RELEASE to 3.2.0.RELEASE; and in between each milestone and/or RC for users who are tracking next-generation development, e.g. 3.2.0.RC2 to 3.2.0.RELEASE.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
The following packages and types have been wholly or partially deprecated in Spring Framework 3.2 and may be removed in a future version. Click through to the linked Javadoc for each item for exact details. See also the complete list of deprecations in the framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests: use of the simpleJdbcTemplate instance variable has been deprecated in favor of the new jdbcTemplate instance variable.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests: use of the simpleJdbcTemplate instance variable has been deprecated in favor of the new jdbcTemplate instance variable.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
Spring provides a JMS integration framework that simplifies the use of the JMS API much like Spring's integration does for the JDBC API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"JMS can be roughly divided into two areas of functionality, namely the production and consumption of messages. The JmsTemplate class is used for message production and synchronous message reception. For asynchronous reception similar to Java EE's message-driven bean style, Spring provides a number of message listener containers that are used to create Message-Driven POJOs (MDPs).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The package org.springframework.jms.core provides the core functionality for using JMS. It contains JMS template classes that simplify the use of the JMS by handling the creation and release of resources, much like the JdbcTemplate does for JDBC. The design principle common to Spring template classes is to provide helper methods to perform common operations and for more sophisticated usage, delegate the essence of the processing task to user implemented callback interfaces. The JMS template follows the same design. The classes offer various convenience methods for the sending of messages, consuming a message synchronously, and exposing the JMS session and message producer to the user.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The package org.springframework.jms.support provides JMSException translation functionality. The translation converts the checked JMSException hierarchy to a mirrored hierarchy of unchecked exceptions. If there are any provider specific subclasses of the checked javax.jms.JMSException, this exception is wrapped in the unchecked UncategorizedJmsException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The package org.springframework.jms.support.converter provides a MessageConverter abstraction to convert between Java objects and JMS messages.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In general, use the Converter SPI when you need to implement general-purpose type conversion logic; for example, for converting between a java.util.Date and and java.lang.Long. Use the Formatter SPI when you're working in a client environment, such as a web application, and need to parse and print localized field values. The ConversionService provides a unified type conversion API for both SPIs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The Formatter SPI to implement field formatting logic is simple and strongly typed:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Where Formatter extends from the Printer and Parser building-block interfaces:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To create your own Formatter, simply implement the Formatter interface above. Parameterize T to be the type of object you wish to format, for example, java.util.Date. Implement the print() operation to print an instance of T for display in the client locale. Implement the parse() operation to parse an instance of T from the formatted representation returned from the client locale. Your Formatter should throw a ParseException or IllegalArgumentException if a parse attempt fails. Take care to ensure your Formatter implementation is thread-safe.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Several Formatter implementations are provided in format subpackages as a convenience. The number package provides a NumberFormatter, CurrencyFormatter, and PercentFormatter to format java.lang.Number objects using a java.text.NumberFormat. The datetime package provides a DateFormatter to format java.util.Date objects with a java.text.DateFormat. The datetime.joda package provides comprehensive datetime formatting support based on the Joda Time library.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Consider DateFormatter as an example Formatter implementation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The Spring team welcomes community-driven Formatter contributions; see http://jira.springframework.org to contribute.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"As you will see, field formatting can be configured by field type or annotation. To bind an Annotation to a formatter, implement AnnotationFormatterFactory:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Parameterize A to be the field annotationType you wish to associate formatting logic with, for example org.springframework.format.annotation.DateTimeFormat. Have getFieldTypes() return the types of fields the annotation may be used on. Have getPrinter() return a Printer to print the value of an annotated field. Have getParser() return a Parser to parse a clientValue for an annotated field.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The example AnnotationFormatterFactory implementation below binds the @NumberFormat Annotation to a formatter. This annotation allows either a number style or pattern to be specified:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To trigger formatting, simply annotate fields with @NumberFormat:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A portable format annotation API exists in the org.springframework.format.annotation package. Use @NumberFormat to format java.lang.Number fields. Use @DateTimeFormat to format java.util.Date, java.util.Calendar, java.util.Long, or Joda Time fields.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The example below uses @DateTimeFormat to format a java.util.Date as a ISO Date (yyyy-MM-dd):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The FormatterRegistry is an SPI for registering formatters and converters. FormattingConversionService is an implementation of FormatterRegistry suitable for most environments. This implementation may be configured programmatically or declaratively as a Spring bean using FormattingConversionServiceFactoryBean. Because this implementation also implements ConversionService, it can be directly configured for use with Spring's DataBinder and the Spring Expression Language (SpEL).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Review the FormatterRegistry SPI below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"As shown above, Formatters can be registered by fieldType or annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The FormatterRegistry SPI allows you to configure Formatting rules centrally, instead of duplicating such configuration across your Controllers. For example, you might want to enforce that all Date fields are formatted a certain way, or fields with a specific annotation are formatted in a certain way. With a shared FormatterRegistry, you define these rules once and they are applied whenever formatting is needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The FormatterRegistrar is an SPI for registering formatters and converters through the FormatterRegistry:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"A FormatterRegistrar is useful when registering multiple related converters and formatters for a given formatting category, such as Date formatting. It can also be useful where declarative registration is insufficient. For example when a formatter needs to be indexed under a specific field type different from its own <T> or when registering a Printer/Parser pair. The next section provides more information on converter and formatter registration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"In a Spring MVC application, you may configure a custom ConversionService instance explicitly as an attribute of the annotation-driven element of the MVC namespace. This ConversionService will then be used anytime a type conversion is required during Controller model binding. If not configured explicitly, Spring MVC will automatically register default formatters and converters for common types such as numbers and dates.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To rely on default formatting rules, no custom configuration is required in your Spring MVC config XML:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"With this one-line of configuration, default formatters for Numbers and Date types will be installed, including support for the @NumberFormat and @DateTimeFormat annotations. Full support for the Joda Time formatting library is also installed if Joda Time is present on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To inject a ConversionService instance with custom formatters and converters registered, set the conversion-service attribute and then specify custom converters, formatters, or FormatterRegistrars as properties of the FormattingConversionServiceFactoryBean:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"See Section 7.6.4, “FormatterRegistrar SPI” and the FormattingConversionServiceFactoryBean for more information on when to use FormatterRegistrars.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"By default, date and time fields that are not annotated with @DateTimeFormat are converted from strings using the the DateFormat.SHORT style. If you prefer, you can change this by defining your own global format.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"You will need to ensure that Spring does not register default formatters, and instead you should register all formatters manually. Use the org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar or org.springframework.format.datetime.DateFormatterRegistrar class depending on whether you use the Joda Time library.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type. Note that the index is 0 based.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
As of Spring 3.0 you can also use the constructor parameter name for value disambiguation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you can't compile your code with debug flag (or don't want to) you can use @ConstructorProperties JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following example shows a class that can only be dependency-injected using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The ApplicationContext supports constructor- and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies are already injected through the constructor approach. You configure the dependencies in the form of a BeanDefinition, which you use with PropertyEditor instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (programmatically), but rather with an XML definition file that is then converted internally into instances of these classes, and used to load an entire Spring IoC container instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Constructor-based or setter-based DI?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Since you can mix both, Constructor- and Setter-based DI, it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies. Note that the use of a @Required annotation on a setter can be used to make setters required dependencies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring team generally advocates setter injection, because large numbers of constructor arguments can get unwieldy, especially when properties are optional. Setter methods also make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is a compelling use case.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Some purists favor constructor-based injection. Supplying all object dependencies means that the object is always returned to client (calling) code in a totally initialized state. The disadvantage is that the object becomes less amenable to reconfiguration and re-injection.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Use the DI that makes the most sense for a particular class. Sometimes, when dealing with third-party classes to which you do not have the source, the choice is made for you. A legacy class may not expose any setter methods, and so constructor injection is the only available DI.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The container performs bean dependency resolution as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The ApplicationContext is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified via XML, Java code or annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor. These dependencies are provided to the bean, when the bean is actually created.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument. By default Spring can convert a value supplied in string format to all built-in types, such as int, long, String, boolean, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring container validates the configuration of each bean as the container is created, including the validation of whether bean reference properties refer to valid beans. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in Section 5.5, “Bean scopes” Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean's dependencies and its dependencies' dependencies (and so on) are created and assigned.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies. For example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why ApplicationContext implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the ApplicationContext is created, not later. You can still override this default behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a configured init method or the InitializingBean callback method) are invoked.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The introduction advisor required is simple. All it needs to do is hold a distinct LockMixin instance, and specify the introduced interfaces - in this case, just Lockable. A more complex example might take a reference to the introduction interceptor (which would be defined as a prototype): in this case, there's no configuration relevant for a LockMixin, so we simply create it using new.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"We can apply this advisor very simply: it requires no configuration. (However, it is necessary: It's impossible to use an IntroductionInterceptor without an IntroductionAdvisor.) As usual with introductions, the advisor must be per-instance, as it is stateful. We need a different instance of LockMixinAdvisor, and hence LockMixin, for each advised object. The advisor comprises part of the advised object's state.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"We can apply this advisor programmatically, using the Advised.addAdvisor() method, or (the recommended way) in XML configuration, like any other advisor. All proxy creation choices discussed below, including ""auto proxy creators,"" correctly handle introductions and stateful mixins.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"In Spring, an Advisor is an aspect that contains just a single advice object associated with a pointcut expression.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Apart from the special case of introductions, any advisor can be used with any advice. org.springframework.aop.support.DefaultPointcutAdvisor is the most commonly used advisor class. For example, it can be used with a MethodInterceptor, BeforeAdvice or ThrowsAdvice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"It is possible to mix advisor and advice types in Spring in the same AOP proxy. For example, you could use a interception around advice, throws advice and before advice in one proxy configuration: Spring will automatically create the necessary interceptor chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If you're using the Spring IoC container (an ApplicationContext or BeanFactory) for your business objects - and you should be! - you will want to use one of Spring's AOP FactoryBeans. (Remember that a factory bean introduces a layer of indirection, enabling it to create objects of a different type.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The Spring 2.0 AOP support also uses factory beans under the covers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The basic way to create an AOP proxy in Spring is to use the org.springframework.aop.framework.ProxyFactoryBean. This gives complete control over the pointcuts and advice that will apply, and their ordering. However, there are simpler options that are preferable if you don't need such control.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The ProxyFactoryBean, like other Spring FactoryBean implementations, introduces a level of indirection. If you define a ProxyFactoryBean with name foo, what objects referencing foo see is not the ProxyFactoryBean instance itself, but an object created by the ProxyFactoryBean's implementation of the getObject() method. This method will create an AOP proxy wrapping a target object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"One of the most important benefits of using a ProxyFactoryBean or another IoC-aware class to create AOP proxies, is that it means that advices and pointcuts can also be managed by IoC. This is a powerful feature, enabling certain approaches that are hard to achieve with other AOP frameworks. For example, an advice may itself reference application objects (besides the target, which should be available in any AOP framework), benefiting from all the pluggability provided by Dependency Injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"In common with most FactoryBean implementations provided with Spring, the ProxyFactoryBean class is itself a JavaBean. Its properties are used to:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Specify the target you want to proxy.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Specify whether to use CGLIB (see below and also Section 10.5.3, “JDK- and CGLIB-based proxies”).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Some key properties are inherited from org.springframework.aop.framework.ProxyConfig (the superclass for all AOP proxy factories in Spring). These key properties include:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"proxyTargetClass: true if the target class is to be proxied, rather than the target class' interfaces. If this property value is set to true, then CGLIB proxies will be created (but see also Section 10.5.3, “JDK- and CGLIB-based proxies”).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
optimize: controls whether or not aggressive optimizations are applied to proxies created via CGLIB. One should not blithely use this setting unless one fully understands how the relevant AOP proxy handles optimization. This is currently used only for CGLIB proxies; it has no effect with JDK dynamic proxies.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"frozen: if a proxy configuration is frozen, then changes to the configuration are no longer allowed. This is useful both as a slight optimization and for those cases when you don't want callers to be able to manipulate the proxy (via the Advised interface) after the proxy has been created. The default value of this property is false, so changes such as adding additional advice are allowed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"exposeProxy: determines whether or not the current proxy should be exposed in a ThreadLocal so that it can be accessed by the target. If a target needs to obtain the proxy and the exposeProxy property is set to true, the target can use the AopContext.currentProxy() method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Other properties specific to ProxyFactoryBean include:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"proxyInterfaces: array of String interface names. If this isn't supplied, a CGLIB proxy for the target class will be used (but see also Section 10.5.3, “JDK- and CGLIB-based proxies”).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"interceptorNames: String array of Advisor, interceptor or other advice names to apply. Ordering is significant, on a first come-first served basis. That is to say that the first interceptor in the list will be the first to be able to intercept the invocation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The names are bean names in the current factory, including bean names from ancestor factories. You can't mention bean references here since doing so would result in the ProxyFactoryBean ignoring the singleton setting of the advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"You can append an interceptor name with an asterisk (*). This will result in the application of all advisor beans with names starting with the part before the asterisk to be applied. An example of using this feature can be found in Section 10.5.6, “Using 'global' advisors”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"singleton: whether or not the factory should return a single object, no matter how often the getObject() method is called. Several FactoryBean implementations offer such a method. The default value is true. If you want to use stateful advice - for example, for stateful mixins - use prototype advices along with a singleton value of false.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
This section serves as the definitive documentation on how the ProxyFactoryBean chooses to create one of either a JDK- and CGLIB-based proxy for a particular target object (that is to be proxied).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The behavior of the ProxyFactoryBean with regard to creating JDK- or CGLIB-based proxies changed between versions 1.2.x and 2.0 of Spring. The ProxyFactoryBean now exhibits similar semantics with regard to auto-detecting interfaces as those of the TransactionProxyFactoryBean class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If the class of a target object that is to be proxied (hereafter simply referred to as the target class) doesn't implement any interfaces, then a CGLIB-based proxy will be created. This is the easiest scenario, because JDK proxies are interface based, and no interfaces means JDK proxying isn't even possible. One simply plugs in the target bean, and specifies the list of interceptors via the interceptorNames property. Note that a CGLIB-based proxy will be created even if the proxyTargetClass property of the ProxyFactoryBean has been set to false. (Obviously this makes no sense, and is best removed from the bean definition because it is at best redundant, and at worst confusing.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"As of Spring 3.0, @NotTransactional is deprecated in favor of moving the non-transactional test method to a separate (non-transactional) test class or to a @BeforeTransaction or @AfterTransaction method. As an alternative to annotating an entire class with @Transactional, consider annotating individual methods with @Transactional; doing so allows a mix of transactional and non-transactional methods in the same test class without the need for using @NotTransactional.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following annotations are supported with standard semantics for all configurations of the Spring TestContext Framework. Note that these annotations are not specific to tests and can be used anywhere in the Spring Framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the Spring TestContext Framework @PostConstruct and @PreDestroy may be used with standard semantics on any application components configured in the ApplicationContext; however, these lifecycle annotations have limited usage within an actual test class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If a method within a test class is annotated with @PostConstruct, that method will be executed before any before methods of the underlying test framework (e.g., methods annotated with JUnit's @Before), and that will apply for every test method in the test class. On the other hand, if a method within a test class is annotated with @PreDestroy, that method will never be executed. Within a test class it is therefore recommended to use test lifecycle callbacks from the underlying test framework instead of @PostConstruct and @PreDestroy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following annotations are only supported when used in conjunction with the SpringJUnit4ClassRunner or the JUnit support classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Indicates that the annotated test is enabled for a specific testing environment. If the configured ProfileValueSource returns a matching value for the provided name, the test is enabled. This annotation can be applied to an entire class or to individual methods. Class-level usage overrides method-level usage.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Alternatively, you can configure @IfProfileValue with a list of values (with OR semantics) to achieve TestNG-like support for test groups in a JUnit environment. Consider the following example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Class-level annotation that specifies what type of ProfileValueSource to use when retrieving profile values configured through the @IfProfileValue annotation. If @ProfileValueSourceConfiguration is not declared for a test, SystemProfileValueSource is used by default.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Indicates that the annotated test method must finish execution in a specified time period (in milliseconds). If the text execution time exceeds the specified time period, the test fails.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The time period includes execution of the test method itself, any repetitions of the test (see @Repeat), as well as any set up or tear down of the test fixture.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring's @Timed annotation has different semantics than JUnit's @Test(timeout=...) support. Specifically, due to the manner in which JUnit handles test execution timeouts (that is, by executing the test method in a separate Thread), @Test(timeout=...) applies to each iteration in the case of repetitions and preemptively fails the test if the test takes too long. Spring's @Timed, on the other hand, times the total test execution time (including all repetitions) and does not preemptively fail the test but rather waits for the test to complete before failing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Indicates that the annotated test method must be executed repeatedly. The number of times that the test method is to be executed is specified in the annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The scope of execution to be repeated includes execution of the test method itself as well as any set up or tear down of the test fixture.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring TestContext Framework (located in the org.springframework.test.context package) provides generic, annotation-driven unit and integration testing support that is agnostic of the testing framework in use. The TestContext framework also places a great deal of importance on convention over configuration with reasonable defaults that can be overridden through annotation-based configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In addition to generic testing infrastructure, the TestContext framework provides explicit support for JUnit and TestNG in the form of abstract support classes. For JUnit, Spring also provides a custom JUnit Runner that allows one to write so-called POJO test classes. POJO test classes are not required to extend a particular class hierarchy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following section provides an overview of the internals of the TestContext framework. If you are only interested in using the framework and not necessarily interested in extending it with your own custom listeners or custom loaders, feel free to go directly to the configuration (context management, dependency injection, transaction management), support classes, and annotation support sections.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The core of the framework consists of the TestContext and TestContextManager classes and the TestExecutionListener, ContextLoader, and SmartContextLoader interfaces. A TestContextManager is created on a per-test basis (e.g., for the execution of a single test method in JUnit). The TestContextManager in turn manages a TestContext that holds the context of the current test. The TestContextManager also updates the state of the TestContext as the test progresses and delegates to TestExecutionListeners, which instrument the actual test execution by providing dependency injection, managing transactions, and so on. A ContextLoader (or SmartContextLoader) is responsible for loading an ApplicationContext for a given test class. Consult the Javadoc and the Spring test suite for further information and examples of various implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"TestContext: Encapsulates the context in which a test is executed, agnostic of the actual testing framework in use, and provides context management and caching support for the test instance for which it is responsible. The TestContext also delegates to a ContextLoader (or SmartContextLoader) to load an ApplicationContext if requested.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"TestContextManager: The main entry point into the Spring TestContext Framework, which manages a single TestContext and signals events to all registered TestExecutionListeners at well-defined test execution points:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
TestExecutionListener: Defines a listener API for reacting to test execution events published by the TestContextManager with which the listener is registered.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring provides four TestExecutionListener implementations that are configured by default: ServletTestExecutionListener, DependencyInjectionTestExecutionListener, DirtiesContextTestExecutionListener, and TransactionalTestExecutionListener. Respectively, they support Servlet API mocks for a WebApplicationContext, dependency injection of the test instance, handling of the @DirtiesContext annotation, and transactional test execution with default rollback semantics.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
ContextLoader: Strategy interface introduced in Spring 2.5 for loading an ApplicationContext for an integration test managed by the Spring TestContext Framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
the execution of any method defined in the service package or a sub-package:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) within the service package:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) within the service package or a sub-package:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) where the proxy implements the AccountService interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'this' is more commonly used in a binding form :- see the following section on advice for how to make the proxy object available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) where the target object implements the AccountService interface:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'target' is more commonly used in a binding form :- see the following section on advice for how to make the target object available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"any join point (method execution only in Spring AOP) which takes a single parameter, and where the argument passed at runtime is Serializable:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'args' is more commonly used in a binding form :- see the following section on advice for how to make the method arguments available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that the pointcut given in this example is different to execution(* *(java.io.Serializable)): the args version matches if the argument passed at runtime is Serializable, the execution version matches if the method signature declares a single parameter of type Serializable.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) where the target object has an @Transactional annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'@target' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) where the declared type of the target object has an @Transactional annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'@within' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) where the executing method has an @Transactional annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'@annotation' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"any join point (method execution only in Spring AOP) which takes a single parameter, and where the runtime type of the argument passed has the @Classified annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
'@args' can also be used in a binding form :- see the following section on advice for how to make the annotation object(s) available in the advice body.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) on a Spring bean named 'tradeService':,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
any join point (method execution only in Spring AOP) on Spring beans having names that match the wildcard expression '*Service':,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"During compilation, AspectJ processes pointcuts in order to try and optimize matching performance. Examining code and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic match means the match cannot be fully determined from static analysis and a test will be placed in the code to determine if there is an actual match when the code is running). On first encountering a pointcut declaration, AspectJ will rewrite it into an optimal form for the matching process. What does this mean? Basically pointcuts are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding the performance of various pointcut designators and may supply them in any order in a pointcut declaration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"However, AspectJ can only work with what it is told, and for optimal performance of matching you should think about what they are trying to achieve and narrow the search space for matches as much as possible in the definition. The existing designators naturally fall into one of three groups: kinded, scoping and context:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"A well written pointcut should try and include at least the first two types (kinded and scoping), whilst the contextual designators may be included if wishing to match based on join point context, or bind that context for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping designators are very fast to match and their usage means AspectJ can very quickly dismiss groups of join points that should not be further processed - that is why a good pointcut should always include one if possible.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Advice is associated with a pointcut expression, and runs before, after, or around method executions matched by the pointcut. The pointcut expression may be either a simple reference to a named pointcut, or a pointcut expression declared in place.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Before advice is declared in an aspect using the @Before annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
If using an in-place pointcut expression we could rewrite the above example as:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After returning advice runs when a matched method execution returns normally. It is declared using the @AfterReturning annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note: it is of course possible to have multiple advice declarations, and other members as well, all inside the same aspect. We're just showing a single advice declaration in these examples to focus on the issue under discussion at the time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"As with JAXB, the CastorMarshaller implements both the Marshaller and Unmarshaller interface. It can be wired up as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Although it is possible to rely on Castor's default marshalling behavior, it might be necessary to have more control over it. This can be accomplished using a Castor mapping file. For more information, refer to Castor XML Mapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The mapping can be set using the mappingLocation resource property, indicated below with a classpath resource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The castor-marshaller tag configures a org.springframework.oxm.castor.CastorMarshaller. Here is an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The marshaller instance can be configured in two ways, by specifying either the location of a mapping file (through the mapping-location property), or by identifying Java POJOs (through the target-class or target-package properties) for which there exist corresponding XML descriptor classes. The latter way is usually used in conjunction with XML code generation from XML schemas.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
Available attributes are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"XMLBeans is an XML binding tool that has full XML Schema support, and offers full XML Infoset fidelity. It takes a different approach to that of most other O/X mapping frameworks, in that all classes that are generated from an XML Schema are all derived from XmlObject, and contain XML binding information in them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"For more information on XMLBeans, refer to the XMLBeans web site . The Spring-WS integration classes reside in the org.springframework.oxm.xmlbeans package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The XmlBeansMarshaller implements both the Marshaller and Unmarshaller interfaces. It can be configured as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Note that the XmlBeansMarshaller can only marshal objects of type XmlObject, and not every java.lang.Object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The xmlbeans-marshaller tag configures a org.springframework.oxm.xmlbeans.XmlBeansMarshaller. Here is an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
Available attributes are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The JiBX framework offers a solution similar to that which JDO provides for ORM: a binding definition defines the rules for how your Java objects are converted to or from XML. After preparing the binding and compiling the classes, a JiBX binding compiler enhances the class files, and adds code to handle converting instances of the classes from or to XML.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"For more information on JiBX, refer to the JiBX web site. The Spring integration classes reside in the org.springframework.oxm.jibx package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The JibxMarshaller class implements both the Marshaller and Unmarshaller interface. To operate, it requires the name of the class to marshal in, which you can set using the targetClass property. Optionally, you can set the binding name using the bindingName property. In the next sample, we bind the Flights class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"A JibxMarshaller is configured for a single class. If you want to marshal multiple classes, you have to configure multiple JibxMarshallers with different targetClass property values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
The jibx-marshaller tag configures a org.springframework.oxm.jibx.JibxMarshaller. Here is an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
Available attributes are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"XStream is a simple library to serialize objects to XML and back again. It does not require any mapping, and generates clean XML.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"For more information on XStream, refer to the XStream web site. The Spring integration classes reside in the org.springframework.oxm.xstream package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"The XStreamMarshaller does not require any configuration, and can be configured in an application context directly. To further customize the XML, you can set an alias map, which consists of string aliases mapped to classes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"By default, XStream allows for arbitrary classes to be unmarshalled, which can result in security vulnerabilities. As such, it is recommended to set the supportedClasses property on the XStreamMarshaller, like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
This will make sure that only the registered classes are eligible for unmarshalling.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Additionally, you can register custom converters to make sure that only your supported classes can be unmarshalled. You might want to add a CatchAllConverter as the last converter in the list, in addition to converters that explicitly support the domain classes that should be supported. As a result, default XStream converters with lower priorities and possible security vulnerabilities do not get invoked.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
"Note that XStream is an XML serialization library, not a data binding library. Therefore, it has limited namespace support. As such, it is rather unsuitable for usage within Web services.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/oxm.html
This tag renders multiple HTML 'input' tags with type 'checkbox'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Building on the example from the previous checkbox tag section. Sometimes you prefer not to have to list all the possible hobbies in your JSP page. You would rather provide a list at runtime of the available options and pass that in to the tag. That is the purpose of the checkboxes tag. You pass in an Array, a List or a Map containing the available options in the ""items"" property. Typically the bound property is a collection so it can hold multiple values selected by the user. Below is an example of the JSP using this tag:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This example assumes that the ""interestList"" is a List available as a model attribute containing strings of the values to be selected from. In the case where you use a Map, the map entry key will be used as the value and the map entry's value will be used as the label to be displayed. You can also use a custom object where you can provide the property names for the value using ""itemValue"" and the label using ""itemLabel"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'input' tag with type 'radio'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
A typical usage pattern will involve multiple tag instances bound to the same property but with different values.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders multiple HTML 'input' tags with type 'radio'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Just like the checkboxes tag above, you might want to pass in the available options as a runtime variable. For this usage you would use the radiobuttons tag. You pass in an Array, a List or a Map containing the available options in the ""items"" property. In the case where you use a Map, the map entry key will be used as the value and the map entry's value will be used as the label to be displayed. You can also use a custom object where you can provide the property names for the value using ""itemValue"" and the label using ""itemLabel"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'input' tag with type 'password' using the bound value.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Please note that by default, the password value is not shown. If you do want the password value to be shown, then set the value of the 'showPassword' attribute to true, like so.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'select' element. It supports data binding to the selected option as well as the use of nested option and options tags.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Let's assume a User has a list of skills.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If the User's skill were in Herbology, the HTML source of the 'Skills' row would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'option'. It sets 'selected' as appropriate based on the bound value.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If the User's house was in Gryffindor, the HTML source of the 'House' row would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders a list of HTML 'option' tags. It sets the 'selected' attribute as appropriate based on the bound value.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If the User lived in the UK, the HTML source of the 'Country' row would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As the example shows, the combined usage of an option tag with the options tag generates the same standard HTML, but allows you to explicitly specify a value in the JSP that is for display only (where it belongs) such as the default string in the example: ""-- Please Select"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The items attribute is typically populated with a collection or array of item objects. itemValue and itemLabel simply refer to bean properties of those item objects, if specified; otherwise, the item objects themselves will be stringified. Alternatively, you may specify a Map of items, in which case the map keys are interpreted as option values and the map values correspond to option labels. If itemValue and/or itemLabel happen to be specified as well, the item value property will apply to the map key and the item label property will apply to the map value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders an HTML 'textarea'.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This tag renders an HTML 'input' tag with type 'hidden' using the bound value. To submit an unbound hidden value, use the HTML input tag with type 'hidden'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If we choose to submit the 'house' value as a hidden one, the HTML would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
This tag renders field errors in an HTML 'span' tag. It provides access to the errors created in your controller or those that were created by any validators associated with your controller.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Let's assume we want to display all error messages for the firstName and lastName fields once we submit the form. We have a validator for instances of the User class called UserValidator.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The form.jsp would look like:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If we submit a form with empty values in the firstName and lastName fields, this is what the HTML would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
What if we want to display the entire list of errors for a given page? The example below shows that the errors tag also supports some basic wildcarding functionality.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The main advantage of this DAO style is that it depends on Hibernate API only; no import of any Spring class is required. This is of course appealing from a non-invasiveness perspective, and will no doubt feel more natural to Hibernate developers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"However, the DAO throws plain HibernateException (which is unchecked, so does not have to be declared or caught), which means that callers can only treat exceptions as generally fatal - unless they want to depend on Hibernate's own exception hierarchy. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly Hibernate-based and/or do not need any special exception treatment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Fortunately, Spring's LocalSessionFactoryBean supports Hibernate's SessionFactory.getCurrentSession() method for any Spring transaction strategy, returning the current Spring-managed transactional Session even with HibernateTransactionManager. Of course, the standard behavior of that method remains the return of the current Session associated with the ongoing JTA transaction, if any. This behavior applies regardless of whether you are using Spring's JtaTransactionManager, EJB container managed transactions (CMTs), or JTA.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In summary: you can implement DAOs based on the plain Hibernate 3 API, while still being able to participate in Spring-managed transactions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"We recommend that you use Spring's declarative transaction support, which enables you to replace explicit transaction demarcation API calls in your Java code with an AOP transaction interceptor. This transaction interceptor can be configured in a Spring container using either Java annotations or XML.This declarative transaction capability allows you to keep business services free of repetitive transaction demarcation code and to focus on adding business logic, which is the real value of your application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Prior to continuing, you are strongly encouraged to read Section 12.5, “Declarative transaction management” if you have not done so.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Furthermore, transaction semantics like propagation behavior and isolation level can be changed in a configuration file and do not affect the business service implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The following example shows how you can configure an AOP transaction interceptor, using XML, for a simple service class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
This is the service class that is advised:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"We also show an attribute-support based configuration, in the following example. You annotate the service layer with @Transactional annotations and instruct the Spring container to find these annotations and provide transactional semantics for these annotated methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As you can see from the following configuration example, the configuration is much simplified, compared to the XML example above, while still providing the same functionality driven by the annotations in the service layer code. All you need to provide is the TransactionManager implementation and a ""<tx:annotation-driven/>"" entry.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You can demarcate transactions in a higher level of the application, on top of such lower-level data access services spanning any number of operations. Nor do restrictions exist on the implementation of the surrounding business service; it just needs a Spring PlatformTransactionManager. Again, the latter can come from anywhere, but preferably as a bean reference through a setTransactionManager(..) method, just as the productDAO should be set by a setProductDao(..) method. The following snippets show a transaction manager and a business service definition in a Spring application context, and an example for a business method implementation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring's TransactionInterceptor allows any checked application exception to be thrown with the callback code, while TransactionTemplate is restricted to unchecked exceptions within the callback. TransactionTemplate triggers a rollback in case of an unchecked application exception, or if the transaction is marked rollback-only by the application (via TransactionStatus). TransactionInterceptor behaves the same way by default but allows configurable rollback policies per method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Both TransactionTemplate and TransactionInterceptor delegate the actual transaction handling to a PlatformTransactionManager instance, which can be a HibernateTransactionManager (for a single Hibernate SessionFactory, using a ThreadLocal Session under the hood) or a JtaTransactionManager (delegating to the JTA subsystem of the container) for Hibernate applications. You can even use a custom PlatformTransactionManager implementation. Switching from native Hibernate transaction management to JTA, such as when facing distributed transaction requirements for certain deployments of your application, is just a matter of configuration. Simply replace the Hibernate transaction manager with Spring's JTA transaction implementation. Both transaction demarcation and data access code will work without changes, because they just use the generic transaction management APIs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"For distributed transactions across multiple Hibernate session factories, simply combine JtaTransactionManager as a transaction strategy with multiple LocalSessionFactoryBean definitions. Each DAO then gets one specific SessionFactory reference passed into its corresponding bean property. If all underlying JDBC data sources are transactional container ones, a business service can demarcate transactions across any number of DAOs and any number of session factories without special regard, as long as it is using JtaTransactionManager as the strategy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Both HibernateTransactionManager and JtaTransactionManager allow for proper JVM-level cache handling with Hibernate, without container-specific transaction manager lookup or a JCA connector (if you are not using EJB to initiate transactions).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"HibernateTransactionManager can export the Hibernate JDBC Connection to plain JDBC access code, for a specific DataSource. This capability allows for high-level transaction demarcation with mixed Hibernate and JDBC data access completely without JTA, if you are accessing only one database. HibernateTransactionManager automatically exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in SessionFactory with a DataSource through the dataSource property of the LocalSessionFactoryBean class. Alternatively, you can specify explicitly the DataSource for which the transactions are supposed to be exposed through the dataSource property of the HibernateTransactionManager class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You can switch between a container-managed JNDI SessionFactory and a locally defined one, without having to change a single line of application code. Whether to keep resource definitions in the container or locally within the application is mainly a matter of the transaction strategy that you use. Compared to a Spring-defined local SessionFactory, a manually registered JNDI SessionFactory does not provide any benefits. Deploying a SessionFactory through Hibernate's JCA connector provides the added value of participating in the Java EE server's management infrastructure, but does not add actual value beyond that.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring's transaction support is not bound to a container. Configured with any strategy other than JTA, transaction support also works in a stand-alone or test environment. Especially in the typical case of single-database transactions, Spring's single-resource local transaction support is a lightweight and powerful alternative to JTA. When you use local EJB stateless session beans to drive transactions, you depend both on an EJB container and JTA, even if you access only a single database, and only use stateless session beans to provide declarative transactions through container-managed transactions. Also, direct use of JTA programmatically requires a Java EE environment as well. JTA does not involve only container dependencies in terms of JTA itself and of JNDI DataSource instances. For non-Spring, JTA-driven Hibernate transactions, you have to use the Hibernate JCA connector, or extra Hibernate transaction code with the TransactionManagerLookup configured for proper JVM-level caching.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring-driven transactions can work as well with a locally defined Hibernate SessionFactory as they do with a local JDBC DataSource if they are accessing a single database. Thus you only have to use Spring's JTA transaction strategy when you have distributed transaction requirements. A JCA connector requires container-specific deployment steps, and obviously JCA support in the first place. This configuration requires more work than deploying a simple web application with local resource definitions and Spring-driven transactions. Also, you often need the Enterprise Edition of your container if you are using, for example, WebLogic Express, which does not provide JCA. A Spring application with local resources and transactions spanning one single database works in any Java EE web container (without JTA, JCA, or EJB) such as Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle tier in desktop applications or test suites.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"All things considered, if you do not use EJBs, stick with local SessionFactory setup and Spring's HibernateTransactionManager or JtaTransactionManager. You get all of the benefits, including proper transactional JVM-level caching and distributed transactions, without the inconvenience of container deployment. JNDI registration of a Hibernate SessionFactory through the JCA connector only adds value when used in conjunction with EJBs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In some JTA environments with very strict XADataSource implementations -- currently only some WebLogic Server and WebSphere versions -- when Hibernate is configured without regard to the JTA PlatformTransactionManager object for that environment, it is possible for spurious warning or exceptions to show up in the application server log. These warnings or exceptions indicate that the connection being accessed is no longer valid, or JDBC access is no longer valid, possibly because the transaction is no longer active. As an example, here is an actual exception from WebLogic:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You resolve this warning by simply making Hibernate aware of the JTA PlatformTransactionManager instance, to which it will synchronize (along with Spring). You have two options for doing this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"If in your application context you are already directly obtaining the JTA PlatformTransactionManager object (presumably from JNDI through JndiObjectFactoryBean or <jee:jndi-lookup>) and feeding it, for example, to Spring's JtaTransactionManager, then the easiest way is to specify a reference to the bean defining this JTA PlatformTransactionManager instance as the value of the jtaTransactionManager property for LocalSessionFactoryBean. Spring then makes the object available to Hibernate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You can use the execute(..) method to execute any arbitrary SQL, and as such the method is often used for DDL statements. It is heavily overloaded with variants taking callback interfaces, binding variable arrays, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The following example invokes a simple stored procedure. More sophisticated stored procedure support is covered later.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Instances of the JdbcTemplate class are threadsafe once configured. This is important because it means that you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs (or repositories). The JdbcTemplate is stateful, in that it maintains a reference to a DataSource, but this state is not conversational state.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"A common practice when using the JdbcTemplate class (and the associated NamedParameterJdbcTemplate classes) is to configure a DataSource in your Spring configuration file, and then dependency-inject that shared DataSource bean into your DAO classes; the JdbcTemplate is created in the setter for the DataSource. This leads to DAOs that look in part like the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The corresponding configuration might look like this.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
An alternative to explicit configuration is to use component-scanning and annotation support for dependency injection. In this case you annotate the class with @Repository (which makes it a candidate for component-scanning) and annotate the DataSource setter method with @Autowired.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The corresponding XML configuration file would look like the following:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If you are using Spring's JdbcDaoSupport class, and your various JDBC-backed DAO classes extend from it, then your sub-class inherits a setDataSource(..) method from the JdbcDaoSupport class. You can choose whether to inherit from this class. The JdbcDaoSupport class is provided as a convenience only.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Regardless of which of the above template initialization styles you choose to use (or not), it is seldom necessary to create a new instance of a JdbcTemplate class each time you want to execute SQL. Once configured, a JdbcTemplate instance is threadsafe. You may want multiple JdbcTemplate instances if your application accesses multiple databases, which requires multiple DataSources, and subsequently multiple differently configured JdbcTemplates.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The NamedParameterJdbcTemplate class adds support for programming JDBC statements using named parameters, as opposed to programming JDBC statements using only classic placeholder ('?') arguments. The NamedParameterJdbcTemplate class wraps a JdbcTemplate, and delegates to the wrapped JdbcTemplate to do much of its work. This section describes only those areas of the NamedParameterJdbcTemplate class that differ from the JdbcTemplate itself; namely, programming JDBC statements using named parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Notice the use of the named parameter notation in the value assigned to the sql variable, and the corresponding value that is plugged into the namedParameters variable (of type MapSqlParameterSource).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Alternatively, you can pass along named parameters and their corresponding values to a NamedParameterJdbcTemplate instance by using the Map-based style.The remaining methods exposed by the NamedParameterJdbcOperations and implemented by the NamedParameterJdbcTemplate class follow a similar pattern and are not covered here.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The following example shows the use of the Map-based style.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"One nice feature related to the NamedParameterJdbcTemplate (and existing in the same Java package) is the SqlParameterSource interface. You have already seen an example of an implementation of this interface in one of the previous code snippet (the MapSqlParameterSource class). An SqlParameterSource is a source of named parameter values to a NamedParameterJdbcTemplate. The MapSqlParameterSource class is a very simple implementation that is simply an adapter around a java.util.Map, where the keys are the parameter names and the values are the parameter values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Another SqlParameterSource implementation is the BeanPropertySqlParameterSource class. This class wraps an arbitrary JavaBean (that is, an instance of a class that adheres to the JavaBean conventions), and uses the properties of the wrapped JavaBean as the source of named parameter values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Remember that the NamedParameterJdbcTemplate class wraps a classic JdbcTemplate template; if you need access to the wrapped JdbcTemplate instance to access functionality only present in the JdbcTemplate class, you can use the getJdbcOperations() method to access the wrapped JdbcTemplate through the JdbcOperations interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
See also the section called “JdbcTemplate best practices” for guidelines on using the NamedParameterJdbcTemplate class in the context of an application.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"SQLExceptionTranslator is an interface to be implemented by classes that can translate between SQLExceptions and Spring's own org.springframework.dao.DataAccessException, which is agnostic in regard to data access strategy. Implementations can be generic (for example, using SQLState codes for JDBC) or proprietary (for example, using Oracle error codes) for greater precision.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
SQLErrorCodeSQLExceptionTranslator is the implementation of SQLExceptionTranslator that is used by default. This implementation uses specific vendor codes. It is more precise than the SQLState implementation. The error code translations are based on codes held in a JavaBean type class called SQLErrorCodes. This class is created and populated by an SQLErrorCodesFactory which as the name suggests is a factory for creating SQLErrorCodes based on the contents of a configuration file named sql-error-codes.xml. This file is populated with vendor codes and based on the DatabaseProductName taken from the DatabaseMetaData. The codes for the actual database you are using are used.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The SQLErrorCodeSQLExceptionTranslator applies matching rules in the following sequence:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The SQLErrorCodesFactory is used by default to define Error codes and custom exception translations. They are looked up in a file named sql-error-codes.xml from the classpath and the matching SQLErrorCodes instance is located based on the database name from the database metadata of the database in use.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Any custom translation implemented by a subclass. Normally the provided concrete SQLErrorCodeSQLExceptionTranslator is used so this rule does not apply. It only applies if you have actually provided a subclass implementation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Any custom implementation of the SQLExceptionTranslator interface that is provided as the customSqlExceptionTranslator property of the SQLErrorCodes class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The list of instances of the CustomSQLErrorCodesTranslation class, provided for the customTranslations property of the SQLErrorCodes class, are searched for a match.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Error code matching is applied.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Use the fallback translator. SQLExceptionSubclassTranslator is the default fallback translator. If this translation is not available then the next fallback translator is the SQLStateSQLExceptionTranslator.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
You can extend SQLErrorCodeSQLExceptionTranslator:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"In this example, the specific error code -12345 is translated and other errors are left to be translated by the default translator implementation. To use this custom translator, it is necessary to pass it to the JdbcTemplate through the method setExceptionTranslator and to use this JdbcTemplate for all of the data access processing where this translator is needed. Here is an example of how this custom translator can be used:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The custom translator is passed a data source in order to look up the error codes in sql-error-codes.xml.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
WebApplicationInitializer is an interface provided by Spring MVC that ensures your code-based configuration is detected and automatically used to initialize any Servlet 3 container. An abstract base class implementation of this interace named AbstractDispatcherServletInitializer makes it even easier to register the DispatcherServlet by simply specifying its servlet mapping. See Code-based Servlet container initialization for more details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The above is only the first step in setting up Spring Web MVC. You now need to configure the various beans used by the Spring Web MVC framework (over and above the DispatcherServlet itself).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As detailed in Section 5.14, “Additional Capabilities of the ApplicationContext”, ApplicationContext instances in Spring can be scoped. In the Web MVC framework, each DispatcherServlet has its own WebApplicationContext, which inherits all the beans already defined in the root WebApplicationContext. These inherited beans can be overridden in the servlet-specific scope, and you can define new scope-specific beans local to a given Servlet instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Upon initialization of a DispatcherServlet, Spring MVC looks for a file named [servlet-name]-servlet.xml in the WEB-INF directory of your web application and creates the beans defined there, overriding the definitions of any beans defined with the same name in the global scope.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Consider the following DispatcherServlet Servlet configuration (in the web.xml file):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"With the above Servlet configuration in place, you will need to have a file called /WEB-INF/golfing-servlet.xml in your application; this file will contain all of your Spring Web MVC-specific components (beans). You can change the exact location of this configuration file through a Servlet initialization parameter (see below for details).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The WebApplicationContext is an extension of the plain ApplicationContext that has some extra features necessary for web applications. It differs from a normal ApplicationContext in that it is capable of resolving themes (see Section 17.9, “Using themes”), and that it knows which Servlet it is associated with (by having a link to the ServletContext). The WebApplicationContext is bound in the ServletContext, and by using static methods on the RequestContextUtils class you can always look up the WebApplicationContext if you need access to it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The Spring DispatcherServlet uses special beans to process requests and render the appropriate views. These beans are part of Spring MVC. You can choose which special beans to use by simply configuring one or more of them in the WebApplicationContext. However, you don't need to do that initially since Spring MVC maintains a list of default beans to use if you don't configure any. More on that in the next section. First see the table below listing the special bean types the DispatcherServlet relies on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
As mentioned in the previous section for each special bean the DispatcherServlet maintains a list of implementations to use by default. This information is kept in the file DispatcherServlet.properties in the package org.springframework.web.servlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
All special beans have some reasonable defaults of their own. Sooner or later though you'll need to customize one or more of the properties these beans provide. For example it's quite common to configure an InternalResourceViewResolver settings its prefix property to the parent location of view files.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Regardless of the details, the important concept to understand here is that once you configure a special bean such as an InternalResourceViewResolver in your WebApplicationContext, you effectively override the list of default implementations that would have been used otherwise for that special bean type. For example if you configure an InternalResourceViewResolver, the default list of ViewResolver implementations is ignored.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In Section 17.15, “Configuring Spring MVC” you'll learn about other options for configuring Spring MVC including MVC Java config and the MVC XML namespace both of which provide a simple starting point and assume little knowledge of how Spring MVC works. Regardless of how you choose to configure your application, the concepts explained in this section are fundamental should be of help to you.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"After you set up a DispatcherServlet, and a request comes in for that specific DispatcherServlet, the DispatcherServlet starts processing the request as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the key DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The locale resolver is bound to the request to enable elements in the process to resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The theme resolver is bound to the request to let elements such as views determine which theme to use. If you do not use themes, you can ignore it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you specify a multipart file resolver, the request is inspected for multiparts; if multiparts are found, the request is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process. See Section 17.10, “Spring's multipart (file upload) support” for further information about multipart handling.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is executed in order to prepare a model or rendering.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If a model is returned, the view is rendered. If no model is returned, (may be due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Handler exception resolvers that are declared in the WebApplicationContext pick up exceptions that are thrown during processing of the request. Using these exception resolvers allows you to define custom behaviors to address exceptions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The Spring DispatcherServlet also supports the return of the last-modification-date, as specified by the Servlet API. The process of determining the last modification date for a specific request is straightforward: the DispatcherServlet looks up an appropriate handler mapping and tests whether the handler that is found implements the LastModified interface. If so, the value of the long getLastModified(request) method of the LastModified interface is returned to the client.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can customize individual DispatcherServlet instances by adding Servlet initialization parameters (init-param elements) to the Servlet declaration in the web.xml file. See the following table for the list of supported parameters.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Controllers provide access to the application behavior that you typically define through a service interface. Controllers interpret user input and transform it into a model that is represented to the user by the view. Spring implements a controller in a very abstract way, which enables you to create a wide variety of controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring 2.5 introduced an annotation-based programming model for MVC controllers that uses annotations such as @RequestMapping, @RequestParam, @ModelAttribute, and so on. This annotation support is available for both Servlet MVC and Portlet MVC. Controllers implemented in this style do not have to extend specific base classes or implement specific interfaces. Furthermore, they do not usually have direct dependencies on Servlet or Portlet APIs, although you can easily configure access to Servlet or Portlet facilities.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Again in keeping with Spring's philosophy, the TransactionException that can be thrown by any of the PlatformTransactionManager interface's methods is unchecked (that is, it extends the java.lang.RuntimeException class). Transaction infrastructure failures are almost invariably fatal. In rare cases where application code can actually recover from a transaction failure, the application developer can still choose to catch and handle TransactionException. The salient point is that developers are not forced to do so.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The getTransaction(..) method returns a TransactionStatus object, depending on a TransactionDefinition parameter. The returned TransactionStatus might represent a new transaction, or can represent an existing transaction if a matching transaction exists in the current call stack. The implication in this latter case is that, as with Java EE transaction contexts, a TransactionStatus is associated with a thread of execution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The TransactionDefinition interface specifies:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Isolation: The degree to which this transaction is isolated from the work of other transactions. For example, can this transaction see uncommitted writes from other transactions?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Propagation: Typically, all code executed within a transaction scope will run in that transaction. However, you have the option of specifying the behavior in the event that a transactional method is executed when a transaction context already exists. For example, code can continue running in the existing transaction (the common case); or the existing transaction can be suspended and a new transaction created. Spring offers all of the transaction propagation options familiar from EJB CMT. To read about the semantics of transaction propagation in Spring, see Section 12.5.7, “Transaction propagation”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Timeout: How long this transaction runs before timing out and being rolled back automatically by the underlying transaction infrastructure.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Read-only status: A read-only transaction can be used when your code reads but does not modify data. Read-only transactions can be a useful optimization in some cases, such as when you are using Hibernate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"These settings reflect standard transactional concepts. If necessary, refer to resources that discuss transaction isolation levels and other core transaction concepts. Understanding these concepts is essential to using the Spring Framework or any transaction management solution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The TransactionStatus interface provides a simple way for transactional code to control transaction execution and query transaction status. The concepts should be familiar, as they are common to all transaction APIs:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Regardless of whether you opt for declarative or programmatic transaction management in Spring, defining the correct PlatformTransactionManager implementation is absolutely essential. You typically define this implementation through dependency injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"PlatformTransactionManager implementations normally require knowledge of the environment in which they work: JDBC, JTA, Hibernate, and so on. The following examples show how you can define a local PlatformTransactionManager implementation. (This example works with plain JDBC.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The related PlatformTransactionManager bean definition will then have a reference to the DataSource definition. It will look like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"If you use JTA in a Java EE container then you use a container DataSource, obtained through JNDI, in conjunction with Spring's JtaTransactionManager. This is what the JTA and JNDI lookup version would look like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The JtaTransactionManager does not need to know about the DataSource, or any other specific resources, because it uses the container's global transaction management infrastructure.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The above definition of the dataSource bean uses the <jndi-lookup/> tag from the jee namespace. For more information on schema-based configuration, see Appendix E, XML Schema-based configuration, and for more information on the <jee/> tags see the section entitled Section E.2.3, “The jee schema”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can also use Hibernate local transactions easily, as shown in the following examples. In this case, you need to define a Hibernate LocalSessionFactoryBean, which your application code will use to obtain Hibernate Session instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The DataSource bean definition will be similar to the local JDBC example shown previously and thus is not shown in the following example.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"If the DataSource, used by any non-JTA transaction manager, is looked up via JNDI and managed by a Java EE container, then it should be non-transactional because the Spring Framework, rather than the Java EE container, will manage the transactions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The txManager bean in this case is of the HibernateTransactionManager type. In the same way as the DataSourceTransactionManager needs a reference to the DataSource, the HibernateTransactionManager needs a reference to the SessionFactory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"If you are using Hibernate and Java EE container-managed JTA transactions, then you should simply use the same JtaTransactionManager as in the previous JTA example for JDBC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"If you use JTA , then your transaction manager definition will look the same regardless of what data access technology you use, be it JDBC, Hibernate JPA or any other supported technology. This is due to the fact that JTA transactions are global transactions, which can enlist any transactional resource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In all these cases, application code does not need to change. You can change how transactions are managed merely by changing configuration, even if that change means moving from local to global transactions or vice versa.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"It should now be clear how you create different transaction managers, and how they are linked to related resources that need to be synchronized to transactions (for example DataSourceTransactionManager to a JDBC DataSource, HibernateTransactionManager to a Hibernate SessionFactory, and so forth). This section describes how the application code, directly or indirectly using a persistence API such as JDBC, Hibernate, or JDO, ensures that these resources are created, reused, and cleaned up properly. The section also discusses how transaction synchronization is triggered (optionally) through the relevant PlatformTransactionManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The preferred approach is to use Spring's highest level template based persistence integration APIs or to use native ORM APIs with transaction- aware factory beans or proxies for managing the native resource factories. These transaction-aware solutions internally handle resource creation and reuse, cleanup, optional transaction synchronization of the resources, and exception mapping. Thus user data access code does not have to address these tasks, but can be focused purely on non-boilerplate persistence logic. Generally, you use the native ORM API or take a template approach for JDBC access by using the JdbcTemplate. These solutions are detailed in subsequent chapters of this reference documentation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Classes such as DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils (for Hibernate), PersistenceManagerFactoryUtils (for JDO), and so on exist at a lower level. When you want the application code to deal directly with the resource types of the native persistence APIs, you use these classes to ensure that proper Spring Framework-managed instances are obtained, transactions are (optionally) synchronized, and exceptions that occur in the process are properly mapped to a consistent API.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"For example, in the case of JDBC, instead of the traditional JDBC approach of calling the getConnection() method on the DataSource, you instead use Spring's org.springframework.jdbc.datasource.DataSourceUtils class as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
org.springframework.test.jdbc.SimpleJdbcTestUtils has been deprecated in favor of JdbcTestUtils which now contains all of the functionality previously available in SimpleJdbcTestUtils.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/migration-3.2.html
"The package org.springframework.jms.support.destination provides various strategies for managing JMS destinations, such as providing a service locator for destinations stored in JNDI.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Finally, the package org.springframework.jms.connection provides an implementation of the ConnectionFactory suitable for use in standalone applications. It also contains an implementation of Spring's PlatformTransactionManager for JMS (the cunningly named JmsTransactionManager). This allows for seamless integration of JMS as a transactional resource into Spring's transaction management mechanisms.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The JmsTemplate class is the central class in the JMS core package. It simplifies the use of JMS since it handles the creation and release of resources when sending or synchronously receiving messages.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Code that uses the JmsTemplate only needs to implement callback interfaces giving them a clearly defined high level contract. The MessageCreator callback interface creates a message given a Session provided by the calling code in JmsTemplate. In order to allow for more complex usage of the JMS API, the callback SessionCallback provides the user with the JMS session and the callback ProducerCallback exposes a Session and MessageProducer pair.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The JMS API exposes two types of send methods, one that takes delivery mode, priority, and time-to-live as Quality of Service (QOS) parameters and one that takes no QOS parameters which uses default values. Since there are many send methods in JmsTemplate, the setting of the QOS parameters have been exposed as bean properties to avoid duplication in the number of send methods. Similarly, the timeout value for synchronous receive calls is set using the property setReceiveTimeout.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Some JMS providers allow the setting of default QOS values administratively through the configuration of the ConnectionFactory. This has the effect that a call to MessageProducer's send method send(Destination destination, Message message) will use different QOS default values than those specified in the JMS specification. In order to provide consistent management of QOS values, the JmsTemplate must therefore be specifically enabled to use its own QOS values by setting the boolean property isExplicitQosEnabled to true.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Instances of the JmsTemplate class are thread-safe once configured. This is important because it means that you can configure a single instance of a JmsTemplate and then safely inject this shared reference into multiple collaborators. To be clear, the JmsTemplate is stateful, in that it maintains a reference to a ConnectionFactory, but this state is not conversational state.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The JmsTemplate requires a reference to a ConnectionFactory. The ConnectionFactory is part of the JMS specification and serves as the entry point for working with JMS. It is used by the client application as a factory to create connections with the JMS provider and encapsulates various configuration parameters, many of which are vendor specific such as SSL configuration options.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces so that they can participate in declarative transaction management and perform pooling of connections and sessions. In order to use this implementation, Java EE containers typically require that you declare a JMS connection factory as a resource-ref inside the EJB or servlet deployment descriptors. To ensure the use of these features with the JmsTemplate inside an EJB, the client application should ensure that it references the managed implementation of the ConnectionFactory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Between the ConnectionFactory and the Send operation there are three intermediate objects that are created and destroyed. To optimise the resource usage and increase performance two implementations of IConnectionFactory are provided.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Spring provides an implementation of the ConnectionFactory interface, SingleConnectionFactory, that will return the same Connection on all createConnection() calls and ignore calls to close(). This is useful for testing and standalone environments so that the same connection can be used for multiple JmsTemplate calls that may span any number of transactions. SingleConnectionFactory takes a reference to a standard ConnectionFactory that would typically come from JNDI.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The CachingConnectionFactory extends the functionality of SingleConnectionFactory and adds the caching of Sessions, MessageProducers, and MessageConsumers. The initial cache size is set to 1, use the property SessionCacheSize to increase the number of cached sessions. Note that the number of actual cached sessions will be more than that number as sessions are cached based on their acknowledgment mode, so there can be up to 4 cached session instances when SessionCacheSize is set to one, one for each AcknowledgementMode. MessageProducers and MessageConsumers are cached within their owning session and also take into account the unique properties of the producers and consumers when caching. MessageProducers are cached based on their destination. MessageConsumers are cached based on a key composed of the destination, selector, noLocal delivery flag, and the durable subscription name (if creating durable consumers).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Destinations, like ConnectionFactories, are JMS administered objects that can be stored and retrieved in JNDI. When configuring a Spring application context you can use the JNDI factory class JndiObjectFactoryBean / <jee:jndi-lookup> to perform dependency injection on your object's references to JMS destinations. However, often this strategy is cumbersome if there are a large number of destinations in the application or if there are advanced destination management features unique to the JMS provider. Examples of such advanced destination management would be the creation of dynamic destinations or support for a hierarchical namespace of destinations. The JmsTemplate delegates the resolution of a destination name to a JMS destination object to an implementation of the interface DestinationResolver. DynamicDestinationResolver is the default implementation used by JmsTemplate and accommodates resolving dynamic destinations. A JndiDestinationResolver is also provided that acts as a service locator for destinations contained in JNDI and optionally falls back to the behavior contained in DynamicDestinationResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Quite often the destinations used in a JMS application are only known at runtime and therefore cannot be administratively created when the application is deployed. This is often because there is shared application logic between interacting system components that create destinations at runtime according to a well-known naming convention. Even though the creation of dynamic destinations is not part of the JMS specification, most vendors have provided this functionality. Dynamic destinations are created with a name defined by the user which differentiates them from temporary destinations and are often not registered in JNDI. The API used to create dynamic destinations varies from provider to provider since the properties associated with the destination are vendor specific. However, a simple implementation choice that is sometimes made by vendors is to disregard the warnings in the JMS specification and to use the TopicSession method createTopic(String topicName) or the QueueSession method createQueue(String queueName) to create a new destination with default destination properties. Depending on the vendor implementation, DynamicDestinationResolver may then also create a physical destination instead of only resolving one.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The boolean property pubSubDomain is used to configure the JmsTemplate with knowledge of what JMS domain is being used. By default the value of this property is false, indicating that the point-to-point domain, Queues, will be used. This property used by JmsTemplate determines the behavior of dynamic destination resolution via implementations of the DestinationResolver interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
You can also configure the JmsTemplate with a default destination via the property defaultDestination. The default destination will be used with send and receive operations that do not refer to a specific destination.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"One of the most common uses of JMS messages in the EJB world is to drive message-driven beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way that does not tie a user to an EJB container. (See Section 23.4.2, “Asynchronous Reception - Message-Driven POJOs” for detailed coverage of Spring's MDP support.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"A message listener container is used to receive messages from a JMS message queue and drive the MessageListener that is injected into it. The listener container is responsible for all threading of message reception and dispatches into the listener for processing. A message listener container is the intermediary between an MDP and a messaging provider, and takes care of registering to receive messages, participating in transactions, resource acquisition and release, exception conversion and suchlike. This allows you as an application developer to write the (possibly complex) business logic associated with receiving a message (and possibly responding to it), and delegates boilerplate JMS infrastructure concerns to the framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"There are two standard JMS message listener containers packaged with Spring, each with its specialised feature set.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"This message listener container is the simpler of the two standard flavors. It creates a fixed number of JMS sessions and consumers at startup, registers the listener using the standard JMS MessageConsumer.setMessageListener() method, and leaves it up the JMS provider to perform listener callbacks. This variant does not allow for dynamic adaption to runtime demands or for participation in externally managed transactions. Compatibility-wise, it stays very close to the spirit of the standalone JMS specification - but is generally not compatible with Java EE's JMS restrictions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Spring features integration classes for remoting support using various technologies. The remoting support eases the development of remote-enabled services, implemented by your usual (Spring) POJOs. Currently, Spring supports the following remoting technologies:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"For more general information about portlet development, please review the JSR-286 Specification.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"For example, the following Java configuration will register a global 'yyyyMMdd' format. This example does not depend on the Joda Time library:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"If you prefer XML based configuration you can use a FormattingConversionServiceFactoryBean. Here is the same example, this time using Joda Time:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Joda Time provides separate distinct types to represent date, time and date-time values. The dateFormatter, timeFormatter and dateTimeFormatter properties of the JodaTimeFormatterRegistrar should be used to configure the different formats for each type. The DateTimeFormatterFactoryBean provides a convenient way to create formatters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"If you are using Spring MVC remember to explicitly configure the conversion service that is used. For Java based @Configuration this means extending the WebMvcConfigurationSupport class and overriding the mvcConversionService() method. For XML you should use the 'conversion-service' attribute of the mvc:annotation-driven element. See Section 7.6.5, “Configuring Formatting in Spring MVC” for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Spring 3 introduces several enhancements to its validation support. First, the JSR-303 Bean Validation API is now fully supported. Second, when used programmatically, Spring's DataBinder can now validate objects as well as bind to them. Third, Spring MVC now has support for declaratively validating @Controller inputs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"JSR-303 standardizes validation constraint declaration and metadata for the Java platform. Using this API, you annotate domain model properties with declarative validation constraints and the runtime enforces them. There are a number of built-in constraints you can take advantage of. You may also define your own custom constraints.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To illustrate, consider a simple PersonForm model with two properties:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
JSR-303 allows you to define declarative validation constraints against such properties:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When an instance of this class is validated by a JSR-303 Validator, these constraints will be enforced.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"For general information on JSR-303, see the Bean Validation Specification. For information on the specific capabilities of the default reference implementation, see the Hibernate Validator documentation. To learn how to setup a JSR-303 implementation as a Spring bean, keep reading.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Spring provides full support for the JSR-303 Bean Validation API. This includes convenient support for bootstrapping a JSR-303 implementation as a Spring bean. This allows for a javax.validation.ValidatorFactory or javax.validation.Validator to be injected wherever validation is needed in your application.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Use the LocalValidatorFactoryBean to configure a default JSR-303 Validator as a Spring bean:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The basic configuration above will trigger JSR-303 to initialize using its default bootstrap mechanism. A JSR-303 provider, such as Hibernate Validator, is expected to be present in the classpath and will be detected automatically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"LocalValidatorFactoryBean implements both javax.validation.ValidatorFactory and javax.validation.Validator, as well as Spring's org.springframework.validation.Validator. You may inject a reference to either of these interfaces into beans that need to invoke validation logic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Inject a reference to javax.validation.Validator if you prefer to work with the JSR-303 API directly:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Inject a reference to org.springframework.validation.Validator if your bean requires the Spring Validation API:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Each JSR-303 validation constraint consists of two parts. First, a @Constraint annotation that declares the constraint and its configurable properties. Second, an implementation of the javax.validation.ConstraintValidator interface that implements the constraint's behavior. To associate a declaration with an implementation, each @Constraint annotation references a corresponding ValidationConstraint implementation class. At runtime, a ConstraintValidatorFactory instantiates the referenced implementation when the constraint annotation is encountered in your domain model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"By default, the LocalValidatorFactoryBean configures a SpringConstraintValidatorFactory that uses Spring to create ConstraintValidator instances. This allows your custom ConstraintValidators to benefit from dependency injection like any other Spring bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Shown below is an example of a custom @Constraint declaration, followed by an associated ConstraintValidator implementation that uses Spring for dependency injection:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"As you can see, a ConstraintValidator implementation may have its dependencies @Autowired like any other Spring bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The default LocalValidatorFactoryBean configuration should prove sufficient for most cases. There are a number of other configuration options for various JSR-303 constructs, from message interpolation to traversal resolution. See the JavaDocs of LocalValidatorFactoryBean for more information on these options.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Since Spring 3, a DataBinder instance can be configured with a Validator. Once configured, the Validator may be invoked by calling binder.validate(). Any validation Errors are automatically added to the binder's BindingResult.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"When working with the DataBinder programmatically, this can be used to invoke validation logic after binding to a target object:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
A DataBinder can also be configured with multiple Validator instances via dataBinder.addValidators and dataBinder.replaceValidators. This is useful when combining globally configured JSR-303 Bean Validation with a Spring Validator configured locally on a DataBinder instance. See the section called “Configuring a Validator for use by Spring MVC”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"Beginning with Spring 3, Spring MVC has the ability to automatically validate @Controller inputs. In previous versions it was up to the developer to manually invoke validation logic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To trigger validation of a @Controller input, simply annotate the input argument as @Valid:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
Spring MVC will validate a @Valid object after binding so-long as an appropriate Validator has been configured.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The @Valid annotation is part of the standard JSR-303 Bean Validation API, and is not a Spring-specific construct.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"The Validator instance invoked when a @Valid method argument is encountered may be configured in two ways. First, you may call binder.setValidator(Validator) within a @Controller's @InitBinder callback. This allows you to configure a Validator instance per @Controller class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The constructor arguments specified in the bean definition will be used as arguments to the constructor of the ExampleBean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Now consider a variant of this example, where instead of using a constructor, Spring is told to call a static factory method to return an instance of the object:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Arguments to the static factory method are supplied via <constructor-arg/> elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the static factory method, although in this example it is. An instance (non-static) factory method would be used in an essentially identical fashion (aside from the use of the factory-bean attribute instead of the class attribute), so details will not be discussed here.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators), or as values defined inline. Spring's XML-based configuration metadata supports sub-element types within its <property/> and <constructor-arg/> elements for this purpose.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The value attribute of the <property/> element specifies a property or constructor argument as a human-readable string representation. As mentioned previously, JavaBeans PropertyEditors are used to convert these string values from a String to the actual type of the property or argument.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example uses the p-namespace for even more succinct XML configuration.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The preceding XML is more succinct; however, typos are discovered at runtime rather than design time, unless you use an IDE such as IntelliJ IDEA or the SpringSource Tool Suite (STS) that support automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also configure a java.util.Properties instance as:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring container converts the text inside the <value/> element into a java.util.Properties instance by using the JavaBeans PropertyEditor mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <value/> element over the value attribute style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The idref element is simply an error-proof way to pass the id (string value - not a reference) of another bean in the container to a <constructor-arg/> or <property/> element.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The above bean definition snippet is exactly equivalent (at runtime) to the following snippet:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The first form is preferable to the second, because using the idref tag allows the container to validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the targetName property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Additionally, if the referenced bean is in the same XML unit, and the bean name is the bean id, you can use the local attribute, which allows the XML parser itself to validate the bean id earlier, at XML document parse time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A common place (at least in versions earlier than Spring 2.0) where the <idref/> element brings value is in the configuration of AOP interceptors in a ProxyFactoryBean bean definition. Using <idref/> elements when you specify the interceptor names prevents you from misspelling an interceptor id.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The ref element is the final element inside a <constructor-arg/> or <property/> definition element. Here you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property will be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may be initialized already by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the id/name of the other object through the bean,local, or parent attributes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Specifying the target bean through the bean attribute of the <ref/> tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the bean attribute may be the same as the id attribute of the target bean, or as one of the values in the name attribute of the target bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Specifying the target bean through the local attribute leverages the ability of the XML parser to validate XML id references within the same file. The value of the local attribute must be the same as the id attribute of the target bean. The XML parser issues an error if no matching element is found in the same file. As such, using the local variant is the best choice (in order to know about errors as early as possible) if the target bean is in the same XML file.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Specifying the target bean through the parent attribute creates a reference to a bean that is in a parent container of the current container. The value of the parent attribute may be the same as either the id attribute of the target bean, or one of the values in the name attribute of the target bean, and the target bean must be in a parent container of the current one. You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A <bean/> element inside the <property/> or <constructor-arg/> elements defines a so-called inner bean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
An inner bean definition does not require a defined id or name; the container ignores these values. It also ignores the scope flag. Inner beans are always anonymous and they are always created with the outer bean. It is not possible to inject inner beans into collaborating beans other than into the enclosing bean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the <list/>, <set/>, <map/>, and <props/> elements, you set the properties and arguments of the Java Collection types List, Set, Map, and Properties, respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The value of a map key or value, or a set value, can also again be any of the following elements:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As of Spring 2.0, the container supports the merging of collections. An application developer can define a parent-style <list/>, <map/>, <set/> or <props/> element, and have child-style <list/>, <map/>, <set/> or <props/> elements inherit and override values from the parent collection. That is, the child collection's values are the result of merging the elements of the parent and child collections, with the child's collection elements overriding values specified in the parent collection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the relevant section before continuing.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If the target class implements one (or more) interfaces, then the type of proxy that is created depends on the configuration of the ProxyFactoryBean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If the proxyTargetClass property of the ProxyFactoryBean has been set to true, then a CGLIB-based proxy will be created. This makes sense, and is in keeping with the principle of least surprise. Even if the proxyInterfaces property of the ProxyFactoryBean has been set to one or more fully qualified interface names, the fact that the proxyTargetClass property is set to true will cause CGLIB-based proxying to be in effect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If the proxyInterfaces property of the ProxyFactoryBean has been set to one or more fully qualified interface names, then a JDK-based proxy will be created. The created proxy will implement all of the interfaces that were specified in the proxyInterfaces property; if the target class happens to implement a whole lot more interfaces than those specified in the proxyInterfaces property, that is all well and good but those additional interfaces will not be implemented by the returned proxy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If the proxyInterfaces property of the ProxyFactoryBean has not been set, but the target class does implement one (or more) interfaces, then the ProxyFactoryBean will auto-detect the fact that the target class does actually implement at least one interface, and a JDK-based proxy will be created. The interfaces that are actually proxied will be all of the interfaces that the target class implements; in effect, this is the same as simply supplying a list of each and every interface that the target class implements to the proxyInterfaces property. However, it is significantly less work, and less prone to typos.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Let's look at a simple example of ProxyFactoryBean in action. This example involves:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"A target bean that will be proxied. This is the ""personTarget"" bean definition in the example below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
An Advisor and an Interceptor used to provide advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An AOP proxy bean definition specifying the target object (the personTarget bean) and the interfaces to proxy, along with the advices to apply.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note that the interceptorNames property takes a list of String: the bean names of the interceptor or advisors in the current factory. Advisors, interceptors, before, after returning and throws advice objects can be used. The ordering of advisors is significant.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"You might be wondering why the list doesn't hold bean references. The reason for this is that if the ProxyFactoryBean's singleton property is set to false, it must be able to return independent proxy instances. If any of the advisors is itself a prototype, an independent instance would need to be returned, so it's necessary to be able to obtain an instance of the prototype from the factory; holding a reference isn't sufficient.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The ""person"" bean definition above can be used in place of a Person implementation, as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Other beans in the same IoC context can express a strongly typed dependency on it, as with an ordinary Java object:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The PersonUser class in this example would expose a property of type Person. As far as it's concerned, the AOP proxy can be used transparently in place of a ""real"" person implementation. However, its class would be a dynamic proxy class. It would be possible to cast it to the Advised interface (discussed below).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"It's possible to conceal the distinction between target and proxy using an anonymous inner bean, as follows. Only the ProxyFactoryBean definition is different; the advice is included only for completeness:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This has the advantage that there's only one object of type Person: useful if we want to prevent users of the application context from obtaining a reference to the un-advised object, or need to avoid any ambiguity with Spring IoC autowiring. There's also arguably an advantage in that the ProxyFactoryBean definition is self-contained. However, there are times when being able to obtain the un-advised target from the factory might actually be an advantage: for example, in certain test scenarios.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"What if you need to proxy a class, rather than one or more interfaces?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Imagine that in our example above, there was no Person interface: we needed to advise a class called Person that didn't implement any business interface. In this case, you can configure Spring to use CGLIB proxying, rather than dynamic proxies. Simply set the proxyTargetClass property on the ProxyFactoryBean above to true. While it's best to program to interfaces, rather than classes, the ability to advise classes that don't implement interfaces can be useful when working with legacy code. (In general, Spring isn't prescriptive. While it makes it easy to apply good practices, it avoids forcing a particular approach.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If you want to, you can force the use of CGLIB in any case, even if you do have interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"CGLIB proxying works by generating a subclass of the target class at runtime. Spring configures this generated subclass to delegate method calls to the original target: the subclass is used to implement the Decorator pattern, weaving in the advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"CGLIB proxying should generally be transparent to users. However, there are some issues to consider:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Final methods can't be advised, as they can't be overridden.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged and included in the spring-core JAR. In other words, CGLIB-based AOP will work ""out of the box"" just as do JDK dynamic proxies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"There's little performance difference between CGLIB proxying and dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster. However, this may change in the future. Performance should not be a decisive consideration in this case.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"By appending an asterisk to an interceptor name, all advisors with bean names matching the part before the asterisk, will be added to the advisor chain. This can come in handy if you need to add a standard set of 'global' advisors:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Especially when defining transactional proxies, you may end up with many similar proxy definitions. The use of parent and child bean definitions, along with inner bean definitions, can result in much cleaner and more concise proxy definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"First a parent, template, bean definition is created for the proxy:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This will never be instantiated itself, so may actually be incomplete. Then each proxy which needs to be created is just a child bean definition, which wraps the target of the proxy as an inner bean definition, since the target will never be used on its own anyway.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"As of Spring 3.1, implement SmartContextLoader instead of this interface in order to provide support for annotated classes and active bean definition profiles.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
SmartContextLoader: Extension of the ContextLoader interface introduced in Spring 3.1.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The SmartContextLoader SPI supersedes the ContextLoader SPI that was introduced in Spring 2.5. Specifically, a SmartContextLoader can choose to process resource locations, annotated classes, or context initializers. Furthermore, a SmartContextLoader can set active bean definition profiles in the context that it loads.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Spring provides the following implementations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
DelegatingSmartContextLoader: one of two default loaders which delegates internally to an AnnotationConfigContextLoader or a GenericXmlContextLoader depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
WebDelegatingSmartContextLoader: one of two default loaders which delegates internally to an AnnotationConfigWebContextLoader or a GenericXmlWebContextLoader depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. A web ContextLoader will only be used if @WebAppConfiguration is present on the test class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AnnotationConfigContextLoader: loads a standard ApplicationContext from annotated classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AnnotationConfigWebContextLoader: loads a WebApplicationContext from annotated classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
GenericXmlContextLoader: loads a standard ApplicationContext from XML resource locations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
GenericXmlWebContextLoader: loads a WebApplicationContext from XML resource locations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
GenericPropertiesContextLoader: loads a standard ApplicationContext from Java Properties files.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following sections explain how to configure the TestContext framework through annotations and provide working examples of how to write unit and integration tests with the framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Each TestContext provides context management and caching support for the test instance it is responsible for. Test instances do not automatically receive access to the configured ApplicationContext. However, if a test class implements the ApplicationContextAware interface, a reference to the ApplicationContext is supplied to the test instance. Note that AbstractJUnit4SpringContextTests and AbstractTestNGSpringContextTests implement ApplicationContextAware and therefore provide access to the ApplicationContext automatically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As an alternative to implementing the ApplicationContextAware interface, you can inject the application context for your test class through the @Autowired annotation on either a field or setter method. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Similarly, if your test is configured to load a WebApplicationContext, you can inject the web application context into your test as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Dependency injection via @Autowired is provided by the DependencyInjectionTestExecutionListener which is configured by default (see the section called “Dependency injection of test fixtures”).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Test classes that use the TestContext framework do not need to extend any particular class or implement a specific interface to configure their application context. Instead, configuration is achieved simply by declaring the @ContextConfiguration annotation at the class level. If your test class does not explicitly declare application context resource locations or annotated classes, the configured ContextLoader determines how to load a context from a default location or default configuration classes. In addition to context resource locations and annotated classes, an application context can also be configured via application context initializers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following sections explain how to configure an ApplicationContext via XML configuration files, annotated classes (typically @Configuration classes), or context initializers using Spring's @ContextConfiguration annotation. Alternatively, you can implement and configure your own custom SmartContextLoader for advanced use cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To load an ApplicationContext for your tests using XML configuration files, annotate your test class with @ContextConfiguration and configure the locations attribute with an array that contains the resource locations of XML configuration metadata. A plain or relative path — for example ""context.xml"" — will be treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath location, for example ""/org/example/config.xml"". A path which represents a resource URL (i.e., a path prefixed with classpath:, file:, http:, etc.) will be used as is.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"@ContextConfiguration supports an alias for the locations attribute through the standard Java value attribute. Thus, if you do not need to declare additional attributes in @ContextConfiguration, you can omit the declaration of the locations attribute name and declare the resource locations by using the shorthand format demonstrated in the following example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you omit both the locations and value attributes from the @ContextConfiguration annotation, the TestContext framework will attempt to detect a default XML resource location. Specifically, GenericXmlContextLoader detects a default location based on the name of the test class. If your class is named com.example.MyTest, GenericXmlContextLoader loads your application context from ""classpath:/com/example/MyTest-context.xml"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To load an ApplicationContext for your tests using annotated classes (see Section 5.12, “Java-based container configuration”), annotate your test class with @ContextConfiguration and configure the classes attribute with an array that contains references to annotated classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you omit the classes attribute from the @ContextConfiguration annotation, the TestContext framework will attempt to detect the presence of default configuration classes. Specifically, AnnotationConfigContextLoader will detect all static inner classes of the test class that meet the requirements for configuration class implementations as specified in the Javadoc for @Configuration. In the following example, the OrderServiceTest class declares a static inner configuration class named Config that will be automatically used to load the ApplicationContext for the test class. Note that the name of the configuration class is arbitrary. In addition, a test class can contain more than one static inner configuration class if desired.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"It may sometimes be desirable to mix XML resources and annotated classes (i.e., typically @Configuration classes) to configure an ApplicationContext for your tests. For example, if you use XML configuration in production, you may decide that you want to use @Configuration classes to configure specific Spring-managed components for your tests, or vice versa. As mentioned in the section called “Spring Testing Annotations” the TestContext framework does not allow you to declare both via @ContextConfiguration, but this does not mean that you cannot use both.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you want to use XML and @Configuration classes to configure your tests, you will have to pick one as the entry point, and that one will have to include or import the other. For example, in XML you can include @Configuration classes via component scanning or define them as normal Spring beans in XML; whereas, in a @Configuration class you can use @ImportResource to import XML configuration files. Note that this behavior is semantically equivalent to how you configure your application in production: in production configuration you will define either a set of XML resource locations or a set of @Configuration classes that your production ApplicationContext will be loaded from, but you still have the freedom to include or import the other type of configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Sometimes you need access in the advice body to the actual value that was returned. You can use the form of @AfterReturning that binds the return value for this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The name used in the returning attribute must correspond to the name of a parameter in the advice method. When a method execution returns, the return value will be passed to the advice method as the corresponding argument value. A returning clause also restricts matching to only those method executions that return a value of the specified type (Object in this case, which will match any return value).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Please note that it is not possible to return a totally different reference when using after-returning advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After throwing advice runs when a matched method execution exits by throwing an exception. It is declared using the @AfterThrowing annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Often you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. Use the throwing attribute to both restrict matching (if desired, use Throwable as the exception type otherwise) and bind the thrown exception to an advice parameter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The name used in the throwing attribute must correspond to the name of a parameter in the advice method. When a method execution exits by throwing an exception, the exception will be passed to the advice method as the corresponding argument value. A throwing clause also restricts matching to only those method executions that throw an exception of the specified type (DataAccessException in this case).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"After (finally) advice runs however a matched method execution exits. It is declared using the @After annotation. After advice must be prepared to handle both normal and exception return conditions. It is typically used for releasing resources, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The final kind of advice is around advice. Around advice runs ""around"" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements (i.e. don't use around advice if simple before advice would do).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Around advice is declared using the @Around annotation. The first parameter of the advice method must be of type ProceedingJoinPoint. Within the body of the advice, calling proceed() on the ProceedingJoinPoint causes the underlying method to execute. The proceed method may also be called passing in an Object[] - the values in the array will be used as the arguments to the method execution when it proceeds.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The behavior of proceed when called with an Object[] is a little different than the behavior of proceed for around advice compiled by the AspectJ compiler. For around advice written using the traditional AspectJ language, the number of arguments passed to proceed must match the number of arguments passed to the around advice (not the number of arguments taken by the underlying join point), and the value passed to proceed in a given argument position supplants the original value at the join point for the entity the value was bound to (Don't worry if this doesn't make sense right now!). The approach taken by Spring is simpler and a better match to its proxy-based, execution only semantics. You only need to be aware of this difference if you are compiling @AspectJ aspects written for Spring and using proceed with arguments with the AspectJ compiler and weaver. There is a way to write such aspects that is 100% compatible across both Spring AOP and AspectJ, and this is discussed in the following section on advice parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The value returned by the around advice will be the return value seen by the caller of the method. A simple caching aspect for example could return a value from a cache if it has one, and invoke proceed() if it does not. Note that proceed may be invoked once, many times, or not at all within the body of the around advice, all of these are quite legal.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring 2.0 offers fully typed advice - meaning that you declare the parameters you need in the advice signature (as we saw for the returning and throwing examples above) rather than work with Object[] arrays all the time. We'll see how to make argument and other contextual values available to the advice body in a moment. First let's take a look at how to write generic advice that can find out about the method the advice is currently advising.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Any advice method may declare as its first parameter, a parameter of type org.aspectj.lang.JoinPoint (please note that around advice is required to declare a first parameter of type ProceedingJoinPoint, which is a subclass of JoinPoint. The JoinPoint interface provides a number of useful methods such as getArgs() (returns the method arguments), getThis() (returns the proxy object), getTarget() (returns the target object), getSignature() (returns a description of the method that is being advised) and toString() (prints a useful description of the method being advised). Please do consult the Javadocs for full details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"We've already seen how to bind the returned value or exception value (using after returning and after throwing advice). To make argument values available to the advice body, you can use the binding form of args. If a parameter name is used in place of a type name in an args expression, then the value of the corresponding argument will be passed as the parameter value when the advice is invoked. An example should make this clearer. Suppose you want to advise the execution of dao operations that take an Account object as the first parameter, and you need access to the account in the advice body. You could write the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The args(account,..) part of the pointcut expression serves two purposes: firstly, it restricts matching to only those method executions where the method takes at least one parameter, and the argument passed to that parameter is an instance of Account; secondly, it makes the actual Account object available to the advice via the account parameter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Another way of writing this is to declare a pointcut that ""provides"" the Account object value when it matches a join point, and then just refer to the named pointcut from the advice. This would look as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The interested reader is once more referred to the AspectJ programming guide for more details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The proxy object (this), target object (target), and annotations (@within, @target, @annotation, @args) can all be bound in a similar fashion. The following example shows how you could match the execution of methods annotated with an @Auditable annotation, and extract the audit code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
First the definition of the @Auditable annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
And then the advice that matches the execution of @Auditable methods:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP can handle generics used in class declarations and method parameters. Suppose you have a generic type like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
You can restrict interception of method types to certain parameter types by simply typing the advice parameter to the parameter type you want to intercept the method for:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"That this works is pretty obvious as we already discussed above. However, it's worth pointing out that this won't work for generic collections. So you cannot define a pointcut like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To make this work we would have to inspect every element of the collection, which is not reasonable as we also cannot decide how to treat null values in general. To achieve something similar to this you have to type the parameter to Collection<?> and manually check the type of the elements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The parameter binding in advice invocations relies on matching names used in pointcut expressions to declared parameter names in (advice and pointcut) method signatures. Parameter names are not available through Java reflection, so Spring AOP uses the following strategies to determine parameter names:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If the parameter names have been specified by the user explicitly, then the specified parameter names are used: both the advice and the pointcut annotations have an optional ""argNames"" attribute which can be used to specify the argument names of the annotated method - these argument names are available at runtime. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If the first parameter is of the JoinPoint, ProceedingJoinPoint, or JoinPoint.StaticPart type, you may leave out the name of the parameter from the value of the ""argNames"" attribute. For example, if you modify the preceding advice to receive the join point object, the ""argNames"" attribute need not include it:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The special treatment given to the first parameter of the JoinPoint, ProceedingJoinPoint, and JoinPoint.StaticPart types is particularly convenient for advice that do not collect any other join point context. In such situations, you may simply omit the ""argNames"" attribute. For example, the following advice need not declare the ""argNames"" attribute:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Using the 'argNames' attribute is a little clumsy, so if the 'argNames' attribute has not been specified, then Spring AOP will look at the debug information for the class and try to determine the parameter names from the local variable table. This information will be present as long as the classes have been compiled with debug information ('-g:vars' at a minimum). The consequences of compiling with this flag on are: (1) your code will be slightly easier to understand (reverse engineer), (2) the class file sizes will be very slightly bigger (typically inconsequential), (3) the optimization to remove unused local variables will not be applied by your compiler. In other words, you should encounter no difficulties building with this flag on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The example below will display a list of errors at the top of the page, followed by field-specific errors next to the fields:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The HTML would look like:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"A key principle of REST is the use of the Uniform Interface. This means that all resources (URLs) can be manipulated using the same four HTTP methods: GET, PUT, POST, and DELETE. For each method, the HTTP specification defines the exact semantics. For instance, a GET should always be a safe operation, meaning that is has no side effects, and a PUT or DELETE should be idempotent, meaning that you can repeat these operations over and over again, but the end result should be the same. While HTTP defines these four methods, HTML only supports two: GET and POST. Fortunately, there are two possible workarounds: you can either use JavaScript to do your PUT or DELETE, or simply do a POST with the 'real' method as an additional parameter (modeled as a hidden input field in an HTML form). This latter trick is what Spring's HiddenHttpMethodFilter does. This filter is a plain Servlet Filter and therefore it can be used in combination with any web framework (not just Spring MVC). Simply add this filter to your web.xml, and a POST with a hidden _method parameter will be converted into the corresponding HTTP method request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This will actually perform an HTTP POST, with the 'real' DELETE method hidden behind a request parameter, to be picked up by the HiddenHttpMethodFilter, as defined in web.xml:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The corresponding @Controller method is shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Starting with Spring 3, the Spring form tag library allows entering dynamic attributes, which means you can enter any HTML5 specific attributes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In Spring 3.1, the form input tag supports entering a type attribute other than 'text'. This is intended to allow rendering new HTML5 specific input types such as 'email', 'date', 'range', and others. Note that entering type='text' is not required since 'text' is the default type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
It is possible to integrate Tiles - just as any other view technology - in web applications using Spring. The following describes in a broad way how to do this.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"NOTE: This section focuses on Spring's support for Tiles 2 (the standalone version of Tiles, requiring Java 5+) in the org.springframework.web.servlet.view.tiles2 package as as well as Tiles 3 in the org.springframework.web.servlet.view.tiles3 package. Spring also continues to support Tiles 1.x (a.k.a. ""Struts Tiles"", as shipped with Struts 1.1+; compatible with Java 1.4) in the original org.springframework.web.servlet.view.tiles package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
To be able to use Tiles you have to have a couple of additional dependencies included in your project. The following is the list of dependencies you need.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"To be able to use Tiles, you have to configure it using files containing definitions (for basic information on definitions and other Tiles concepts, please have a look at http://tiles.apache.org). In Spring this is done using the TilesConfigurer. Have a look at the following piece of example ApplicationContext configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As you can see, there are five files containing definitions, which are all located in the 'WEB-INF/defs' directory. At initialization of the WebApplicationContext, the files will be loaded and the definitions factory will be initialized. After that has been done, the Tiles includes in the definition files can be used as views within your Spring web application. To be able to use the views you have to have a ViewResolver just as with any other view technology used with Spring. Below you can find two possibilities, the UrlBasedViewResolver and the ResourceBundleViewResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The UrlBasedViewResolver instantiates the given viewClass for each view it has to resolve.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The ResourceBundleViewResolver has to be provided with a property file containing viewnames and viewclasses the resolver can use:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As you can see, when using the ResourceBundleViewResolver, you can easily mix different view technologies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Note that the TilesView class for Tiles 2 supports JSTL (the JSP Standard Tag Library) out of the box, whereas there is a separate TilesJstlView subclass in the Tiles 1.x support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"As an advanced feature, Spring also supports two special Tiles 2 PreparerFactory implementations. Check out the Tiles documentation for details on how to use ViewPreparer references in your Tiles definition files.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Specify SimpleSpringPreparerFactory to autowire ViewPreparer instances based on specified preparer classes, applying Spring's container callbacks as well as applying configured Spring BeanPostProcessors. If Spring's context-wide annotation-config has been activated, annotations in ViewPreparer classes will be automatically detected and applied. Note that this expects preparer classes in the Tiles definition files, just like the default PreparerFactory does.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Specify SpringBeanPreparerFactory to operate on specified preparer names instead of classes, obtaining the corresponding Spring bean from the DispatcherServlet's application context. The full bean creation process will be in the control of the Spring application context in this case, allowing for the use of explicit dependency injection configuration, scoped beans etc. Note that you need to define one Spring bean definition per preparer name (as used in your Tiles definitions).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Velocity and FreeMarker are two templating languages that can be used as view technologies within Spring MVC applications. The languages are quite similar and serve similar needs and so are considered together in this section. For semantic and syntactic differences between the two languages, see the FreeMarker web site.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
A suitable configuration is initialized by adding the relevant configurer bean definition to your '*-servlet.xml' as shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
For non web-apps add a VelocityConfigurationFactoryBean or a FreeMarkerConfigurationFactoryBean to your application context definition file.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Your templates need to be stored in the directory specified by the *Configurer bean shown above. This document does not cover details of creating templates for the two languages - please see their relevant websites for information. If you use the view resolvers highlighted, then the logical view names relate to the template file names in similar fashion to InternalResourceViewResolver for JSP's. So if your controller returns a ModelAndView object containing a view name of ""welcome"" then the resolvers will look for the /WEB-INF/freemarker/welcome.ftl or /WEB-INF/velocity/welcome.vm template as appropriate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The basic configurations highlighted above will be suitable for most application requirements, however additional configuration options are available for when unusual or advanced requirements dictate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"More likely you do not already have the JTA PlatformTransactionManager instance, because Spring's JtaTransactionManager can find it itself. Thus you need to configure Hibernate to look up JTA PlatformTransactionManager directly. You do this by configuring an application server- specific TransactionManagerLookup class in the Hibernate configuration, as described in the Hibernate manual.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The remainder of this section describes the sequence of events that occur with and without Hibernate's awareness of the JTA PlatformTransactionManager.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"When Hibernate is not configured with any awareness of the JTA PlatformTransactionManager, the following events occur when a JTA transaction commits:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The JTA transaction commits.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring's JtaTransactionManager is synchronized to the JTA transaction, so it is called back through an afterCompletion callback by the JTA transaction manager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Among other activities, this synchronization can trigger a callback by Spring to Hibernate, through Hibernate's afterTransactionCompletion callback (used to clear the Hibernate cache), followed by an explicit close() call on the Hibernate Session, which causes Hibernate to attempt to close() the JDBC Connection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In some environments, this Connection.close() call then triggers the warning or error, as the application server no longer considers the Connection usable at all, because the transaction has already been committed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"When Hibernate is configured with awareness of the JTA PlatformTransactionManager, the following events occur when a JTA transaction commits:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
the JTA transaction is ready to commit.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring's JtaTransactionManager is synchronized to the JTA transaction, so the transaction is called back through a beforeCompletion callback by the JTA transaction manager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring is aware that Hibernate itself is synchronized to the JTA transaction, and behaves differently than in the previous scenario. Assuming the Hibernate Session needs to be closed at all, Spring will close it now.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The JTA transaction commits.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Hibernate is synchronized to the JTA transaction, so the transaction is called back through an afterCompletion callback by the JTA transaction manager, and can properly clear its cache.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring supports the standard JDO 2.0 and 2.1 APIs as data access strategy, following the same style as the Hibernate support. The corresponding integration classes reside in the org.springframework.orm.jdo package.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Spring provides a LocalPersistenceManagerFactoryBean class that allows you to define a local JDO PersistenceManagerFactory within a Spring application context:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Alternatively, you can set up a PersistenceManagerFactory through direct instantiation of a PersistenceManagerFactory implementation class. A JDO PersistenceManagerFactory implementation class follows the JavaBeans pattern, just like a JDBC DataSource implementation class, which is a natural fit for a configuration that uses Spring. This setup style usually supports a Spring-defined JDBC DataSource, passed into the connectionFactory property. For example, for the open source JDO implementation DataNucleus (formerly JPOX) (http://www.datanucleus.org/), this is the XML configuration of the PersistenceManagerFactory implementation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You can also set up JDO PersistenceManagerFactory in the JNDI environment of a Java EE application server, usually through the JCA connector provided by the particular JDO implementation. Spring's standard JndiObjectFactoryBean or <jee:jndi-lookup> can be used to retrieve and expose such a PersistenceManagerFactory. However, outside an EJB context, no real benefit exists in holding the PersistenceManagerFactory in JNDI: only choose such a setup for a good reason. See Section 15.3.6, “Comparing container-managed and locally defined resources” for a discussion; the arguments there apply to JDO as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"DAOs can also be written directly against plain JDO API, without any Spring dependencies, by using an injected PersistenceManagerFactory. The following is an example of a corresponding DAO implementation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Because the above DAO follows the dependency injection pattern, it fits nicely into a Spring container, just as it would if coded against Spring's JdoTemplate:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The main problem with such DAOs is that they always get a new PersistenceManager from the factory. To access a Spring-managed transactional PersistenceManager, define a TransactionAwarePersistenceManagerFactoryProxy (as included in Spring) in front of your target PersistenceManagerFactory, then passing a reference to that proxy into your DAOs as in the following example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Your data access code will receive a transactional PersistenceManager (if any) from the PersistenceManagerFactory.getPersistenceManager() method that it calls. The latter method call goes through the proxy, which first checks for a current transactional PersistenceManager before getting a new one from the factory. Any close() calls on the PersistenceManager are ignored in case of a transactional PersistenceManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"If your data access code always runs within an active transaction (or at least within active transaction synchronization), it is safe to omit the PersistenceManager.close() call and thus the entire finally block, which you might do to keep your DAO implementations concise:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"With such DAOs that rely on active transactions, it is recommended that you enforce active transactions through turning off TransactionAwarePersistenceManagerFactoryProxy's allowCreate flag:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The main advantage of this DAO style is that it depends on JDO API only; no import of any Spring class is required. This is of course appealing from a non-invasiveness perspective, and might feel more natural to JDO developers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"However, the DAO throws plain JDOException (which is unchecked, so does not have to be declared or caught), which means that callers can only treat exceptions as fatal, unless you want to depend on JDO's own exception structure. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly JDO-based and/or do not need any special exception treatment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In summary, you can DAOs based on the plain JDO API, and they can still participate in Spring-managed transactions. This strategy might appeal to you if you are already familiar with JDO. However, such DAOs throw plain JDOException, and you would have to convert explicitly to Spring's DataAccessException (if desired).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You are strongly encouraged to read Section 12.5, “Declarative transaction management” if you have not done so, to get a more detailed coverage of Spring's declarative transaction support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Executing an SQL statement requires very little code. You need a DataSource and a JdbcTemplate, including the convenience methods that are provided with the JdbcTemplate. The following example shows what you need to include for a minimal but fully functional class that creates a new table:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Some query methods return a single value. To retrieve a count or a specific value from one row, use queryForObject(..). The latter converts the returned JDBC Type to the Java class that is passed in as an argument. If the type conversion is invalid, then an InvalidDataAccessApiUsageException is thrown. Here is an example that contains two query methods, one for an int and one that queries for a String.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"In addition to the single result query methods, several methods return a list with an entry for each row that the query returned. The most generic method is queryForList(..) which returns a List where each entry is a Map with each entry in the map representing the column value for that row. If you add a method to the above example to retrieve a list of all the rows, it would look like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The list returned would look something like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The following example shows a column updated for a certain primary key. In this example, an SQL statement has placeholders for row parameters. The parameter values can be passed in as varargs or alternatively as an array of objects. Thus primitives should be wrapped in the primitive wrapper classes explicitly or using auto-boxing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"An update() convenience method supports the retrieval of primary keys generated by the database. This support is part of the JDBC 3.0 standard; see Chapter 13.6 of the specification for details. The method takes a PreparedStatementCreator as its first argument, and this is the way the required insert statement is specified. The other argument is a KeyHolder, which contains the generated key on successful return from the update. There is not a standard single way to create an appropriate PreparedStatement (which explains why the method signature is the way it is). The following example works on Oracle but may not work on other platforms:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Spring obtains a connection to the database through a DataSource. A DataSource is part of the JDBC specification and is a generalized connection factory. It allows a container or a framework to hide connection pooling and transaction management issues from the application code. As a developer, you need not know details about how to connect to the database; that is the responsibility of the administrator that sets up the datasource. You most likely fill both roles as you develop and test code, but you do not necessarily have to know how the production data source is configured.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"When using Spring's JDBC layer, you obtain a data source from JNDI or you configure your own with a connection pool implementation provided by a third party. Popular implementations are Apache Jakarta Commons DBCP and C3P0. Implementations in the Spring distribution are meant only for testing purposes and do not provide pooling.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This section uses Spring's DriverManagerDataSource implementation, and several additional implementations are covered later.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Only use the DriverManagerDataSource class should only be used for testing purposes since it does not provide pooling and will perform poorly when multiple requests for a connection are made.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You obtain a connection with DriverManagerDataSource as you typically obtain a JDBC connection. Specify the fully qualified classname of the JDBC driver so that the DriverManager can load the driver class. Next, provide a URL that varies between JDBC drivers. (Consult the documentation for your driver for the correct value.) Then provide a username and a password to connect to the database. Here is an example of how to configure a DriverManagerDataSource in Java code:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Here is the corresponding XML configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The following examples show the basic connectivity and configuration for DBCP and C3P0. To learn about more options that help control the pooling features, see the product documentation for the respective connection pooling implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
DBCP configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
C3P0 configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The DataSourceUtils class is a convenient and powerful helper class that provides static methods to obtain connections from JNDI and close connections if necessary. It supports thread-bound connections with, for example, DataSourceTransactionManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The SmartDataSource interface should be implemented by classes that can provide a connection to a relational database. It extends the DataSource interface to allow classes using it to query whether the connection should be closed after a given operation. This usage is efficient when you know that you will reuse a connection.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
AbstractDataSource is an abstract base class for Spring's DataSource implementations that implements code that is common to all DataSource implementations. You extend the AbstractDataSource class if you are writing your own DataSource implementation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SingleConnectionDataSource class is an implementation of the SmartDataSource interface that wraps a single Connection that is not closed after each use. Obviously, this is not multi-threading capable.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If any client code calls close in the assumption of a pooled connection, as when using persistence tools, set the suppressClose property to true. This setting returns a close-suppressing proxy wrapping the physical connection. Be aware that you will not be able to cast this to a native Oracle Connection or the like anymore.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This is primarily a test class. For example, it enables easy testing of code outside an application server, in conjunction with a simple JNDI environment. In contrast to DriverManagerDataSource, it reuses the same connection all the time, avoiding excessive creation of physical connections.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The DriverManagerDataSource class is an implementation of the standard DataSource interface that configures a plain JDBC driver through bean properties, and returns a new Connection every time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This implementation is useful for test and stand-alone environments outside of a Java EE container, either as a DataSource bean in a Spring IoC container, or in conjunction with a simple JNDI environment. Pool-assuming Connection.close() calls will simply close the connection, so any DataSource-aware persistence code should work. However, using JavaBean-style connection pools such as commons-dbcp is so easy, even in a test environment, that it is almost always preferable to use such a connection pool over DriverManagerDataSource.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Available in the samples repository, a number of web applications leverage the annotation support described in this section including MvcShowcase, MvcAjax, MvcBasic, PetClinic, PetCare, and others.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As you can see, the @Controller and @RequestMapping annotations allow flexible method names and signatures. In this particular example the method accepts a Model and returns a view name as a String, but various other method parameters and return values can be used as explained later in this section. @Controller and @RequestMapping and a number of other annotations form the basis for the Spring MVC implementation. This section documents these annotations and how they are most commonly used in a Servlet environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The @Controller annotation indicates that a particular class serves the role of a controller. Spring does not require you to extend any controller base class or reference the Servlet API. However, you can still reference Servlet-specific features if you need to.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The @Controller annotation acts as a stereotype for the annotated class, indicating its role. The dispatcher scans such annotated classes for mapped methods and detects @RequestMapping annotations (see the next section).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can define annotated controller beans explicitly, using a standard Spring bean definition in the dispatcher's context. However, the @Controller stereotype also allows for autodetection, aligned with Spring general support for detecting component classes in the classpath and auto-registering bean definitions for them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To enable autodetection of such annotated controllers, you add component scanning to your configuration. Use the spring-context schema as shown in the following XML snippet:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You use the @RequestMapping annotation to map URLs such as /appointments onto an entire class or a particular handler method. Typically the class-level annotation maps a specific request path (or path pattern) onto a form controller, with additional method-level annotations narrowing the primary mapping for a specific HTTP method request method (""GET"", ""POST"", etc.) or an HTTP request parameter condition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following example from the Petcare sample shows a controller in a Spring MVC application that uses this annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the example, the @RequestMapping is used in a number of places. The first usage is on the type (class) level, which indicates that all handling methods on this controller are relative to the /appointments path. The get() method has a further @RequestMapping refinement: it only accepts GET requests, meaning that an HTTP GET for /appointments invokes this method. The post() has a similar refinement, and the getNewForm() combines the definition of HTTP method and path into one, so that GET requests for appointments/new are handled by that method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The getForDay() method shows another usage of @RequestMapping: URI templates. (See the next section ).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A @RequestMapping on the class level is not required. Without it, all paths are simply absolute, and not relative. The following example from the PetClinic sample application shows a multi-action controller using @RequestMapping:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A common pitfall when working with annotated controller classes happens when applying functionality that requires creating a proxy for the controller object (e.g. @Transactional methods). Usually you will introduce an interface for the controller in order to use JDK dynamic proxies. To make this work you must move the @RequestMapping annotations, as well as any other type and method-level annotations (e.g. @ModelAttribute, @InitBinder) to the interface as well as the mapping mechanism can only ""see"" the interface exposed by the proxy. Alternatively, you could activate proxy-target-class=""true"" in the configuration for the functionality applied to the controller (in our transaction scenario in <tx:annotation-driven />). Doing so indicates that CGLIB-based subclass proxies should be used instead of interface-based JDK proxies. For more information on various proxying mechanisms see Section 9.6, “Proxying mechanisms”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note however that method argument annotations, e.g. @RequestParam, must be present in the method signatures of the controller class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring 3.1 introduced a new set of support classes for @RequestMapping methods called RequestMappingHandlerMapping and RequestMappingHandlerAdapter respectively. They are recommended for use and even required to take advantage of new features in Spring MVC 3.1 and going forward. The new support classes are enabled by default by the MVC namespace and the MVC Java config but must be configured explicitly if using neither. This section describes a few important differences between the old and the new support classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Prior to Spring 3.1, type and method-level request mappings were examined in two separate stages -- a controller was selected first by the DefaultAnnotationHandlerMapping and the actual method to invoke was narrowed down second by the AnnotationMethodHandlerAdapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"With the new support classes in Spring 3.1, the RequestMappingHandlerMapping is the only place where a decision is made about which method should process the request. Think of controller methods as a collection of unique endpoints with mappings for each method derived from type and method-level @RequestMapping information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This enables some new possibilities. For once a HandlerInterceptor or a HandlerExceptionResolver can now expect the Object-based handler to be a HandlerMethod, which allows them to examine the exact method, its parameters and associated annotations. The processing for a URL no longer needs to be split across different controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
There are also several things no longer possible:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Select a controller first with a SimpleUrlHandlerMapping or BeanNameUrlHandlerMapping and then narrow the method based on @RequestMapping annotations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Rely on method names as a fall-back mechanism to disambiguate between two @RequestMapping methods that don't have an explicit path mapping URL path but otherwise match equally, e.g. by HTTP method. In the new support classes @RequestMapping methods have to be mapped uniquely.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Have a single default method (without an explicit path mapping) with which requests are processed if no other controller method matches more concretely. In the new support classes if a matching method is not found a 404 error is raised.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The above features are still supported with the existing support classes. However to take advantage of new Spring MVC 3.1 features you'll need to use the new support classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
URI templates can be used for convenient access to selected parts of a URL in a @RequestMapping method.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A URI Template is a URI-like string, containing one or more variable names. When you substitute values for these variables, the template becomes a URI. The proposed RFC for URI Templates defines how a URI is parameterized. For example, the URI Template http://www.example.com/users/{userId} contains the variable userId. Assigning the value fred to the variable yields http://www.example.com/users/fred.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If an existing transaction already has a connection synchronized (linked) to it, that instance is returned. Otherwise, the method call triggers the creation of a new connection, which is (optionally) synchronized to any existing transaction, and made available for subsequent reuse in that same transaction. As mentioned, any SQLException is wrapped in a Spring Framework CannotGetJdbcConnectionException, one of the Spring Framework's hierarchy of unchecked DataAccessExceptions. This approach gives you more information than can be obtained easily from the SQLException, and ensures portability across databases, even across different persistence technologies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"This approach also works without Spring transaction management (transaction synchronization is optional), so you can use it whether or not you are using Spring for transaction management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Of course, once you have used Spring's JDBC support, JPA support or Hibernate support, you will generally prefer not to use DataSourceUtils or the other helper classes, because you will be much happier working through the Spring abstraction than directly with the relevant APIs. For example, if you use the Spring JdbcTemplate or jdbc.object package to simplify your use of JDBC, correct connection retrieval occurs behind the scenes and you won't need to write any special code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"At the very lowest level exists the TransactionAwareDataSourceProxy class. This is a proxy for a target DataSource, which wraps the target DataSource to add awareness of Spring-managed transactions. In this respect, it is similar to a transactional JNDI DataSource as provided by a Java EE server.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"It should almost never be necessary or desirable to use this class, except when existing code must be called and passed a standard JDBC DataSource interface implementation. In that case, it is possible that this code is usable, but participating in Spring managed transactions. It is preferable to write your new code by using the higher level abstractions mentioned above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Most Spring Framework users choose declarative transaction management. This option has the least impact on application code, and hence is most consistent with the ideals of a non-invasive lightweight container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring Framework's declarative transaction management is made possible with Spring aspect-oriented programming (AOP), although, as the transactional aspects code comes with the Spring Framework distribution and may be used in a boilerplate fashion, AOP concepts do not generally have to be understood to make effective use of this code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The Spring Framework's declarative transaction management is similar to EJB CMT in that you can specify transaction behavior (or lack of it) down to individual method level. It is possible to make a setRollbackOnly() call within a transaction context if necessary. The differences between the two types of transaction management are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Unlike EJB CMT, which is tied to JTA, the Spring Framework's declarative transaction management works in any environment. It can work with JTA transactions or local transactions using JDBC, JPA, Hibernate or JDO by simply adjusting the configuration files.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can apply the Spring Framework declarative transaction management to any class, not merely special classes such as EJBs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring Framework offers declarative rollback rules, a feature with no EJB equivalent. Both programmatic and declarative support for rollback rules is provided.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring Framework enables you to customize transactional behavior, by using AOP. For example, you can insert custom behavior in the case of transaction rollback. You can also add arbitrary advice, along with the transactional advice. With EJB CMT, you cannot influence the container's transaction management except with setRollbackOnly().",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring Framework does not support propagation of transaction contexts across remote calls, as do high-end application servers. If you need this feature, we recommend that you use EJB. However, consider carefully before using such a feature, because normally, one does not want transactions to span remote calls.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Where is TransactionProxyFactoryBean?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Declarative transaction configuration in versions of Spring 2.0 and above differs considerably from previous versions of Spring. The main difference is that there is no longer any need to configure TransactionProxyFactoryBean beans.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The pre-Spring 2.0 configuration style is still 100% valid configuration; think of the new <tx:tags/> as simply defining TransactionProxyFactoryBean beans on your behalf.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The concept of rollback rules is important: they enable you to specify which exceptions (and throwables) should cause automatic rollback. You specify this declaratively, in configuration, not in Java code. So, although you can still call setRollbackOnly()on the TransactionStatus object to roll back the current transaction back, most often you can specify a rule that MyApplicationException must always result in rollback. The significant advantage to this option is that business objects do not depend on the transaction infrastructure. For example, they typically do not need to import Spring transaction APIs or other Spring APIs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Although EJB container default behavior automatically rolls back the transaction on a system exception (usually a runtime exception), EJB CMT does not roll back the transaction automatically on an application exception (that is, a checked exception other than java.rmi.RemoteException). While the Spring default behavior for declarative transaction management follows EJB convention (roll back is automatic only on unchecked exceptions), it is often useful to customize this behavior.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"It is not sufficient to tell you simply to annotate your classes with the @Transactional annotation, add @EnableTransactionManagement to your configuration, and then expect you to understand how it all works. This section explains the inner workings of the Spring Framework's declarative transaction infrastructure in the event of transaction-related issues.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The most important concepts to grasp with regard to the Spring Framework's declarative transaction support are that this support is enabled via AOP proxies, and that the transactional advice is driven by metadata (currently XML- or annotation-based). The combination of AOP with transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with an appropriate PlatformTransactionManager implementation to drive transactions around method invocations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Spring AOP is covered in Chapter 9, Aspect Oriented Programming with Spring.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Conceptually, calling a method on a transactional proxy looks like this...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Consider the following interface, and its attendant implementation. This example uses Foo and Bar classes as placeholders so that you can concentrate on the transaction usage without focusing on a particular domain model. For the purposes of this example, the fact that the DefaultFooService class throws UnsupportedOperationException instances in the body of each implemented method is good; it allows you to see transactions created and then rolled back in response to the UnsupportedOperationException instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Assume that the first two methods of the FooService interface, getFoo(String) and getFoo(String, String), must execute in the context of a transaction with read-only semantics, and that the other methods,insertFoo(Foo) and updateFoo(Foo), must execute in the context of a transaction with read-write semantics. The following configuration is explained in detail in the next few paragraphs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Examine the preceding configuration. You want to make a service object, the fooService bean, transactional. The transaction semantics to apply are encapsulated in the <tx:advice/> definition. The <tx:advice/> definition reads as “... all methods on starting with 'get' are to execute in the context of a read-only transaction, and all other methods are to execute with the default transaction semantics”. The transaction-manager attribute of the <tx:advice/> tag is set to the name of the PlatformTransactionManager bean that is going to drive the transactions, in this case, the txManager bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can omit the transaction-manager attribute in the transactional advice (<tx:advice/>) if the bean name of the PlatformTransactionManager that you want to wire in has the name transactionManager. If the PlatformTransactionManager bean that you want to wire in has any other name, then you must use the transaction-manager attribute explicitly, as in the preceding example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"This message listener container is the one used in most cases. In contrast to SimpleMessageListenerContainer, this container variant does allow for dynamic adaption to runtime demands and is able to participate in externally managed transactions. Each received message is registered with an XA transaction when configured with a JtaTransactionManager; so processing may take advantage of XA transaction semantics. This listener container strikes a good balance between low requirements on the JMS provider, advanced functionality such as transaction participation, and compatibility with Java EE environments.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Spring provides a JmsTransactionManager that manages transactions for a single JMS ConnectionFactory. This allows JMS applications to leverage the managed transaction features of Spring as described in Chapter 12, Transaction Management. The JmsTransactionManager performs local resource transactions, binding a JMS Connection/Session pair from the specified ConnectionFactory to the thread. JmsTemplate automatically detects such transactional resources and operates on them accordingly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In a Java EE environment, the ConnectionFactory will pool Connections and Sessions, so those resources are efficiently reused across transactions. In a standalone environment, using Spring's SingleConnectionFactory will result in a shared JMS Connection, with each transaction having its own independent Session. Alternatively, consider the use of a provider-specific pooling adapter such as ActiveMQ's PooledConnectionFactory class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
JmsTemplate can also be used with the JtaTransactionManager and an XA-capable JMS ConnectionFactory for performing distributed transactions. Note that this requires the use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory! (Check your Java EE server's / JMS provider's documentation.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Reusing code across a managed and unmanaged transactional environment can be confusing when using the JMS API to create a Session from a Connection. This is because the JMS API has only one factory method to create a Session and it requires values for the transaction and acknowledgement modes. In a managed environment, setting these values is the responsibility of the environment's transactional infrastructure, so these values are ignored by the vendor's wrapper to the JMS Connection. When using the JmsTemplate in an unmanaged environment you can specify these values through the use of the properties sessionTransacted and sessionAcknowledgeMode. When using a PlatformTransactionManager with JmsTemplate, the template will always be given a transactional JMS Session.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The JmsTemplate contains many convenience methods to send a message. There are send methods that specify the destination using a javax.jms.Destination object and those that specify the destination using a string for use in a JNDI lookup. The send method that takes no destination argument uses the default destination. Here is an example that sends a message to a queue using the 1.0.2 implementation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"This example uses the MessageCreator callback to create a text message from the supplied Session object. The JmsTemplate is constructed by passing a reference to a ConnectionFactory. As an alternative, a zero argument constructor and connectionFactory is provided and can be used for constructing the instance in JavaBean style (using a BeanFactory or plain Java code). Alternatively, consider deriving from Spring's JmsGatewaySupport convenience base class, which provides pre-built bean properties for JMS configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The method send(String destinationName, MessageCreator creator) lets you send a message using the string name of the destination. If these names are registered in JNDI, you should set the destinationResolver property of the template to an instance of JndiDestinationResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"If you created the JmsTemplate and specified a default destination, the send(MessageCreator c) sends a message to that destination.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In order to facilitate the sending of domain model objects, the JmsTemplate has various send methods that take a Java object as an argument for a message's data content. The overloaded methods convertAndSend() and receiveAndConvert() in JmsTemplate delegate the conversion process to an instance of the MessageConverter interface. This interface defines a simple contract to convert between Java objects and JMS messages. The default implementation SimpleMessageConverter supports conversion between String and TextMessage, byte[] and BytesMesssage, and java.util.Map and MapMessage. By using the converter, you and your application code can focus on the business object that is being sent or received via JMS and not be concerned with the details of how it is represented as a JMS message.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The sandbox currently includes a MapMessageConverter which uses reflection to convert between a JavaBean and a MapMessage. Other popular implementation choices you might implement yourself are Converters that use an existing XML marshalling package, such as JAXB, Castor, XMLBeans, or XStream, to create a TextMessage representing the object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"To accommodate the setting of a message's properties, headers, and body that can not be generically encapsulated inside a converter class, the MessagePostProcessor interface gives you access to the message after it has been converted, but before it is sent. The example below demonstrates how to modify a message header and a property after a java.util.Map is converted to a message.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
This results in a message of the form:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"While the send operations cover many common usage scenarios, there are cases when you want to perform multiple operations on a JMS Session or MessageProducer. The SessionCallback and ProducerCallback expose the JMS Session and Session / MessageProducer pair respectively. The execute() methods on JmsTemplate execute these callback methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"While JMS is typically associated with asynchronous processing, it is possible to consume messages synchronously. The overloaded receive(..) methods provide this functionality. During a synchronous receive, the calling thread blocks until a message becomes available. This can be a dangerous operation since the calling thread can potentially be blocked indefinitely. The property receiveTimeout specifies how long the receiver should wait before giving up waiting for a message.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see also below for the discussion of the MessageListenerAdapter class) on an MDP is that it must implement the javax.jms.MessageListener interface. Please also be aware that in the case where your POJO will be receiving messages on multiple threads, it is important to ensure that your implementation is thread-safe.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Below is a simple implementation of an MDP:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Once you've implemented your MessageListener, it's time to create a message listener container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Find below an example of how to define and configure one of the message listener containers that ships with Spring (in this case the DefaultMessageListenerContainer).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Please refer to the Spring Javadoc of the various message listener containers for a full description of the features supported by each implementation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The SessionAwareMessageListener interface is a Spring-specific interface that provides a similar contract to the JMS MessageListener interface, but also provides the message handling method with access to the JMS Session from which the Message was received.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"You can choose to have your MDPs implement this interface (in preference to the standard JMS MessageListener interface) if you want your MDPs to be able to respond to any received messages (using the Session supplied in the onMessage(Message, Session) method). All of the message listener container implementations that ship with Spring have support for MDPs that implement either the MessageListener or SessionAwareMessageListener interface. Classes that implement the SessionAwareMessageListener come with the caveat that they are then tied to Spring through the interface. The choice of whether or not to use it is left entirely up to you as an application developer or architect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Please note that the 'onMessage(..)' method of the SessionAwareMessageListener interface throws JMSException. In contrast to the standard JMS MessageListener interface, when using the SessionAwareMessageListener interface, it is the responsibility of the client code to handle any exceptions thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The MessageListenerAdapter class is the final component in Spring's asynchronous messaging support: in a nutshell, it allows you to expose almost any class as a MDP (there are of course some constraints).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Remote Method Invocation (RMI). Through the use of the RmiProxyFactoryBean and the RmiServiceExporter Spring supports both traditional RMI (with java.rmi.Remote interfaces and java.rmi.RemoteException) and transparent remoting via RMI invokers (with any Java interface).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring's HTTP invoker. Spring provides a special remoting strategy which allows for Java serialization via HTTP, supporting any Java interface (just like the RMI invoker). The corresponding support classes are HttpInvokerProxyFactoryBean and HttpInvokerServiceExporter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Hessian. By using Spring's HessianProxyFactoryBean and the HessianServiceExporter you can transparently expose your services using the lightweight binary HTTP-based protocol provided by Caucho.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Burlap. Burlap is Caucho's XML-based alternative to Hessian. Spring provides support classes such as BurlapProxyFactoryBean and BurlapServiceExporter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
JAX-RPC. Spring provides remoting support for web services via JAX-RPC (J2EE 1.4's web service API).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"JAX-WS. Spring provides remoting support for web services via JAX-WS (the successor of JAX-RPC, as introduced in Java EE 5 and Java 6).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
JMS. Remoting using JMS as the underlying protocol is supported via the JmsInvokerServiceExporter and JmsInvokerProxyFactoryBean classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"While discussing the remoting capabilities of Spring, we'll use the following domain model and corresponding services:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
We will start exposing the service to a remote client by using RMI and talk a bit about the drawbacks of using RMI. We'll then continue to show an example using Hessian as the protocol.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Using Spring's support for RMI, you can transparently expose your services through the RMI infrastructure. After having this set up, you basically have a configuration similar to remote EJBs, except for the fact that there is no standard support for security context propagation or remote transaction propagation. Spring does provide hooks for such additional invocation context when using the RMI invoker, so you can for example plug in security frameworks or custom security credentials here.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Using the RmiServiceExporter, we can expose the interface of our AccountService object as RMI object. The interface can be accessed by using RmiProxyFactoryBean, or via plain RMI in case of a traditional RMI service. The RmiServiceExporter explicitly supports the exposing of any non-RMI services via RMI invokers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Of course, we first have to set up our service in the Spring container:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Next we'll have to expose our service using the RmiServiceExporter:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"As you can see, we're overriding the port for the RMI registry. Often, your application server also maintains an RMI registry and it is wise to not interfere with that one. Furthermore, the service name is used to bind the service under. So right now, the service will be bound at 'rmi://HOST:1199/AccountService'. We'll use the URL later on to link in the service at the client side.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The servicePort property has been omitted (it defaults to 0). This means that an anonymous port will be used to communicate with the service.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Our client is a simple object using the AccountService to manage accounts:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"To link in the service on the client, we'll create a separate Spring container, containing the simple object and the service linking configuration bits:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
That's all we need to do to support the remote account service on the client. Spring will transparently create an invoker and remotely enable the account service through the RmiServiceExporter. At the client we're linking it in using the RmiProxyFactoryBean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Hessian offers a binary HTTP-based remoting protocol. It is developed by Caucho and more information about Hessian itself can be found at http://www.caucho.com.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Hessian communicates via HTTP and does so using a custom servlet. Using Spring's DispatcherServlet principles, as known from Spring Web MVC usage, you can easily wire up such a servlet exposing your services. First we'll have to create a new servlet in your application (this is an excerpt from 'web.xml'):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"You're probably familiar with Spring's DispatcherServlet principles and if so, you know that now you'll have to create a Spring container configuration resource named 'remoting-servlet.xml' (after the name of your servlet) in the 'WEB-INF' directory. The application context will be used in the next section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Alternatively, consider the use of Spring's simpler HttpRequestHandlerServlet. This allows you to embed the remote exporter definitions in your root application context (by default in 'WEB-INF/applicationContext.xml'), with individual servlet definitions pointing to specific exporter beans. Each servlet name needs to match the bean name of its target exporter in this case.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In the newly created application context called remoting-servlet.xml, we'll create a HessianServiceExporter exporting your services:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Now we're ready to link in the service at the client. No explicit handler mapping is specified, mapping request URLs onto services, so BeanNameUrlHandlerMapping will be used: Hence, the service will be exported at the URL indicated through its bean name within the containing DispatcherServlet's mapping (as defined above): 'http://HOST:8080/remoting/AccountService'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Alternatively, create a HessianServiceExporter in your root application context (e.g. in 'WEB-INF/applicationContext.xml'):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In the latter case, define a corresponding servlet for this exporter in 'web.xml', with the same end result: The exporter getting mapped to the request path /remoting/AccountService. Note that the servlet name needs to match the bean name of the target exporter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Using the HessianProxyFactoryBean we can link in the service at the client. The same principles apply as with the RMI example. We'll create a separate bean factory or application context and mention the following beans where the SimpleObject is using the AccountService to manage accounts:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"We won't discuss Burlap, the XML-based equivalent of Hessian, in detail here, since it is configured and set up in exactly the same way as the Hessian variant explained above. Just replace the word Hessian with Burlap and you're all set to go.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In addition to supporting conventional (servlet-based) Web development, Spring also supports JSR-286 Portlet development. As much as possible, the Portlet MVC framework is a mirror image of the Web MVC framework, and also uses the same underlying view abstractions and integration technology. So, be sure to review the chapters entitled Chapter 17, Web MVC framework and Chapter 18, View technologies before continuing with this chapter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Bear in mind that while the concepts of Spring MVC are the same in Spring Portlet MVC, there are some notable differences created by the unique workflow of JSR-286 portlets.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The main way in which portlet workflow differs from servlet workflow is that the request to the portlet can have two distinct phases: the action phase and the render phase. The action phase is executed only once and is where any 'backend' changes or actions occur, such as making changes in a database. The render phase then produces what is displayed to the user each time the display is refreshed. The critical point here is that for a single overall request, the action phase is executed only once, but the render phase may be executed multiple times. This provides (and requires) a clean separation between the activities that modify the persistent state of your system and the activities that generate what is displayed to the user.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Spring Web Flow (SWF) aims to be the best solution for the management of web application page flow.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"SWF integrates with existing frameworks like Spring MVC, Struts, and JSF, in both servlet and portlet environments. If you have a business process (or processes) that would benefit from a conversational model as opposed to a purely request model, then SWF may be the solution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"SWF allows you to capture logical page flows as self-contained modules that are reusable in different situations, and as such is ideal for building web application modules that guide the user through controlled navigations that drive business processes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"For more information about SWF, consult the Spring Web Flow website.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The dual phases of portlet requests are one of the real strengths of the JSR-286 specification. For example, dynamic search results can be updated routinely on the display without the user explicitly rerunning the search. Most other portlet MVC frameworks attempt to completely hide the two phases from the developer and make it look as much like traditional servlet development as possible - we think this approach removes one of the main benefits of using portlets. So, the separation of the two phases is preserved throughout the Spring Portlet MVC framework. The primary manifestation of this approach is that where the servlet version of the MVC classes will have one method that deals with the request, the portlet version of the MVC classes will have two methods that deal with the request: one for the action phase and one for the render phase. For example, where the servlet version of AbstractController has the handleRequestInternal(..) method, the portlet version of AbstractController has handleActionRequestInternal(..) and handleRenderRequestInternal(..) methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The framework is designed around a DispatcherPortlet that dispatches requests to handlers, with configurable handler mappings and view resolution, just as the DispatcherServlet in the web framework does. File upload is also supported in the same way.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Locale resolution and theme resolution are not supported in Portlet MVC - these areas are in the purview of the portal/portlet container and are not appropriate at the Spring level. However, all mechanisms in Spring that depend on the locale (such as internationalization of messages) will still function properly because DispatcherPortlet exposes the current locale in the same way as DispatcherServlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The default handler is still a very simple Controller interface, offering just two methods:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"void handleActionRequest(request,response)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"ModelAndView handleRenderRequest(request,response)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The framework also includes most of the same controller implementation hierarchy, such as AbstractController, SimpleFormController, and so on. Data binding, command object usage, model handling, and view resolution are all the same as in the servlet framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"All the view rendering capabilities of the servlet framework are used directly via a special bridge servlet named ViewRendererServlet. By using this servlet, the portlet request is converted into a servlet request and the view can be rendered using the entire normal servlet infrastructure. This means all the existing renderers, such as JSP, Velocity, etc., can still be used within the portlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Portlet MVC is a request-driven web MVC framework, designed around a portlet that dispatches requests to controllers and offers other functionality facilitating the development of portlet applications. Spring's DispatcherPortlet however, does more than just that. It is completely integrated with the Spring ApplicationContext and allows you to use every other feature Spring has.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Like ordinary portlets, the DispatcherPortlet is declared in the portlet.xml file of your web application:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The DispatcherPortlet now needs to be configured.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"In the Portlet MVC framework, each DispatcherPortlet has its own WebApplicationContext, which inherits all the beans already defined in the Root WebApplicationContext. These inherited beans can be overridden in the portlet-specific scope, and new scope-specific beans can be defined local to a given portlet instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The framework will, on initialization of a DispatcherPortlet, look for a file named [portlet-name]-portlet.xml in the WEB-INF directory of your web application and create the beans defined there (overriding the definitions of any beans defined with the same name in the global scope).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The config location used by the DispatcherPortlet can be modified through a portlet initialization parameter (see below for details).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The Spring DispatcherPortlet has a few special beans it uses, in order to be able to process requests and render the appropriate views. These beans are included in the Spring framework and can be configured in the WebApplicationContext, just as any other bean would be configured. Each of those beans is described in more detail below. Right now, we'll just mention them, just to let you know they exist and to enable us to go on talking about the DispatcherPortlet. For most of the beans, defaults are provided so you don't have to worry about configuring them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"When a DispatcherPortlet is setup for use and a request comes in for that specific DispatcherPortlet, it starts processing the request. The list below describes the complete process a request goes through if handled by a DispatcherPortlet:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The locale returned by PortletRequest.getLocale() is bound to the request to let elements in the process resolve the locale to use when processing the request (rendering the view, preparing data, etc.).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"If a multipart resolver is specified and this is an ActionRequest, the request is inspected for multiparts and if they are found, it is wrapped in a MultipartActionRequest for further processing by other elements in the process. (See Section 20.7, “Multipart (file upload) support” for further information about multipart handling).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Second, you may call setValidator(Validator) on the global WebBindingInitializer. This allows you to configure a Validator instance across all @Controllers. This can be achieved easily by using the Spring MVC namespace:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"To combine a global and a local validator, configure the global validator as shown above and then add a local validator:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"With JSR-303, a single javax.validation.Validator instance typically validates all model objects that declare validation constraints. To configure a JSR-303-backed Validator with Spring MVC, simply add a JSR-303 Provider, such as Hibernate Validator, to your classpath. Spring MVC will detect it and automatically enable JSR-303 support across all Controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The Spring MVC configuration required to enable JSR-303 support is shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
"With this minimal configuration, anytime a @Valid @Controller input is encountered, it will be validated by the JSR-303 provider. JSR-303, in turn, will enforce any constraints declared against the input. Any ConstraintViolations will automatically be exposed as errors in the BindingResult renderable by standard Spring MVC form tags.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/validation.html
The following example demonstrates collection merging:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Notice the use of the merge=true attribute on the <props/> element of the adminEmails property of the child bean definition. When the child bean is resolved and instantiated by the container, the resulting instance has an adminEmails Properties collection that contains the result of the merging of the child's adminEmails collection with the parent's adminEmails collection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The child Properties collection's value set inherits all property elements from the parent <props/>, and the child's value for the support value overrides the value in the parent collection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This merging behavior applies similarly to the <list/>, <map/>, and <set/> collection types. In the specific case of the <list/> element, the semantics associated with the List collection type, that is, the notion of an ordered collection of values, is maintained; the parent's values precede all of the child list's values. In the case of the Map, Set, and Properties collection types, no ordering exists. Hence no ordering semantics are in effect for the collection types that underlie the associated Map, Set, and Properties implementation types that the container uses internally.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You cannot merge different collection types (such as a Map and a List), and if you do attempt to do so an appropriate Exception is thrown. The merge attribute must be specified on the lower, inherited, child definition; specifying the merge attribute on a parent collection definition is redundant and will not result in the desired merging. The merging feature is available only in Spring 2.0 and later.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Java 5 and later, you can use strongly typed collections (using generic types). That is, it is possible to declare a Collection type such that it can only contain String elements (for example). If you are using Spring to dependency-inject a strongly-typed Collection into a bean, you can take advantage of Spring's type-conversion support such that the elements of your strongly-typed Collection instances are converted to the appropriate type prior to being added to the Collection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When the accounts property of the foo bean is prepared for injection, the generics information about the element type of the strongly-typed Map<String, Float> is available by reflection. Thus Spring's type conversion infrastructure recognizes the various value elements as being of type Float, and the string values 9.99, 2.75, and 3.99 are converted into an actual Float type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring treats empty arguments for properties and the like as empty Strings. The following XML-based configuration metadata snippet sets the email property to the empty String value ("""")",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The preceding example is equivalent to the following Java code: exampleBean.setEmail(""""). The <null/> element handles null values. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The above configuration is equivalent to the following Java code: exampleBean.setEmail(null).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The p-namespace enables you to use the bean element's attributes, instead of nested <property/> elements, to describe your property values and/or collaborating beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring 2.0 and later supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows two XML snippets that resolve to the same result: The first uses standard XML format and the second uses the p-namespace.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The example shows an attribute in the p-namespace called email in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This next example includes two more bean definitions that both have a reference to another bean:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As you can see, this example includes not only a property value using the p-namespace, but also uses a special format to declare property references. Whereas the first bean definition uses <property name=""spouse"" ref=""jane""/> to create a reference from bean john to bean jane, the second bean definition uses p:spouse-ref=""jane"" as an attribute to do the exact same thing. In this case spouse is the property name, whereas the -ref part indicates that this is not a straight value but rather a reference to another bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in Ref, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Similar to the the section called “XML shortcut with the p-namespace”, the c-namespace, newly introduced in Spring 3.1, allows usage of inlined attributes for configuring the constructor arguments rather then nested constructor-arg elements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Let's review the examples from the section called “Constructor-based dependency injection” with the c namespace:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The c: namespace uses the same conventions as the p: one (trailing -ref for bean references) for setting the constructor arguments by their names. And just as well, it needs to be declared even though it is not defined in an XSD schema (but it exists inside the Spring core).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can use fallback to the argument indexes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Due to the XML grammar, the index notation requires the presence of the leading _ as XML attribute names cannot start with a number (even though some IDE allow it).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In practice, the constructor resolution mechanism is quite efficient in matching arguments so unless one really needs to, we recommend using the name notation through-out your configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not null. Consider the following bean definition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The foo bean has a fred property, which has a bob property, which has a sammy property, and that final sammy property is being set to the value 123. In order for this to work, the fred property of foo, and the bob property of fred must not be null after the bean is constructed, or a NullPointerException is thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If a bean is a dependency of another that usually means that one bean is set as a property of another. Typically you accomplish this with the <ref/> element in XML-based configuration metadata. However, sometimes dependencies between beans are less direct; for example, a static initializer in a class needs to be triggered, such as database driver registration. The depends-on attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the depends-on attribute to express a dependency on a single bean:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To express a dependency on multiple beans, supply a list of bean names as the value of the depends-on attribute, with commas, whitespace and semicolons, used as valid delimiters:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It is of course possible to override properties from the parent template, such as in this case, the transaction propagation settings:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note that in the example above, we have explicitly marked the parent bean definition as abstract by using the abstract attribute, as described previously, so that it may not actually ever be instantiated. Application contexts (but not simple bean factories) will by default pre-instantiate all singletons. It is therefore important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the abstract attribute to true, otherwise the application context will actually try to pre-instantiate it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
It's easy to create AOP proxies programmatically using Spring. This enables you to use Spring AOP without dependency on Spring IoC.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The following listing shows creation of a proxy for a target object, with one interceptor and one advisor. The interfaces implemented by the target object will automatically be proxied:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The first step is to construct an object of type org.springframework.aop.framework.ProxyFactory. You can create this with a target object, as in the above example, or specify the interfaces to be proxied in an alternate constructor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"You can add advices (with interceptors as a specialized kind of advice) and/or advisors, and manipulate them for the life of the ProxyFactory. If you add an IntroductionInterceptionAroundAdvisor, you can cause the proxy to implement additional interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
There are also convenience methods on ProxyFactory (inherited from AdvisedSupport) which allow you to add other advice types such as before and throws advice. AdvisedSupport is the superclass of both ProxyFactory and ProxyFactoryBean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Integrating AOP proxy creation with the IoC framework is best practice in most applications. We recommend that you externalize configuration from Java code with AOP, as in general.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"However you create AOP proxies, you can manipulate them using the org.springframework.aop.framework.Advised interface. Any AOP proxy can be cast to this interface, whichever other interfaces it implements. This interface includes the following methods:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The getAdvisors() method will return an Advisor for every advisor, interceptor or other advice type that has been added to the factory. If you added an Advisor, the returned advisor at this index will be the object that you added. If you added an interceptor or other advice type, Spring will have wrapped this in an advisor with a pointcut that always returns true. Thus if you added a MethodInterceptor, the advisor returned for this index will be an DefaultPointcutAdvisor returning your MethodInterceptor and a pointcut that matches all classes and methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The addAdvisor() methods can be used to add any Advisor. Usually the advisor holding pointcut and advice will be the generic DefaultPointcutAdvisor, which can be used with any advice or pointcut (but not for introductions).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"By default, it's possible to add or remove advisors or interceptors even once a proxy has been created. The only restriction is that it's impossible to add or remove an introduction advisor, as existing proxies from the factory will not show the interface change. (You can obtain a new proxy from the factory to avoid this problem.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
A simple example of casting an AOP proxy to the Advised interface and examining and manipulating its advice:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"It's questionable whether it's advisable (no pun intended) to modify advice on a business object in production, although there are no doubt legitimate usage cases. However, it can be very useful in development: for example, in tests. I have sometimes found it very useful to be able to add test code in the form of an interceptor or other advice, getting inside a method invocation I want to test. (For example, the advice can get inside a transaction created for that method: for example, to run SQL to check that a database was correctly updated, before marking the transaction for roll back.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Depending on how you created the proxy, you can usually set a frozen flag, in which case the Advised isFrozen() method will return true, and any attempts to modify advice through addition or removal will result in an AopConfigException. The ability to freeze the state of an advised object is useful in some cases, for example, to prevent calling code removing a security interceptor. It may also be used in Spring 1.1 to allow aggressive optimization if runtime advice modification is known not to be required.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
So far we've considered explicit creation of AOP proxies using a ProxyFactoryBean or similar factory bean.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring also allows us to use ""auto-proxy"" bean definitions, which can automatically proxy selected bean definitions. This is built on Spring ""bean post processor"" infrastructure, which enables modification of any bean definition as the container loads.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"In this model, you set up some special bean definitions in your XML bean definition file to configure the auto proxy infrastructure. This allows you just to declare the targets eligible for auto-proxying: you don't need to use ProxyFactoryBean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
There are two ways to do this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Using an auto-proxy creator that refers to specific beans in the current context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
A special case of auto-proxy creation that deserves to be considered separately; auto-proxy creation driven by source-level metadata attributes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The org.springframework.aop.framework.autoproxy package provides the following standard auto-proxy creators.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The BeanNameAutoProxyCreator class is a BeanPostProcessor that automatically creates AOP proxies for beans with names matching literal values or wildcards.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"As with ProxyFactoryBean, there is an interceptorNames property rather than a list of interceptors, to allow correct behavior for prototype advisors. Named ""interceptors"" can be advisors or any advice type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"As with auto proxying in general, the main point of using BeanNameAutoProxyCreator is to apply the same configuration consistently to multiple objects, with minimal volume of configuration. It is a popular choice for applying declarative transactions to multiple objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Bean definitions whose names match, such as ""jdkMyBean"" and ""onlyJdk"" in the above example, are plain old bean definitions with the target class. An AOP proxy will be created automatically by the BeanNameAutoProxyCreator. The same advice will be applied to all matching beans. Note that if advisors are used (rather than the interceptor in the above example), the pointcuts may apply differently to different beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"To configure an ApplicationContext for your tests using context initializers, annotate your test class with @ContextConfiguration and configure the initializers attribute with an array that contains references to classes that implement ApplicationContextInitializer. The declared context initializers will then be used to initialize the ConfigurableApplicationContext that is loaded for your tests. Note that the concrete ConfigurableApplicationContext type supported by each declared initializer must be compatible with the type of ApplicationContext created by the SmartContextLoader in use (i.e., typically a GenericApplicationContext). Furthermore, the order in which the initializers are invoked depends on whether they implement Spring's Ordered interface or are annotated with Spring's @Order annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"It is also possible to omit the declaration of XML configuration files or annotated classes in @ContextConfiguration entirely and instead declare only ApplicationContextInitializer classes which are then responsible for registering beans in the context — for example, by programmatically loading bean definitions from XML files or configuration classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"@ContextConfiguration supports boolean inheritLocations and inheritInitializers attributes that denote whether resource locations or annotated classes and context initializers declared by superclasses should be inherited. The default value for both flags is true. This means that a test class inherits the resource locations or annotated classes as well as the context initializers declared by any superclasses. Specifically, the resource locations or annotated classes for a test class are appended to the list of resource locations or annotated classes declared by superclasses. Similarly, the initializers for a given test class will be added to the set of initializers defined by test superclasses. Thus, subclasses have the option of extending the resource locations, annotated classes, or context initializers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If @ContextConfiguration's inheritLocations or inheritInitializers attribute is set to false, the resource locations or annotated classes and the context initializers, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the following example that uses XML resource locations, the ApplicationContext for ExtendedTest will be loaded from ""base-config.xml"" and ""extended-config.xml"", in that order. Beans defined in ""extended-config.xml"" may therefore override (i.e., replace) those defined in ""base-config.xml"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Similarly, in the following example that uses annotated classes, the ApplicationContext for ExtendedTest will be loaded from the BaseConfig and ExtendedConfig classes, in that order. Beans defined in ExtendedConfig may therefore override (i.e., replace) those defined in BaseConfig.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the following example that uses context initializers, the ApplicationContext for ExtendedTest will be initialized using BaseInitializer and ExtendedInitializer. Note, however, that the order in which the initializers are invoked depends on whether they implement Spring's Ordered interface or are annotated with Spring's @Order annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring 3.1 introduced first-class support in the framework for the notion of environments and profiles (a.k.a., bean definition profiles), and integration tests can be configured to activate particular bean definition profiles for various testing scenarios. This is achieved by annotating a test class with the @ActiveProfiles annotation and supplying a list of profiles that should be activated when loading the ApplicationContext for the test.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"@ActiveProfiles may be used with any implementation of the new SmartContextLoader SPI, but @ActiveProfiles is not supported with implementations of the older ContextLoader SPI.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Let's take a look at some examples with XML configuration and @Configuration classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When TransferServiceTest is run, its ApplicationContext will be loaded from the app-config.xml configuration file in the root of the classpath. If you inspect app-config.xml you'll notice that the accountRepository bean has a dependency on a dataSource bean; however, dataSource is not defined as a top-level bean. Instead, dataSource is defined twice: once in the production profile and once in the dev profile.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"By annotating TransferServiceTest with @ActiveProfiles(""dev"") we instruct the Spring TestContext Framework to load the ApplicationContext with the active profiles set to {""dev""}. As a result, an embedded database will be created, and the accountRepository bean will be wired with a reference to the development DataSource. And that's likely what we want in an integration test.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following code listings demonstrate how to implement the same configuration and integration test but using @Configuration classes instead of XML.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In this variation, we have split the XML configuration into three independent @Configuration classes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As with the XML-based configuration example, we still annotate TransferServiceTest with @ActiveProfiles(""dev""), but this time we specify all three configuration classes via the @ContextConfiguration annotation. The body of the test class itself remains completely unchanged.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring 3.2 introduces support for loading a WebApplicationContext in integration tests. To instruct the TestContext framework to load a WebApplicationContext instead of a standard ApplicationContext, simply annotate the respective test class with @WebAppConfiguration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The presence of @WebAppConfiguration on your test class instructs the TestContext framework (TCF) that a WebApplicationContext (WAC) should be loaded for your integration tests. In the background the TCF makes sure that a MockServletContext is created and supplied to your test's WAC. By default the base resource path for your MockServletContext will be set to ""src/main/webapp"". This is interpreted as a path relative to the root of your JVM (i.e., normally the path to your project). If you're familiar with the directory structure of a web application in a Maven project, you'll know that ""src/main/webapp"" is the default location for the root of your WAR. If you need to override this default, simply provide an alternate path to the @WebAppConfiguration annotation (e.g., @WebAppConfiguration(""src/test/webapp"")). If you wish to reference a base resource path from the classpath instead of the file system, just use Spring's classpath: prefix.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Please note that Spring's testing support for WebApplicationContexts is on par with its support for standard ApplicationContexts. When testing with a WebApplicationContext you are free to declare either XML configuration files or @Configuration classes via @ContextConfiguration. You are of course also free to use any other test annotations such as @TestExecutionListeners, @TransactionConfiguration, @ActiveProfiles, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following examples demonstrate some of the various configuration options for loading a WebApplicationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The above example demonstrates the TestContext framework's support for convention over configuration. If you annotate a test class with @WebAppConfiguration without specifying a resource base path, the resource path will effectively default to ""file:src/main/webapp"". Similarly, if you declare @ContextConfiguration without specifying resource locations, annotated classes, or context initializers, Spring will attempt to detect the presence of your configuration using conventions (i.e., ""WacTests-context.xml"" in the same package as the WacTests class or static nested @Configuration classes).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"This example demonstrates how to explicitly declare a resource base path with @WebAppConfiguration and an XML resource location with @ContextConfiguration. The important thing to note here is the different semantics for paths with these two annotations. By default, @WebAppConfiguration resource paths are file system based; whereas, @ContextConfiguration resource locations are classpath based.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In this third example, we see that we can override the default resource semantics for both annotations by specifying a Spring resource prefix. Contrast the comments in this example with the previous example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To provide comprehensive web testing support, Spring 3.2 introduces a new ServletTestExecutionListener that is enabled by default. When testing against a WebApplicationContext this TestExecutionListener sets up default thread-local state via Spring Web's RequestContextHolder before each test method and creates a MockHttpServletRequest, MockHttpServletResponse, and ServletWebRequest based on the base resource path configured via @WebAppConfiguration. ServletTestExecutionListener also ensures that the MockHttpServletResponse and ServletWebRequest can be injected into the test instance, and once the test is complete it cleans up thread-local state.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Once you have a WebApplicationContext loaded for your test you might find that you need to interact with the web mocks — for example, to set up your test fixture or to perform assertions after invoking your web component. The following example demonstrates which mocks can be autowired into your test instance. Note that the WebApplicationContext and MockServletContext are both cached across the test suite; whereas, the other mocks are managed per test method by the ServletTestExecutionListener.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Once the TestContext framework loads an ApplicationContext (or WebApplicationContext) for a test, that context will be cached and reused for all subsequent tests that declare the same unique context configuration within the same test suite. To understand how caching works, it is important to understand what is meant by unique and test suite.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the debug information then there is no need to add the argNames attribute as the compiler will retain the needed information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If the code has been compiled without the necessary debug information, then Spring AOP will attempt to deduce the pairing of binding variables to parameters (for example, if only one variable is bound in the pointcut expression, and the advice method only takes one parameter, the pairing is obvious!). If the binding of variables is ambiguous given the available information, then an AmbiguousBindingException will be thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
If all of the above strategies fail then an IllegalArgumentException will be thrown.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
We remarked earlier that we would describe how to write a proceed call with arguments that works consistently across Spring AOP and AspectJ. The solution is simply to ensure that the advice signature binds each of the method parameters in order. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
In many cases you will be doing this binding anyway (as in the example above).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"What happens when multiple pieces of advice all want to run at the same join point? Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution. The highest precedence advice runs first ""on the way in"" (so given two pieces of before advice, the one with highest precedence runs first). ""On the way out"" from a join point, the highest precedence advice runs last (so given two pieces of after advice, the one with the highest precedence will run second).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When two pieces of advice defined in different aspects both need to run at the same join point, unless you specify otherwise the order of execution is undefined. You can control the order of execution by specifying precedence. This is done in the normal Spring way by either implementing the org.springframework.core.Ordered interface in the aspect class or annotating it with the Order annotation. Given two aspects, the aspect returning the lower value from Ordered.getValue() (or the annotation value) has the higher precedence.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When two pieces of advice defined in the same aspect both need to run at the same join point, the ordering is undefined (since there is no way to retrieve the declaration order via reflection for javac-compiled classes). Consider collapsing such advice methods into one advice method per join point in each aspect class, or refactor the pieces of advice into separate aspect classes - which can be ordered at the aspect level.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"An introduction is made using the @DeclareParents annotation. This annotation is used to declare that matching types have a new parent (hence the name). For example, given an interface UsageTracked, and an implementation of that interface DefaultUsageTracked, the following aspect declares that all implementors of service interfaces also implement the UsageTracked interface. (In order to expose statistics via JMX for example.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The interface to be implemented is determined by the type of the annotated field. The value attribute of the @DeclareParents annotation is an AspectJ type pattern :- any bean of a matching type will implement the UsageTracked interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the UsageTracked interface. If accessing a bean programmatically you would write the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"(This is an advanced topic, so if you are just starting out with AOP you can safely skip it until later.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"By default there will be a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles :- Spring supports AspectJ's perthis and pertarget instantiation models (percflow, percflowbelow, and pertypewithin are not currently supported).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"A ""perthis"" aspect is declared by specifying a perthis clause in the @Aspect annotation. Let's look at an example, and then we'll explain how it works.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The effect of the 'perthis' clause is that one aspect instance will be created for each unique service object executing a business service (each unique object bound to 'this' at join points matched by the pointcut expression). The aspect instance is created the first time that a method is invoked on the service object. The aspect goes out of scope when the service object goes out of scope. Before the aspect instance is created, none of the advice within it executes. As soon as the aspect instance has been created, the advice declared within it will execute at matched join points, but only when the service object is the one this aspect is associated with. See the AspectJ programming guide for more information on per-clauses.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The 'pertarget' instantiation model works in exactly the same way as perthis, but creates one aspect instance for each unique target object at matched join points.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Now that you have seen how all the constituent parts work, let's put them together to do something useful!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely to succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don't need to go back to the user for conflict resolution), we'd like to transparently retry the operation to avoid the client seeing a PessimisticLockingFailureException. This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Because we want to retry the operation, we will need to use around advice so that we can call proceed multiple times. Here's how the basic aspect implementation looks:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that the aspect implements the Ordered interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The maxRetries and order properties will both be configured by Spring. The main action happens in the doConcurrentOperation around advice. Notice that for the moment we're applying the retry logic to all businessService()s. We try to proceed, and if we fail with an PessimisticLockingFailureException we simply try again unless we have exhausted all of our retry attempts.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The corresponding Spring configuration is:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To refine the aspect so that it only retries idempotent operations, we might define an Idempotent annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
and use the annotation to annotate the implementation of service operations. The change to the aspect to only retry idempotent operations simply involves refining the pointcut expression so that only @Idempotent operations match:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are unable to use Java 5, or simply prefer an XML-based format, then Spring 2.0 also offers support for defining aspects using the new ""aop"" namespace tags. The exact same pointcut expressions and advice kinds are supported as when using the @AspectJ style, hence in this section we will focus on the new syntax and refer the reader to the discussion in the previous section (Section 9.2, “@AspectJ support”) for an understanding of writing pointcut expressions and the binding of advice parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To use the aop namespace tags described in this section, you need to import the spring-aop schema as described in Appendix E, XML Schema-based configuration. See Section E.2.7, “The aop schema” for how to import the tags in the aop namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Within your Spring configurations, all aspect and advisor elements must be placed within an <aop:config> element (you can have more than one <aop:config> element in an application context configuration). An <aop:config> element can contain pointcut, advisor, and aspect elements (note these must be declared in that order).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The <aop:config> style of configuration makes heavy use of Spring's auto-proxying mechanism. This can cause issues (such as advice not being woven) if you are already using explicit auto-proxying via the use of BeanNameAutoProxyCreator or suchlike. The recommended usage pattern is to use either just the <aop:config> style, or just the AutoProxyCreator style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Using the schema support, an aspect is simply a regular Java object defined as a bean in your Spring application context. The state and behavior is captured in the fields and methods of the object, and the pointcut and advice information is captured in the XML.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"An aspect is declared using the <aop:aspect> element, and the backing bean is referenced using the ref attribute:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"This file is completely optional, but if specified, contains the values that are passed to the Velocity runtime in order to configure velocity itself. Only required for advanced configurations, if you need this file, specify its location on the VelocityConfigurer bean definition above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Alternatively, you can specify velocity properties directly in the bean definition for the Velocity config bean by replacing the ""configLocation"" property with the following inline properties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Refer to the API documentation for Spring configuration of Velocity, or the Velocity documentation for examples and definitions of the 'velocity.properties' file itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
FreeMarker 'Settings' and 'SharedVariables' can be passed directly to the FreeMarker Configuration object managed by Spring by setting the appropriate bean properties on the FreeMarkerConfigurer bean. The freemarkerSettings property requires a java.util.Properties object and the freemarkerVariables property requires a java.util.Map.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
See the FreeMarker documentation for details of settings and variables as they apply to the Configuration object.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Spring provides a tag library for use in JSP's that contains (amongst other things) a <spring:bind/> tag. This tag primarily enables forms to display values from form backing objects and to show the results of failed validations from a Validator in the web or business tier. From version 1.1, Spring now has support for the same functionality in both Velocity and FreeMarker, with additional convenience macros for generating form input elements themselves.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"A standard set of macros are maintained within the spring-webmvc.jar file for both languages, so they are always available to a suitably configured application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Some of the macros defined in the Spring libraries are considered internal (private) but no such scoping exists in the macro definitions making all macros visible to calling code and user templates. The following sections concentrate only on the macros you need to be directly calling from within your templates. If you wish to view the macro code directly, the files are called spring.vm / spring.ftl and are in the packages org.springframework.web.servlet.view.velocity or org.springframework.web.servlet.view.freemarker respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In your html forms (vm / ftl templates) that act as the 'formView' for a Spring form controller, you can use code similar to the following to bind to field values and display error messages for each input field in similar fashion to the JSP equivalent. Note that the name of the command object is ""command"" by default, but can be overridden in your MVC configuration by setting the 'commandName' bean property on your form controller. Example code is shown below for the personFormV and personFormF views configured earlier;",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The optional form of the macro called #springBindEscaped / <@spring.bindEscaped> takes a second argument and explicitly specifies whether HTML escaping should be used in the status error messages or values. Set to true or false as required. Additional form handling macros simplify the use of HTML escaping and these macros should be used wherever possible. They are explained in the next section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Additional convenience macros for both languages simplify both binding and form generation (including validation error display). It is never necessary to use these macros to generate form input fields, and they can be mixed and matched with simple HTML or calls direct to the spring bind macros highlighted previously.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The following table of available macros show the VTL and FTL definitions and the parameter list that each takes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"* In FTL (FreeMarker), these two macros are not actually required as you can use the normal formInput macro, specifying 'hidden' or 'password' as the value for the fieldType parameter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The parameters to any of the above macros have consistent meanings:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"path: the name of the field to bind to (ie ""command.name"")",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"options: a Map of all the available values that can be selected from in the input field. The keys to the map represent the values that will be POSTed back from the form and bound to the command object. Map objects stored against the keys are the labels displayed on the form to the user and may be different from the corresponding values posted back by the form. Usually such a map is supplied as reference data by the controller. Any Map implementation can be used depending on required behavior. For strictly sorted maps, a SortedMap such as a TreeMap with a suitable Comparator may be used and for arbitrary Maps that should return values in insertion order, use a LinkedHashMap or a LinkedMap from commons-collections.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"separator: where multiple options are available as discreet elements (radio buttons or checkboxes), the sequence of characters used to separate each one in the list (ie ""<br>"").",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"attributes: an additional string of arbitrary tags or text to be included within the HTML tag itself. This string is echoed literally by the macro. For example, in a textarea field you may supply attributes as 'rows=""5"" cols=""60""' or you could pass style information such as 'style=""border:1px solid silver""'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"classOrStyle: for the showErrors macro, the name of the CSS class that the span tag wrapping each error will use. If no information is supplied (or the value is empty) then the errors will be wrapped in <b></b> tags.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Examples of the macros are outlined below some in FTL and some in VTL. Where usage differences exist between the two languages, they are explained in the notes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The formInput macro takes the path parameter (command.name) and an additional attributes parameter which is empty in the example above. The macro, along with all other form generation macros, performs an implicit spring bind on the path parameter. The binding remains valid until a new bind occurs so the showErrors macro doesn't need to pass the path parameter again - it simply operates on whichever field a bind was last created for.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The showErrors macro takes a separator parameter (the characters that will be used to separate multiple errors on a given field) and also accepts a second parameter, this time a class name or style attribute. Note that FreeMarker is able to specify default values for the attributes parameter, unlike Velocity, and the two macro calls above could be expressed as follows in FTL:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Output is shown below of the form fragment generating the name field, and displaying a validation error after the form was submitted with no value in the field. Validation occurs through Spring's Validation framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The generated HTML looks like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The formTextarea macro works the same way as the formInput macro and accepts the same parameter list. Commonly, the second parameter (attributes) will be used to pass style information or rows and cols attributes for the textarea.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Four selection field macros can be used to generate common UI value selection inputs in your HTML forms.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Each of the four macros accepts a Map of options containing the value for the form field, and the label corresponding to that value. The value and the label can be the same.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"To execute service operations within transactions, you can use Spring's common declarative transaction facilities. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"JDO requires an active transaction to modify a persistent object. The non-transactional flush concept does not exist in JDO, in contrast to Hibernate. For this reason, you need to set up the chosen JDO implementation for a specific environment. Specifically, you need to set it up explicitly for JTA synchronization, to detect an active JTA transaction itself. This is not necessary for local transactions as performed by Spring's JdoTransactionManager, but it is necessary to participate in JTA transactions, whether driven by Spring's JtaTransactionManager or by EJB CMT and plain JTA.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"JdoTransactionManager is capable of exposing a JDO transaction to JDBC access code that accesses the same JDBC DataSource, provided that the registered JdoDialect supports retrieval of the underlying JDBC Connection. This is the case for JDBC-based JDO 2.0 implementations by default.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As an advanced feature, both JdoTemplate and JdoTransactionManager support a custom JdoDialect that can be passed into the jdoDialect bean property. In this scenario, the DAOs will not receive a PersistenceManagerFactory reference but rather a full JdoTemplate instance (for example, passed into the jdoTemplate property of JdoDaoSupport). Using a JdoDialect implementation, you can enable advanced features supported by Spring, usually in a vendor-specific manner:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
See the JdoDialect Javadoc for more details on its operations and how to use them within Spring's JDO support.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The Spring JPA, available under the org.springframework.orm.jpa package, offers comprehensive support for the Java Persistence API in a similar manner to the integration with Hibernate or JDO, while being aware of the underlying implementation in order to provide additional features.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The Spring JPA support offers three ways of setting up the JPA EntityManagerFactory that will be used by the application to obtain an entity manager.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Only use this option in simple deployment environments such as stand-alone applications and integration tests.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The LocalEntityManagerFactoryBean creates an EntityManagerFactory suitable for simple deployment environments where the application uses only JPA for data access. The factory bean uses the JPA PersistenceProvider autodetection mechanism (according to JPA's Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing JDBC DataSource bean definition and no support for global transactions exists. Furthermore, weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a specific JVM agent to specified on startup. This option is sufficient only for stand-alone applications and test environments, for which the JPA specification is designed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Use this option when deploying to a Java EE 5 server. Check your server's documentation on how to deploy a custom JPA provider into your server, allowing for a different provider than the server's default.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Obtaining an EntityManagerFactory from JNDI (for example in a Java EE 5 environment), is simply a matter of changing the XML configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This action assumes standard Java EE 5 bootstrapping: the Java EE server autodetects persistence units (in effect, META-INF/persistence.xml files in application jars) and persistence-unit-ref entries in the Java EE deployment descriptor (for example, web.xml) and defines environment naming context locations for those persistence units.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In such a scenario, the entire persistence unit deployment, including the weaving (byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC DataSource is defined through a JNDI location in the META-INF/persistence.xml file; EntityManager transactions are integrated with the server's JTA subsystem. Spring merely uses the obtained EntityManagerFactory, passing it on to application objects through dependency injection, and managing transactions for the persistence unit, typically through JtaTransactionManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"If multiple persistence units are used in the same application, the bean names of such JNDI-retrieved persistence units should match the persistence unit names that the application uses to refer to them, for example, in @PersistenceUnit and @PersistenceContext annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat as well as stand-alone applications and integration tests with sophisticated persistence requirements.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The LocalContainerEntityManagerFactoryBean gives full control over EntityManagerFactory configuration and is appropriate for environments where fine-grained customization is required. The LocalContainerEntityManagerFactoryBean creates a PersistenceUnitInfo instance based on the persistence.xml file, the supplied dataSourceLookup strategy, and the specified loadTimeWeaver. It is thus possible to work with custom data sources outside of JNDI and to control the weaving process. The following example shows a typical bean definition for a LocalContainerEntityManagerFactoryBean:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The following example shows a typical persistence.xml file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The exclude-unlisted-classes element always indicates that no scanning for annotated entity classes is supposed to occur, in order to support the <exclude-unlisted-classes/> shortcut. This is in line with the JPA specification, which suggests that shortcut, but unfortunately is in conflict with the JPA XSD, which implies false for that shortcut. Consequently, <exclude-unlisted-classes> false </exclude-unlisted-classes/> is not supported. Simply omit the exclude-unlisted-classes element if you want entity class scanning to occur.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Using the LocalContainerEntityManagerFactoryBean is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC DataSource, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This option may conflict with the built-in JPA capabilities of a Java EE 5 server. In a full Java EE 5 environment, consider obtaining your EntityManagerFactory from JNDI. Alternatively, specify a custom persistenceXmlLocation on your LocalContainerEntityManagerFactoryBean definition, for example, META-INF/my-persistence.xml, and only include a descriptor with that name in your application jar files. Because the Java EE 5 server only looks for default META-INF/persistence.xml files, it ignores such custom persistence units and hence avoid conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for example.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
When is load-time weaving required?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Not all JPA providers require a JVM agent ; Hibernate is an example of one that does not. If your provider does not require an agent or you have other alternatives, such as applying enhancements at build time through a custom compiler or an ant task, the load-time weaver should not be used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The LoadTimeWeaver interface is a Spring-provided class that allows JPA ClassTransformer instances to be plugged in a specific manner, depending whether the environment is a web container or application server. Hooking ClassTransformers through a Java 5 agent typically is not efficient. The agents work against the entire virtual machine and inspect every class that is loaded, which is usually undesirable in a production server environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring provides a number of LoadTimeWeaver implementations for various environments, allowing ClassTransformer instances to be applied only per class loader and not per VM.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Refer to the section called “Spring configuration” in the AOP chapter for more insight regarding the LoadTimeWeaver implementations and their setup, either generic or customized to various platforms (such as Tomcat, WebLogic, OC4J, GlassFish, Resin and JBoss).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As described in the aforementioned section, you can configure a context-wide LoadTimeWeaver using the @EnableLoadTimeWeaving annotation of context:load-time-weaver XML element. Such a global weaver is picked up by all JPA LocalContainerEntityManagerFactoryBeans automatically. This is the preferred way of setting up a load-time weaver, delivering autodetection of the platform (WebLogic, OC4J, GlassFish, Tomcat, Resin, JBoss or VM agent) and automatic propagation of the weaver to all weaver-aware beans:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"However, if needed, one can manually specify a dedicated weaver through the loadTimeWeaver property:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"TransactionAwareDataSourceProxy is a proxy for a target DataSource, which wraps that target DataSource to add awareness of Spring-managed transactions. In this respect, it is similar to a transactional JNDI DataSource as provided by a Java EE server.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"It is rarely desirable to use this class, except when already existing code that must be called and passed a standard JDBC DataSource interface implementation. In this case, it's possible to still have this code be usable, and at the same time have this code participating in Spring managed transactions. It is generally preferable to write your own new code using the higher level abstractions for resource management, such as JdbcTemplate or DataSourceUtils.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
(See the TransactionAwareDataSourceProxy Javadocs for more details.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The DataSourceTransactionManager class is a PlatformTransactionManager implementation for single JDBC datasources. It binds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for one thread connection per data source.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Application code is required to retrieve the JDBC connection through DataSourceUtils.getConnection(DataSource) instead of Java EE's standard DataSource.getConnection. It throws unchecked org.springframework.dao exceptions instead of checked SQLExceptions. All framework classes like JdbcTemplate use this strategy implicitly. If not used with this transaction manager, the lookup strategy behaves exactly like the common one - it can thus be used in any case.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The DataSourceTransactionManager class supports custom isolation levels, and timeouts that get applied as appropriate JDBC statement query timeouts. To support the latter, application code must either use JdbcTemplate or call the DataSourceUtils.applyTransactionTimeout(..) method for each created statement.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This implementation can be used instead of JtaTransactionManager in the single resource case, as it does not require the container to support JTA. Switching between both is just a matter of configuration, if you stick to the required connection lookup pattern. JTA does not support custom isolation levels!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Sometimes you need to access vendor specific JDBC methods that differ from the standard JDBC API. This can be problematic if you are running in an application server or with a DataSource that wraps the Connection, Statement and ResultSet objects with its own wrapper objects. To gain access to the native objects you can configure your JdbcTemplate or OracleLobHandler with a NativeJdbcExtractor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The NativeJdbcExtractor comes in a variety of flavors to match your execution environment:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Usually the SimpleNativeJdbcExtractor is sufficient for unwrapping a Connection object in most environments. See the Javadocs for more details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Most JDBC drivers provide improved performance if you batch multiple calls to the same prepared statement. By grouping updates into batches you limit the number of round trips to the database.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You accomplish JdbcTemplate batch processing by implementing two methods of a special interface, BatchPreparedStatementSetter, and passing that in as the second parameter in your batchUpdate method call. Use the getBatchSize method to provide the size of the current batch. Use the setValues method to set the values for the parameters of the prepared statement. This method will be called the number of times that you specified in the getBatchSize call. The following example updates the actor table based on entries in a list. The entire list is used as the batch in this example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If you are processing a stream of updates or reading from a file, then you might have a preferred batch size, but the last batch might not have that number of entries. In this case you can use the InterruptibleBatchPreparedStatementSetter interface, which allows you to interrupt a batch once the input source is exhausted. The isBatchExhausted method allows you to signal the end of the batch.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Both the JdbcTemplate and the NamedParameterJdbcTemplate provides an alternate way of providing the batch update. Instead of implementing a special batch interface, you provide all parameter values in the call as a list. The framework loops over these values and uses an internal prepared statement setter. The API varies depending on whether you use named parameters. For the named parameters you provide an array of SqlParameterSource, one entry for each member of the batch. You can use the SqlParameterSource.createBatch method to create this array, passing in either an array of JavaBeans or an array of Maps containing the parameter values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
This example shows a batch update using named parameters:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"For an SQL statement using the classic ""?"" placeholders, you pass in a list containing an object array with the update values. This object array must have one entry for each placeholder in the SQL statement, and they must be in the same order as they are defined in the SQL statement.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The same example using classic JDBC ""?"" placeholders:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"All of the above batch update methods return an int array containing the number of affected rows for each batch entry. This count is reported by the JDBC driver. If the count is not available, the JDBC driver returns a -2 value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The last example of a batch update deals with batches that are so large that you want to break them up into several smaller batches. You can of course do this with the methods mentioned above by making multiple calls to the batchUpdate method, but there is now a more convenient method. This method takes, in addition to the SQL statement, a Collection of objects containing the parameters, the number of updates to make for each batch and a ParameterizedPreparedStatementSetter to set the values for the parameters of the prepared statement. The framework loops over the provided values and breaks the update calls into batches of the size specified.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
This example shows a batch update using a batch size of 100:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The batch update methods for this call returns an array of int arrays containing an array entry for each batch with an array of the number of affected rows for each update. The top level array's length indicates the number of batches executed and the second level array's length indicates the number of updates in that batch. The number of updates in each batch should be the the batch size provided for all batches except for the last one that might be less, depending on the total number of update objects provided. The update count for each update statement is the one reported by the JDBC driver. If the count is not available, the JDBC driver returns a -2 value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SimpleJdbcInsert and SimpleJdbcCall classes provide a simplified configuration by taking advantage of database metadata that can be retrieved through the JDBC driver. This means there is less to configure up front, although you can override or turn off the metadata processing if you prefer to provide all the details in your code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Let's start by looking at the SimpleJdbcInsert class with the minimal amount of configuration options. You should instantiate the SimpleJdbcInsert in the data access layer's initialization method. For this example, the initializing method is the setDataSource method. You do not need to subclass the SimpleJdbcInsert class; simply create a new instance and set the table name using the withTableName method. Configuration methods for this class follow the ""fluid"" style that returns the instance of the SimpleJdbcInsert, which allows you to chain all configuration methods. This example uses only one configuration method; you will see examples of multiple ones later.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
In Spring MVC you can use the @PathVariable annotation on a method argument to bind it to the value of a URI template variable:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The URI Template ""/owners/{ownerId}"" specifies the variable name ownerId. When the controller handles this request, the value of ownerId is set to the value found in the appropriate part of the URI. For example, when a request comes in for /owners/fred, the value of ownerId is fred.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To process the @PathVariable annotation, Spring MVC needs to find the matching URI template variable by name. You can specify it in the annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Or if the URI template variable name matches the method argument name you can omit that detail. As long as your code is not compiled without debugging information, Spring MVC will match the method argument name to the URI template variable name:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A method can have any number of @PathVariable annotations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When a @PathVariable annotation is used on a Map<String, String> argument, the map is populated with all URI template variables.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A URI template can be assembled from type and path level @RequestMapping annotations. As a result the findPet() method can be invoked with a URL such as /owners/42/pets/21.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A @PathVariable argument can be of any simple type such as int, long, Date, etc. Spring automatically converts to the appropriate type or throws a TypeMismatchException if it fails to do so. You can also register support for parsing additional data types. See the section called “Method Parameters And Type Conversion” and the section called “Customizing WebDataBinder initialization”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Sometimes you need more precision in defining URI template variables. Consider the URL ""/spring-web/spring-web-3.0.5.jar"". How do you break it down into multiple parts?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @RequestMapping annotation supports the use of regular expressions in URI template variables. The syntax is {varName:regex} where the first part defines the variable name and the second - the regular expression.For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In addition to URI templates, the @RequestMapping annotation also supports Ant-style path patterns (for example, /myPath/*.do). A combination of URI templates and Ant-style globs is also supported (for example, /owners/*/pets/{petId}).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Patterns in @RequestMapping annotations support ${...} placeholders against local properties and/or system properties and environment variables. This may be useful in cases where the path a controller is mapped to may need to be customized through configuration. For more information on placeholders see the Javadoc for PropertyPlaceholderConfigurer.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The URI specification RFC 3986 defines the possibility of including name-value pairs within path segments. There is no specific term used in the spec. The general ""URI path parameters"" could be applied although the more unique ""Matrix URIs"", originating from an old post by Tim Berners-Lee, is also frequently used and fairly well known. Within Spring MVC these are referred to as matrix variables.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Matrix variables can appear in any path segment, each matrix variable separated with a "";"" (semicolon). For example: ""/cars;color=red;year=2012"". Multiple values may be either "","" (comma) separated ""color=red,green,blue"" or the variable name may be repeated ""color=red;color=green;color=blue"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If a URL is expected to contain matrix variables, the request mapping pattern must represent them with a URI template. This ensures the request can be matched correctly regardless of whether matrix variables are present or not and in what order they are provided.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Below is an example of extracting the matrix variable ""q"":",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Since all path segments may contain matrix variables, in some cases you need to be more specific to identify where the variable is expected to be:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A matrix variable may be defined as optional and a default value specified:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
All matrix variables may be obtained in a Map:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note that to enable the use of matrix variables, you must set the removeSemicolonContent property of RequestMappingHandlerMapping to false. By default it is set to false.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the MVC namespace, the `mvc:annotation-driven` element has an `enableMatrixVariables` attribute that should be set to `true`. By default it is set to `false`.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can narrow the primary mapping by specifying a list of consumable media types. The request will be matched only if the Content-Type request header matches the specified media type. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Consumable media type expressions can also be negated as in !text/plain to match to all requests other than those with Content-Type of text/plain.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The consumes condition is supported on the type and on the method level. Unlike most other conditions, when used at the type level, method-level consumable types override rather than extend type-level consumable types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can narrow the primary mapping by specifying a list of producible media types. The request will be matched only if the Accept request header matches one of these values. Furthermore, use of the produces condition ensures the actual content type used to generate the response respects the media types specified in the produces condition. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Just like with consumes, producible media type expressions can be negated as in !text/plain to match to all requests other than those with an Accept header value of text/plain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The produces condition is supported on the type and on the method level. Unlike most other conditions, when used at the type level, method-level producible types override rather than extend type-level producible types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can narrow request matching through request parameter conditions such as ""myParam"", ""!myParam"", or ""myParam=myValue"". The first two test for request parameter presence/absence and the third for a specific parameter value. Here is an example with a request parameter value condition:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The same can be done to test for request header presence/absence or to match based on a specific request header value:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Although you can match to Content-Type and Accept header values using media type wild cards (for example ""content-type=text/*"" will match to ""text/plain"" and ""text/html""), it is recommended to use the consumes and produces conditions respectively instead. They are intended specifically for that purpose.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The <aop:config/> definition ensures that the transactional advice defined by the txAdvice bean executes at the appropriate points in the program. First you define a pointcut that matches the execution of any operation defined in the FooService interface (fooServiceOperation). Then you associate the pointcut with the txAdvice using an advisor. The result indicates that at the execution of a fooServiceOperation, the advice defined by txAdvice will be run.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The expression defined within the <aop:pointcut/> element is an AspectJ pointcut expression; see Chapter 9, Aspect Oriented Programming with Spring for more details on pointcut expressions in Spring 2.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
A common requirement is to make an entire service layer transactional. The best way to do this is simply to change the pointcut expression to match any operation in your service layer. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In this example it is assumed that all your service interfaces are defined in the x.y.service package; see Chapter 9, Aspect Oriented Programming with Spring for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Now that we've analyzed the configuration, you may be asking yourself, “Okay... but what does all this configuration actually do?”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The above configuration will be used to create a transactional proxy around the object that is created from the fooService bean definition. The proxy will be configured with the transactional advice, so that when an appropriate method is invoked on the proxy, a transaction is started, suspended, marked as read-only, and so on, depending on the transaction configuration associated with that method. Consider the following program that test drives the above configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The output from running the preceding program will resemble the following. (The Log4J output and the stack trace from the UnsupportedOperationException thrown by the insertFoo(..) method of the DefaultFooService class have been truncated for clarity.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The previous section outlined the basics of how to specify transactional settings for classes, typically service layer classes, declaratively in your application. This section describes how you can control the rollback of transactions in a simple declarative fashion.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The recommended way to indicate to the Spring Framework's transaction infrastructure that a transaction's work is to be rolled back is to throw an Exception from code that is currently executing in the context of a transaction. The Spring Framework's transaction infrastructure code will catch any unhandled Exception as it bubbles up the call stack, and make a determination whether to mark the transaction for rollback.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In its default configuration, the Spring Framework's transaction infrastructure code only marks a transaction for rollback in the case of runtime, unchecked exceptions; that is, when the thrown exception is an instance or subclass of RuntimeException. (Errors will also - by default - result in a rollback). Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can configure exactly which Exception types mark a transaction for rollback, including checked exceptions. The following XML snippet demonstrates how you configure rollback for a checked, application-specific Exception type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can also specify 'no rollback rules', if you do not want a transaction rolled back when an exception is thrown. The following example tells the Spring Framework's transaction infrastructure to commit the attendant transaction even in the face of an unhandled InstrumentNotFoundException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When the Spring Framework's transaction infrastructure catches an exception and is consults configured rollback rules to determine whether to mark the transaction for rollback, the strongest matching rule wins. So in the case of the following configuration, any exception other than an InstrumentNotFoundException results in a rollback of the attendant transaction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can also indicate a required rollback programmatically. Although very simple, this process is quite invasive, and tightly couples your code to the Spring Framework's transaction infrastructure:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You are strongly encouraged to use the declarative approach to rollback if at all possible. Programmatic rollback is available should you absolutely need it, but its usage flies in the face of achieving a clean POJO-based architecture.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Consider the scenario where you have a number of service layer objects, and you want to apply a totally different transactional configuration to each of them. You do this by defining distinct <aop:advisor/> elements with differing pointcut and advice-ref attribute values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"As a point of comparison, first assume that all of your service layer classes are defined in a root x.y.service package. To make all beans that are instances of classes defined in that package (or in subpackages) and that have names ending in Service have the default transactional configuration, you would write the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The following example shows how to configure two distinct beans with totally different transactional settings.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
This section summarizes the various transactional settings that can be specified using the <tx:advice/> tag. The default <tx:advice/> settings are:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Propagation setting is REQUIRED.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Isolation level is DEFAULT.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Transaction is read/write.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Transaction timeout defaults to the default timeout of the underlying transaction system, or none if timeouts are not supported.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Any RuntimeException triggers rollback, and any checked Exception does not.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
You can change these default settings; the various attributes of the <tx:method/> tags that are nested within <tx:advice/> and <tx:attributes/> tags are summarized below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Method name(s) with which the transaction attributes are to be associated. The wildcard (*) character can be used to associate the same transaction attribute settings with a number of methods; for example, get*, handle*, on*Event, and so forth.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Consider the following interface definition. Notice that although the interface extends neither the MessageListener nor SessionAwareMessageListener interfaces, it can still be used as a MDP via the use of the MessageListenerAdapter class. Notice also how the various message handling methods are strongly typed according to the contents of the various Message types that they can receive and handle.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In particular, note how the above implementation of the MessageDelegate interface (the above DefaultMessageDelegate class) has no JMS dependencies at all. It truly is a POJO that we will make into an MDP via the following configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Below is an example of another MDP that can only handle the receiving of JMS TextMessage messages. Notice how the message handling method is actually called 'receive' (the name of the message handling method in a MessageListenerAdapter defaults to 'handleMessage'), but it is configurable (as you will see below). Notice also how the 'receive(..)' method is strongly typed to receive and respond only to JMS TextMessage messages.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The configuration of the attendant MessageListenerAdapter would look like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Please note that if the above 'messageListener' receives a JMS Message of a type other than TextMessage, an IllegalStateException will be thrown (and subsequently swallowed). Another of the capabilities of the MessageListenerAdapter class is the ability to automatically send back a response Message if a handler method returns a non-void value. Consider the interface and class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"If the above DefaultResponsiveTextMessageDelegate is used in conjunction with a MessageListenerAdapter then any non-null value that is returned from the execution of the 'receive(..)' method will (in the default configuration) be converted into a TextMessage. The resulting TextMessage will then be sent to the Destination (if one exists) defined in the JMS Reply-To property of the original Message, or the default Destination set on the MessageListenerAdapter (if one has been configured); if no Destination is found then an InvalidDestinationException will be thrown (and please note that this exception will not be swallowed and will propagate up the call stack).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Invoking a message listener within a transaction only requires reconfiguration of the listener container.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Local resource transactions can simply be activated through the sessionTransacted flag on the listener container definition. Each message listener invocation will then operate within an active JMS transaction, with message reception rolled back in case of listener execution failure. Sending a response message (via SessionAwareMessageListener) will be part of the same local transaction, but any other resource operations (such as database access) will operate independently. This usually requires duplicate message detection in the listener implementation, covering the case where database processing has committed but message processing failed to commit.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"For participating in an externally managed transaction, you will need to configure a transaction manager and use a listener container which supports externally managed transactions: typically DefaultMessageListenerContainer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"To configure a message listener container for XA transaction participation, you'll want to configure a JtaTransactionManager (which, by default, delegates to the Java EE server's transaction subsystem). Note that the underlying JMS ConnectionFactory needs to be XA-capable and properly registered with your JTA transaction coordinator! (Check your Java EE server's configuration of JNDI resources.) This allows message reception as well as e.g. database access to be part of the same transaction (with unified commit semantics, at the expense of XA transaction log overhead).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Then you just need to add it to our earlier container configuration. The container will take care of the rest.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Beginning with version 2.5, Spring also provides support for a JCA-based MessageListener container. The JmsMessageEndpointManager will attempt to automatically determine the ActivationSpec class name from the provider's ResourceAdapter class name. Therefore, it is typically possible to just provide Spring's generic JmsActivationSpecConfig as shown in the following example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Alternatively, you may set up a JmsMessageEndpointManager with a given ActivationSpec object. The ActivationSpec object may also come from a JNDI lookup (using <jee:jndi-lookup>).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Using Spring's ResourceAdapterFactoryBean, the target ResourceAdapter may be configured locally as depicted in the following example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The specified WorkManager may also point to an environment-specific thread pool - typically through SimpleTaskWorkManager's ""asyncTaskExecutor"" property. Consider defining a shared thread pool for all your ResourceAdapter instances if you happen to use multiple adapters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"In some environments (e.g. WebLogic 9 or above), the entire ResourceAdapter object may be obtained from JNDI instead (using <jee:jndi-lookup>). The Spring-based message listeners can then interact with the server-hosted ResourceAdapter, also using the server's built-in WorkManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Please consult the JavaDoc for JmsMessageEndpointManager, JmsActivationSpecConfig, and ResourceAdapterFactoryBean for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Spring also provides a generic JCA message endpoint manager which is not tied to JMS: org.springframework.jca.endpoint.GenericMessageEndpointManager. This component allows for using any message listener type (e.g. a CCI MessageListener) and any provider-specific ActivationSpec object. Check out your JCA provider's documentation to find out about the actual capabilities of your connector, and consult GenericMessageEndpointManager's JavaDoc for the Spring-specific configuration details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans; it uses the same underlying resource provider contract. Like with EJB 2.1 MDBs, any message listener interface supported by your JCA provider can be used in the Spring context as well. Spring nevertheless provides explicit 'convenience' support for JMS, simply because JMS is the most common endpoint API used with the JCA endpoint management contract.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
Spring 2.5 introduces an XML namespace for simplifying JMS configuration. To use the JMS namespace elements you will need to reference the JMS schema:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The namespace consists of two top-level elements: <listener-container/> and <jca-listener-container/> both of which may contain one or more <listener/> child elements. Here is an example of a basic configuration for two listeners.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The example above is equivalent to creating two distinct listener container bean definitions and two distinct MessageListenerAdapter bean definitions as demonstrated in Section 23.4.4, “The MessageListenerAdapter”. In addition to the attributes shown above, the listener element may contain several optional ones. The following table describes all available attributes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"A bean name for the hosting listener container. If not specified, a bean name will be automatically generated.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The destination name for this listener, resolved through the DestinationResolver strategy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"One of the advantages of Hessian and Burlap is that we can easily apply HTTP basic authentication, because both protocols are HTTP-based. Your normal HTTP server security mechanism can easily be applied through using the web.xml security features, for example. Usually, you don't use per-user security credentials here, but rather shared credentials defined at the Hessian/BurlapProxyFactoryBean level (similar to a JDBC DataSource).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
This is an example where we explicitly mention the BeanNameUrlHandlerMapping and set an interceptor allowing only administrators and operators to call the beans mentioned in this application context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Of course, this example doesn't show a flexible kind of security infrastructure. For more options as far as security is concerned, have a look at the Spring Security project at http://static.springsource.org/spring-security/site/.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"As opposed to Burlap and Hessian, which are both lightweight protocols using their own slim serialization mechanisms, Spring HTTP invokers use the standard Java serialization mechanism to expose services through HTTP. This has a huge advantage if your arguments and return types are complex types that cannot be serialized using the serialization mechanisms Hessian and Burlap use (refer to the next section for more considerations when choosing a remoting technology).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Under the hood, Spring uses either the standard facilities provided by J2SE to perform HTTP calls or Commons HttpClient. Use the latter if you need more advanced and easy-to-use functionality. Refer to jakarta.apache.org/commons/httpclient for more info.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Setting up the HTTP invoker infrastructure for a service object resembles closely the way you would do the same using Hessian or Burlap. Just as Hessian support provides the HessianServiceExporter, Spring's HttpInvoker support provides the org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"To expose the AccountService (mentioned above) within a Spring Web MVC DispatcherServlet, the following configuration needs to be in place in the dispatcher's application context:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Such an exporter definition will be exposed through the DispatcherServlet's standard mapping facilities, as explained in the section on Hessian.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Alternatively, create an HttpInvokerServiceExporter in your root application context (e.g. in 'WEB-INF/applicationContext.xml'):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In addition, define a corresponding servlet for this exporter in 'web.xml', with the servlet name matching the bean name of the target exporter:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"If you are running outside of a servlet container and are using Sun's Java 6, then you can use the built-in HTTP server implementation. You can configure the SimpleHttpServerFactoryBean together with a SimpleHttpInvokerServiceExporter as is shown in this example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Again, linking in the service from the client much resembles the way you would do it when using Hessian or Burlap. Using a proxy, Spring will be able to translate your calls to HTTP POST requests to the URL pointing to the exported service.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"As mentioned before, you can choose what HTTP client you want to use. By default, the HttpInvokerProxy uses the J2SE HTTP functionality, but you can also use the Commons HttpClient by setting the httpInvokerRequestExecutor property:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Spring provides full support for standard Java web services APIs:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Why two standard Java web services APIs?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"JAX-RPC 1.1 is the standard web service API in J2EE 1.4. As its name indicates, it focuses on on RPC bindings, which became less and less popular in the past couple of years. As a consequence, it has been superseded by JAX-WS 2.0 in Java EE 5, being more flexible in terms of bindings but also being heavily annotation-based. JAX-WS 2.1 is also included in Java 6 (or more specifically, in Sun's JDK 1.6.0_04 and above; previous Sun JDK 1.6.0 releases included JAX-WS 2.0), integrated with the JDK's built-in HTTP server.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring can work with both standard Java web services APIs. On Java EE 5 / Java 6, the obvious choice is JAX-WS. On J2EE 1.4 environments that run on Java 5, you might have the option to plug in a JAX-WS provider; check your Java EE server's documentation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In addition to stock support for JAX-RPC and JAX-WS in Spring Core, the Spring portfolio also features Spring Web Services, a solution for contract-first, document-driven web services - highly recommended for building modern, future-proof web services.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring provides a convenience base class for JAX-RPC servlet endpoint implementations - ServletEndpointSupport. To expose our AccountService we extend Spring's ServletEndpointSupport class and implement our business logic here, usually delegating the call to the business layer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Our AccountServletEndpoint needs to run in the same web application as the Spring context to allow for access to Spring's facilities. In case of Axis, copy the AxisServlet definition into your 'web.xml', and set up the endpoint in 'server-config.wsdd' (or use the deploy tool). See the sample application JPetStore where the OrderService is exposed as a web service using Axis.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring provides two factory beans to create JAX-RPC web service proxies, namely LocalJaxRpcServiceFactoryBean and JaxRpcPortProxyFactoryBean. The former can only return a JAX-RPC service class for us to work with. The latter is the full-fledged version that can return a proxy that implements our business service interface. In this example we use the latter to create a proxy for the AccountService endpoint we exposed in the previous section. You will see that Spring has great support for web services requiring little coding efforts - most of the setup is done in the Spring configuration file as usual:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Where serviceInterface is our remote business interface the clients will use. wsdlDocumentUrl is the URL for the WSDL file. Spring needs this at startup time to create the JAX-RPC Service. namespaceUri corresponds to the targetNamespace in the .wsdl file. serviceName corresponds to the service name in the .wsdl file. portName corresponds to the port name in the .wsdl file.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Accessing the web service is now very easy as we have a bean factory for it that will expose it as RemoteAccountService interface. We can wire this up in Spring:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"From the client code we can access the web service just as if it was a normal class, except that it throws RemoteException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
We can get rid of the checked RemoteException since Spring supports automatic conversion to its corresponding unchecked RemoteException. This requires that we provide a non-RMI interface also. Our configuration is now:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Where serviceInterface is changed to our non RMI interface. Our RMI interface is now defined using the property portInterface. Our client code can now avoid handling java.rmi.RemoteException:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Note that you can also drop the ""portInterface"" part and specify a plain business interface as ""serviceInterface"". In this case, JaxRpcPortProxyFactoryBean will automatically switch to the JAX-RPC ""Dynamic Invocation Interface"", performing dynamic invocations without a fixed port stub. The advantage is that you don't even need to have an RMI-compliant Java port interface around (e.g. in case of a non-Java target web service); all you need is a matching business interface. Check out JaxRpcPortProxyFactoryBean's javadoc for details on the runtime implications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
To transfer complex objects over the wire such as Account we must register bean mappings on the client side.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (pre-processors, post-processors, controllers) will be executed in order to prepare a model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"If a model is returned, the view is rendered, using the view resolver that has been configured with the WebApplicationContext. If no model is returned (which could be due to a pre- or post-processor intercepting the request, for example, for security reasons), no view is rendered, since the request could already have been fulfilled.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Exceptions that are thrown during processing of the request get picked up by any of the handler exception resolvers that are declared in the WebApplicationContext. Using these exception resolvers you can define custom behavior in case such exceptions get thrown.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
You can customize Spring's DispatcherPortlet by adding context parameters in the portlet.xml file or portlet init-parameters. The possibilities are listed below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The rendering process in Portlet MVC is a bit more complex than in Web MVC. In order to reuse all the view technologies from Spring Web MVC, we must convert the PortletRequest / PortletResponse to HttpServletRequest / HttpServletResponse and then call the render method of the View. To do this, DispatcherPortlet uses a special servlet that exists for just this purpose: the ViewRendererServlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"In order for DispatcherPortlet rendering to work, you must declare an instance of the ViewRendererServlet in the web.xml file for your web application as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"To perform the actual rendering, DispatcherPortlet does the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Binds the WebApplicationContext to the request as an attribute under the same WEB_APPLICATION_CONTEXT_ATTRIBUTE key that DispatcherServlet uses.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Binds the Model and View objects to the request to make them available to the ViewRendererServlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Constructs a PortletRequestDispatcher and performs an include using the /WEB- INF/servlet/view URL that is mapped to the ViewRendererServlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The ViewRendererServlet is then able to call the render method on the View with the appropriate arguments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The actual URL for the ViewRendererServlet can be changed using DispatcherPortlet’s viewRendererUrl configuration parameter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The controllers in Portlet MVC are very similar to the Web MVC Controllers, and porting code from one to the other should be simple.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The basis for the Portlet MVC controller architecture is the org.springframework.web.portlet.mvc.Controller interface, which is listed below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"As you can see, the Portlet Controller interface requires two methods that handle the two phases of a portlet request: the action request and the render request. The action phase should be capable of handling an action request, and the render phase should be capable of handling a render request and returning an appropriate model and view. While the Controller interface is quite abstract, Spring Portlet MVC offers several controllers that already contain a lot of the functionality you might need; most of these are very similar to controllers from Spring Web MVC. The Controller interface just defines the most common functionality required of every controller: handling an action request, handling a render request, and returning a model and a view.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Of course, just a Controller interface isn't enough. To provide a basic infrastructure, all of Spring Portlet MVC's Controllers inherit from AbstractController, a class offering access to Spring's ApplicationContext and control over caching.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The requireSession and cacheSeconds properties are declared on the PortletContentGenerator class, which is the superclass of AbstractController) but are included here for completeness.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"When using the AbstractController as a base class for your controllers (which is not recommended since there are a lot of other controllers that might already do the job for you) you only have to override either the handleActionRequestInternal(ActionRequest, ActionResponse) method or the handleRenderRequestInternal(RenderRequest, RenderResponse) method (or both), implement your logic, and return a ModelAndView object (in the case of handleRenderRequestInternal).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The default implementations of both handleActionRequestInternal(..) and handleRenderRequestInternal(..) throw a PortletException. This is consistent with the behavior of GenericPortlet from the JSR- 168 Specification API. So you only need to override the method that your controller is intended to handle.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Here is short example consisting of a class and a declaration in the web application context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The class above and the declaration in the web application context is all you need besides setting up a handler mapping (see Section 20.5, “Handler mappings”) to get this very simple controller working.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Although you can extend AbstractController, Spring Portlet MVC provides a number of concrete implementations which offer functionality that is commonly used in simple MVC applications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The ParameterizableViewController is basically the same as the example above, except for the fact that you can specify the view name that it will return in the web application context (no need to hard-code the view name).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The PortletModeNameViewController uses the current mode of the portlet as the view name. So, if your portlet is in View mode (i.e. PortletMode.VIEW) then it uses ""view"" as the view name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Spring Portlet MVC has the exact same hierarchy of command controllers as Spring Web MVC. They provide a way to interact with data objects and dynamically bind parameters from the PortletRequest to the data object specified. Your data objects don't have to implement a framework-specific interface, so you can directly manipulate your persistent objects if you desire. Let's examine what command controllers are available, to get an overview of what you can do with them:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"AbstractCommandController - a command controller you can use to create your own command controller, capable of binding request parameters to a data object you specify. This class does not offer form functionality, it does however offer validation features and lets you specify in the controller itself what to do with the command object that has been filled with the parameters from the request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"AbstractFormController - an abstract controller offering form submission support. Using this controller you can model forms and populate them using a command object you retrieve in the controller. After a user has filled the form, AbstractFormController binds the fields, validates, and hands the object back to the controller to take appropriate action. Supported features are: invalid form submission (resubmission), validation, and normal form workflow. You implement methods to determine which views are used for form presentation and success. Use this controller if you need forms, but don't want to specify what views you're going to show the user in the application context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"SimpleFormController - a concrete AbstractFormController that provides even more support when creating a form with a corresponding command object. The SimpleFormController lets you specify a command object, a viewname for the form, a viewname for the page you want to show the user when form submission has succeeded, and more.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"AbstractWizardFormController – a concrete AbstractFormController that provides a wizard-style interface for editing the contents of a command object across multiple display pages. Supports multiple user actions: finish, cancel, or page change, all of which are easily specified in request parameters from the view.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The depends-on attribute in the bean definition can specify both an initialization time dependency and, in the case of singleton beans only, a corresponding destroy time dependency. Dependent beans that define a depends-on relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus depends-on can also control shutdown order.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In XML, this behavior is controlled by the lazy-init attribute on the <bean/> element; for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When the preceding configuration is consumed by an ApplicationContext, the bean named lazy is not eagerly pre-instantiated when the ApplicationContext is starting up, whereas the not.lazy bean is eagerly pre-instantiated.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the ApplicationContext creates the lazy-initialized bean at startup, because it must satisfy the singleton's dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also control lazy-initialization at the container level by using the default-lazy-init attribute on the <beans/> element; for example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The Spring container can autowire relationships between collaborating beans. You can allow Spring to resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When using XML-based configuration metadata[2], you specify autowire mode for a bean definition with the autowire attribute of the <bean/> element. The autowiring functionality has five modes. You specify autowiring per bean and thus can choose which ones to autowire.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"(Default) No autowiring. Bean references must be defined via a ref element. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name, and it contains a master property (that is, it has a setMaster(..) method), Spring looks for a bean definition named master, and uses it to set the property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Allows a property to be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use byType autowiring for that bean. If there are no matching beans, nothing happens; the property is not set.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Analogous to byType, but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With byType or constructor autowiring mode, you can wire arrays and typed-collections. In such cases all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed Maps if the expected key type is String. An autowired Maps values will consist of all bean instances that match the expected type, and the Maps keys will contain the corresponding bean names.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can combine autowire behavior with dependency checking, which is performed after autowiring completes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Consider the limitations and disadvantages of autowiring:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Explicit dependencies in property and constructor-arg settings always override autowiring. You cannot autowire so-called simple properties such as primitives, Strings, and Classes (and arrays of such simple properties). This limitation is by-design.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Autowiring is less exact than explicit wiring. Although, as noted in the above table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Wiring information may not be available to tools that may generate documentation from a Spring container.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the latter scenario, you have several options:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Abandon autowiring in favor of explicit wiring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Avoid autowiring for a bean definition by setting its autowire-candidate attributes to false as described in the next section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Designate a single bean definition as the primary candidate by setting the primary attribute of its <bean/> element to true.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration, as described in Section 5.9, “Annotation-based container configuration”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A more general and extremely powerful auto proxy creator is DefaultAdvisorAutoProxyCreator. This will automagically apply eligible advisors in the current context, without the need to include specific bean names in the auto-proxy advisor's bean definition. It offers the same merit of consistent configuration and avoidance of duplication as BeanNameAutoProxyCreator.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Using this mechanism involves:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Specifying a DefaultAdvisorAutoProxyCreator bean definition.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Specifying any number of Advisors in the same or related contexts. Note that these must be Advisors, not just interceptors or other advices. This is necessary because there must be a pointcut to evaluate, to check the eligibility of each advice to candidate bean definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The DefaultAdvisorAutoProxyCreator will automatically evaluate the pointcut contained in each advisor, to see what (if any) advice it should apply to each business object (such as ""businessObject1"" and ""businessObject2"" in the example).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This means that any number of advisors can be applied automatically to each business object. If no pointcut in any of the advisors matches any method in a business object, the object will not be proxied. As bean definitions are added for new business objects, they will automatically be proxied if necessary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Autoproxying in general has the advantage of making it impossible for callers or dependencies to obtain an un-advised object. Calling getBean(""businessObject1"") on this ApplicationContext will return an AOP proxy, not the target business object. (The ""inner bean"" idiom shown earlier also offers this benefit.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The DefaultAdvisorAutoProxyCreator is very useful if you want to apply the same advice consistently to many business objects. Once the infrastructure definitions are in place, you can simply add new business objects without including specific proxy configuration. You can also drop in additional aspects very easily - for example, tracing or performance monitoring aspects - with minimal change to configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The DefaultAdvisorAutoProxyCreator offers support for filtering (using a naming convention so that only certain advisors are evaluated, allowing use of multiple, differently configured, AdvisorAutoProxyCreators in the same factory) and ordering. Advisors can implement the org.springframework.core.Ordered interface to ensure correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used in the above example has a configurable order value; the default setting is unordered.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This is the superclass of DefaultAdvisorAutoProxyCreator. You can create your own auto-proxy creators by subclassing this class, in the unlikely event that advisor definitions offer insufficient customization to the behavior of the framework DefaultAdvisorAutoProxyCreator.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"A particularly important type of auto-proxying is driven by metadata. This produces a similar programming model to .NET ServicedComponents. Instead of defining metadata in XML descriptors, configuration for transaction management and other enterprise services is held in source-level attributes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"In this case, you use the DefaultAdvisorAutoProxyCreator, in combination with Advisors that understand metadata attributes. The metadata specifics are held in the pointcut part of the candidate advisors, rather than in the auto-proxy creation class itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This is really a special case of the DefaultAdvisorAutoProxyCreator, but deserves consideration on its own. (The metadata-aware code is in the pointcuts contained in the advisors, not the AOP framework itself.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The /attributes directory of the JPetStore sample application shows the use of attribute-driven auto-proxying. In this case, there's no need to use the TransactionProxyFactoryBean. Simply defining transactional attributes on business objects is sufficient, because of the use of metadata-aware pointcuts. The bean definitions include the following code, in /WEB-INF/declarativeServices.xml. Note that this is generic, and can be used outside the JPetStore:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The DefaultAdvisorAutoProxyCreator bean definition (the name is not significant, hence it can even be omitted) will pick up all eligible pointcuts in the current application context. In this case, the ""transactionAdvisor"" bean definition, of type TransactionAttributeSourceAdvisor, will apply to classes or methods carrying a transaction attribute. The TransactionAttributeSourceAdvisor depends on a TransactionInterceptor, via constructor dependency. The example resolves this via autowiring. The AttributesTransactionAttributeSource depends on an implementation of the org.springframework.metadata.Attributes interface. In this fragment, the ""attributes"" bean satisfies this, using the Jakarta Commons Attributes API to obtain attribute information. (The application code must have been compiled using the Commons Attributes compilation task.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The /annotation directory of the JPetStore sample application contains an analogous example for auto-proxying driven by JDK 1.5+ annotations. The following configuration enables automatic detection of Spring's Transactional annotation, leading to implicit proxies for beans containing that annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The TransactionInterceptor defined here depends on a PlatformTransactionManager definition, which is not included in this generic file (although it could be) because it will be specific to the application's transaction requirements (typically JTA, as in this example, or Hibernate, JDO or JDBC):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If you require only declarative transaction management, using these generic XML definitions will result in Spring automatically proxying all classes or methods with transaction attributes. You won't need to work directly with AOP, and the programming model is similar to that of .NET ServicedComponents.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
This mechanism is extensible. It's possible to do auto-proxying based on custom attributes. You need to:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Define your custom attribute.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Specify an Advisor with the necessary advice, including a pointcut that is triggered by the presence of the custom attribute on a class or method. You may be able to use an existing advice, merely implementing a static pointcut that picks up the custom attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"It's possible for such advisors to be unique to each advised class (for example, mixins): they simply need to be defined as prototype, rather than singleton, bean definitions. For example, the LockMixin introduction interceptor from the Spring test suite, shown above, could be used in conjunction with an attribute-driven pointcut to target a mixin, as shown here. We use the generic DefaultPointcutAdvisor, configured using JavaBean properties:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If the attribute aware pointcut matches any methods in the anyBean or other bean definitions, the mixin will be applied. Note that both lockMixin and lockableAdvisor definitions are prototypes. The myAttributeAwarePointcut pointcut can be a singleton definition, as it doesn't hold state for individual advised objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"An ApplicationContext can be uniquely identified by the combination of configuration parameters that are used to load it. Consequently, the unique combination of configuration parameters are used to generate a key under which the context is cached. The TestContext framework uses the following configuration parameters to build the context cache key:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
locations (from @ContextConfiguration),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
classes (from @ContextConfiguration),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
contextInitializerClasses (from @ContextConfiguration),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
contextLoader (from @ContextConfiguration),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
activeProfiles (from @ActiveProfiles),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
resourceBasePath (from @WebAppConfiguration),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"For example, if TestClassA specifies {""app-config.xml"", ""test-config.xml""} for the locations (or value) attribute of @ContextConfiguration, the TestContext framework will load the corresponding ApplicationContext and store it in a static context cache under a key that is based solely on those locations. So if TestClassB also defines {""app-config.xml"", ""test-config.xml""} for its locations (either explicitly or implicitly through inheritance) but does not define @WebAppConfiguration, a different ContextLoader, different active profiles, or different context initializers, then the same ApplicationContext will be shared by both test classes. This means that the setup cost for loading an application context is incurred only once (per test suite), and subsequent test execution is much faster.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a static variable. In other words, if tests execute in separate processes the static cache will be cleared between each test execution, and this will effectively disable the caching mechanism.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To benefit from the caching mechanism, all tests must run within the same process or test suite. This can be achieved by executing all tests as a group within an IDE. Similarly, when executing tests with a build framework such as Ant, Maven, or Gradle it is important to make sure that the build framework does not fork between tests. For example, if the forkMode for the Maven Surefire plug-in is set to always or pertest, the TestContext framework will not be able to cache application contexts between test classes and the build process will run significantly slower as a result.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the unlikely case that a test corrupts the application context and requires reloading — for example, by modifying a bean definition or the state of an application object — you can annotate your test class or test method with @DirtiesContext (see the discussion of @DirtiesContext in the section called “Spring Testing Annotations”). This instructs Spring to remove the context from the cache and rebuild the application context before executing the next test. Note that support for the @DirtiesContext annotation is provided by the DirtiesContextTestExecutionListener which is enabled by default.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When writing integration tests that rely on a loaded Spring ApplicationContext, it is often sufficient to test against a single context; however, there are times when it is beneficial or even necessary to test against a hierarchy of ApplicationContexts. For example, if you are developing a Spring MVC web application you will typically have a root WebApplicationContext loaded via Spring's ContextLoaderListener and a child WebApplicationContext loaded via Spring's DispatcherServlet. This results in a parent-child context hierarchy where shared components and infrastructure configuration are declared in the root context and consumed in the child context by web-specific components. Another use case can be found in Spring Batch applications where you often have a parent context that provides configuration for shared batch infrastructure and a child context for the configuration of a specific batch job.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As of Spring Framework 3.2.2, it is possible to write integration tests that use context hierarchies by declaring context configuration via the @ContextHierarchy annotation, either on an individual test class or within a test class hierarchy. If a context hierarchy is declared on multiple classes within a test class hierarchy it is also possible to merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration for a given level in the hierarchy the configuration resource type (i.e., XML configuration files or annotated classes) must be consistent; otherwise, it is perfectly acceptable to have different levels in a context hierarchy configured using different resource types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following JUnit-based examples demonstrate common configuration scenarios for integration tests that require the use of context hierarchies.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"ControllerIntegrationTests represents a typical integration testing scenario for a Spring MVC web application by declaring a context hierarchy consisting of two levels, one for the root WebApplicationContext (loaded using the TestAppConfig @Configuration class) and one for the dispatcher servlet WebApplicationContext (loaded using the WebConfig @Configuration class). The WebApplicationContext that is autowired into the test instance is the one for the child context (i.e., the lowest context in the hierarchy).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following test classes define a context hierarchy within a test class hierarchy. AbstractWebTests declares the configuration for a root WebApplicationContext in a Spring-powered web application. Note, however, that AbstractWebTests does not declare @ContextHierarchy; consequently, subclasses of AbstractWebTests can optionally participate in a context hierarchy or simply follow the standard semantics for @ContextConfiguration. SoapWebServiceTests and RestWebServiceTests both extend AbstractWebTests and define a context hierarchy via @ContextHierarchy. The result is that three application contexts will be loaded (one for each declaration of @ContextConfiguration), and the application context loaded based on the configuration in AbstractWebTests will be set as the parent context for each of the contexts loaded for the concrete subclasses.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following classes demonstrate the use of named hierarchy levels in order to merge the configuration for specific levels in a context hierarchy. BaseTests defines two levels in the hierarchy, parent and child. ExtendedTests extends BaseTests and instructs the Spring TestContext Framework to merge the context configuration for the child hierarchy level, simply by ensuring that the names declared via ContextConfiguration's name attribute are both ""child"". The result is that three application contexts will be loaded: one for ""/app-config.xml"", one for ""/user-config.xml"", and one for {""/user-config.xml"", ""/order-config.xml""}. As with the previous example, the application context loaded from ""/app-config.xml"" will be set as the parent context for the contexts loaded from ""/user-config.xml"" and {""/user-config.xml"", ""/order-config.xml""}.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In contrast to the previous example, this example demonstrates how to override the configuration for a given named level in a context hierarchy by setting ContextConfiguration's inheritLocations flag to false. Consequently, the application context for ExtendedTests will be loaded only from ""/test-user-config.xml"" and will have its parent set to the context loaded from ""/app-config.xml"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If @DirtiesContext is used in a test whose context is configured as part of a context hierarchy, the hierarchyMode flag can be used to control how the context cache is cleared. For further details consult the discussion of @DirtiesContext in the section called “Spring Testing Annotations” and the Javadoc for @DirtiesContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When you use the DependencyInjectionTestExecutionListener — which is configured by default — the dependencies of your test instances are injected from beans in the application context that you configured with @ContextConfiguration. You may use setter injection, field injection, or both, depending on which annotations you choose and whether you place them on setter methods or fields. For consistency with the annotation support introduced in Spring 2.5 and 3.0, you can use Spring's @Autowired annotation or the @Inject annotation from JSR 300.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The TestContext framework does not instrument the manner in which a test instance is instantiated. Thus the use of @Autowired or @Inject for constructors has no effect for test classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Because @Autowired is used to perform autowiring by type , if you have multiple bean definitions of the same type, you cannot rely on this approach for those particular beans. In that case, you can use @Autowired in conjunction with @Qualifier. As of Spring 3.0 you may also choose to use @Inject in conjunction with @Named. Alternatively, if your test class has access to its ApplicationContext, you can perform an explicit lookup by using (for example) a call to applicationContext.getBean(""titleRepository"").",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The bean backing the aspect (""aBean"" in this case) can of course be configured and dependency injected just like any other Spring bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"A named pointcut can be declared inside an <aop:config> element, enabling the pointcut definition to be shared across several aspects and advisors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
A pointcut representing the execution of any business service in the service layer could be defined as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that the pointcut expression itself is using the same AspectJ pointcut expression language as described in Section 9.2, “@AspectJ support”. If you are using the schema based declaration style with Java 5, you can refer to named pointcuts defined in types (@Aspects) within the pointcut expression, but this feature is not available on JDK 1.4 and below (it relies on the Java 5 specific AspectJ reflection APIs). On JDK 1.5 therefore, another way of defining the above pointcut would be:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Assuming you have a SystemArchitecture aspect as described in the section called “Sharing common pointcut definitions”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Much the same way in an @AspectJ aspect, pointcuts declared using the schema based definition style may collect join point context. For example, the following pointcut collects the 'this' object as the join point context and passes it to advice:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The advice must be declared to receive the collected join point context by including parameters of the matching names:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When combining pointcut sub-expressions, '&&' is awkward within an XML document, and so the keywords 'and', 'or' and 'not' can be used in place of '&&', '||' and '!' respectively. For example, the previous pointcut may be better written as:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Note that pointcuts defined in this way are referred to by their XML id and cannot be used as named pointcuts to form composite pointcuts. The named pointcut support in the schema based definition style is thus more limited than that offered by the @AspectJ style.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The same five advice kinds are supported as for the @AspectJ style, and they have exactly the same semantics.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Before advice runs before a matched method execution. It is declared inside an <aop:aspect> using the <aop:before> element.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Here dataAccessOperation is the id of a pointcut defined at the top (<aop:config>) level. To define the pointcut inline instead, replace the pointcut-ref attribute with a pointcut attribute:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"As we noted in the discussion of the @AspectJ style, using named pointcuts can significantly improve the readability of your code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The method attribute identifies a method (doAccessCheck) that provides the body of the advice. This method must be defined for the bean referenced by the aspect element containing the advice. Before a data access operation is executed (a method execution join point matched by the pointcut expression), the ""doAccessCheck"" method on the aspect bean will be invoked.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After returning advice runs when a matched method execution completes normally. It is declared inside an <aop:aspect> in the same way as before advice. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Just as in the @AspectJ style, it is possible to get hold of the return value within the advice body. Use the returning attribute to specify the name of the parameter to which the return value should be passed:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The doAccessCheck method must declare a parameter named retVal. The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, the method signature may be declared as:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After throwing advice executes when a matched method execution exits by throwing an exception. It is declared inside an <aop:aspect> using the after-throwing element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Just as in the @AspectJ style, it is possible to get hold of the thrown exception within the advice body. Use the throwing attribute to specify the name of the parameter to which the exception should be passed:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The doRecoveryActions method must declare a parameter named dataAccessEx. The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
After (finally) advice runs however a matched method execution exits. It is declared using the after element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The final kind of advice is around advice. Around advice runs ""around"" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements; don't use around advice if simple before advice would do.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Around advice is declared using the aop:around element. The first parameter of the advice method must be of type ProceedingJoinPoint. Within the body of the advice, calling proceed() on the ProceedingJoinPoint causes the underlying method to execute. The proceed method may also be calling passing in an Object[] - the values in the array will be used as the arguments to the method execution when it proceeds. See the section called “Around advice” for notes on calling proceed with an Object[].",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"An example of radio buttons in FTL is below. The form backing object specifies a default value of 'London' for this field and so no validation is necessary. When the form is rendered, the entire list of cities to choose from is supplied as reference data in the model under the name 'cityMap'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If your application expects to handle cities by internal codes for example, the map of codes would be created with suitable keys like the example below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The code would now produce output where the radio values are the relevant codes but the user still sees the more user friendly city names.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Default usage of the form macros above will result in HTML tags that are HTML 4.01 compliant and that use the default value for HTML escaping defined in your web.xml as used by Spring's bind support. In order to make the tags XHTML compliant or to override the default HTML escaping value, you can specify two variables in your template (or in your model where they will be visible to your templates). The advantage of specifying them in the templates is that they can be changed to different values later in the template processing to provide different behavior for different fields in your form.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"To switch to XHTML compliance for your tags, specify a value of 'true' for a model/context variable named xhtmlCompliant:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Any tags generated by the Spring macros will now be XHTML compliant after processing this directive.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In similar fashion, HTML escaping can be specified per field:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"XSLT is a transformation language for XML and is popular as a view technology within web applications. XSLT can be a good choice as a view technology if your application naturally deals with XML, or if your model can easily be converted to XML. The following section shows how to produce an XML document as model data and have it transformed with XSLT in a Spring Web MVC application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This example is a trivial Spring application that creates a list of words in the Controller and adds them to the model map. The map is returned along with the view name of our XSLT view. See Section 17.3, “Implementing Controllers” for details of Spring Web MVC's Controller interface. The XSLT view will turn the list of words into a simple XML document ready for transformation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Configuration is standard for a simple Spring application. The dispatcher servlet config file contains a reference to a ViewResolver, URL mappings and a single controller bean...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
... that encapsulates our word generation logic.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The controller logic is encapsulated in a subclass of AbstractController, with the handler method being defined like so...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"So far we've done nothing that's XSLT specific. The model data has been created in the same way as you would for any other Spring MVC application. Depending on the configuration of the application now, that list of words could be rendered by JSP/JSTL by having them added as request attributes, or they could be handled by Velocity by adding the object to the VelocityContext. In order to have XSLT render them, they of course have to be converted into an XML document somehow. There are software packages available that will automatically 'domify' an object graph, but within Spring, you have complete flexibility to create the DOM from your model in any way you choose. This prevents the transformation of XML playing too great a part in the structure of your model data which is a danger when using tools to manage the domification process.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In order to create a DOM document from our list of words or any other model data, we must subclass the (provided) org.springframework.web.servlet.view.xslt.AbstractXsltView class. In doing so, we must also typically implement the abstract method createXsltSource(..) method. The first parameter passed to this method is our model map. Here's the complete listing of the HomePage class in our trivial word application:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"A series of parameter name/value pairs can optionally be defined by your subclass which will be added to the transformation object. The parameter names must match those defined in your XSLT template declared with <xsl:param name=""myParam"">defaultValue</xsl:param>. To specify the parameters, override the getParameters() method of the AbstractXsltView class and return a Map of the name/value pairs. If your parameters need to derive information from the current request, you can override the getParameters(HttpServletRequest request) method instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The views.properties file (or equivalent xml definition if you're using an XML based view resolver as we did in the Velocity examples above) looks like this for the one-view application that is 'My First Words':,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here, you can see how the view is tied in with the HomePage class just written which handles the model domification in the first property '.(class)'. The 'stylesheetLocation' property points to the XSLT file which will handle the XML transformation into HTML for us and the final property '.root' is the name that will be used as the root of the XML document. This gets passed to the HomePage class above in the second parameter to the createXsltSource(..) method(s).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Finally, we have the XSLT code used for transforming the above document. As shown in the above 'views.properties' file, the stylesheet is called 'home.xslt' and it lives in the war file in the 'WEB-INF/xsl' directory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
A summary of the files discussed and their location in the WAR file is shown in the simplified WAR structure below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"You will also need to ensure that an XML parser and an XSLT engine are available on the classpath. JDK 1.4 provides them by default, and most Java EE containers will also make them available by default, but it's a possible source of errors to be aware of.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Returning an HTML page isn't always the best way for the user to view the model output, and Spring makes it simple to generate a PDF document or an Excel spreadsheet dynamically from the model data. The document is the view and will be streamed from the server with the correct content type to (hopefully) enable the client PC to run their spreadsheet or PDF viewer application in response.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In order to use Excel views, you need to add the 'poi' library to your classpath, and for PDF generation, the iText library.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Document based views are handled in an almost identical fashion to XSLT views, and the following sections build upon the previous one by demonstrating how the same controller used in the XSLT example is invoked to render the same model as both a PDF document and an Excel spreadsheet (which can also be viewed or manipulated in Open Office).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"No matter how the LTW is configured, using this technique, JPA applications relying on instrumentation can run in the target platform (ex: Tomcat) without needing an agent. This is important especially when the hosting applications rely on different JPA implementations because the JPA transformers are applied only at class loader level and thus are isolated from each other.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"For applications that rely on multiple persistence units locations, stored in various JARS in the classpath, for example, Spring offers the PersistenceUnitManager to act as a central repository and to avoid the persistence units discovery process, which can be expensive. The default implementation allows multiple locations to be specified that are parsed and later retrieved through the persistence unit name. (By default, the classpath is searched for META-INF/persistence.xml files.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The default implementation allows customization of the PersistenceUnitInfo instances, before they are fed to the JPA provider, declaratively through its properties, which affect all hosted units, or programmatically, through the PersistenceUnitPostProcessor, which allows persistence unit selection. If no PersistenceUnitManager is specified, one is created and used internally by LocalContainerEntityManagerFactoryBean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Although EntityManagerFactory instances are thread-safe, EntityManager instances are not. The injected JPA EntityManager behaves like an EntityManager fetched from an application server's JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional EntityManager, if any; otherwise, it falls back to a newly created EntityManager per operation, in effect making its usage thread-safe.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"It is possible to write code against the plain JPA without any Spring dependencies, by using an injected EntityManagerFactory or EntityManager. Spring can understand @PersistenceUnit and @PersistenceContext annotations both at field and method level if a PersistenceAnnotationBeanPostProcessor is enabled. A plain JPA DAO implementation using the @PersistenceUnit annotation might look like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The DAO above has no dependency on Spring and still fits nicely into a Spring application context. Moreover, the DAO takes advantage of annotations to require the injection of the default EntityManagerFactory:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As an alternative to defining a PersistenceAnnotationBeanPostProcessor explicitly, consider using the Spring context:annotation-config XML element in your application context configuration. Doing so automatically registers all Spring standard post-processors for annotation-based configuration, including CommonAnnotationBeanPostProcessor and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The main problem with such a DAO is that it always creates a new EntityManager through the factory. You can avoid this by requesting a transactional EntityManager (also called ""shared EntityManager"" because it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the factory:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The @PersistenceContext annotation has an optional attribute type, which defaults to PersistenceContextType.TRANSACTION. This default is what you need to receive a shared EntityManager proxy. The alternative, PersistenceContextType.EXTENDED, is a completely different affair: This results in a so-called extended EntityManager, which is not thread-safe and hence must not be used in a concurrently accessed component such as a Spring-managed singleton bean. Extended EntityManagers are only supposed to be used in stateful components that, for example, reside in a session, with the lifecycle of the EntityManager not tied to a current transaction but rather being completely up to the application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Annotations that indicate dependency injections (such as @PersistenceUnit and @PersistenceContext) can be applied on field or methods inside a class, hence the expressions method-level injection and field-level injection. Field-level annotations are concise and easier to use while method-level allows for further processing of the injected dependency. In both cases the member visibility (public, protected, private) does not matter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
What about class-level annotations?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"On the Java EE 5 platform, they are used for dependency declaration and not for resource injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The injected EntityManager is Spring-managed (aware of the ongoing transaction). It is important to note that even though the new DAO implementation uses method level injection of an EntityManager instead of an EntityManagerFactory, no change is required in the application context XML due to annotation usage.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The main advantage of this DAO style is that it only depends on Java Persistence API; no import of any Spring class is required. Moreover, as the JPA annotations are understood, the injections are applied automatically by the Spring container. This is appealing from a non-invasiveness perspective, and might feel more natural to JPA developers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"You are strongly encouraged to read Section 12.5, “Declarative transaction management” if you have not done so, to get a more detailed coverage of Spring's declarative transaction support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"To execute service operations within transactions, you can use Spring's common declarative transaction facilities. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Spring JPA allows a configured JpaTransactionManager to expose a JPA transaction to JDBC access code that accesses the same JDBC DataSource, provided that the registered JpaDialect supports retrieval of the underlying JDBC Connection. Out of the box, Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA implementations. See the next section for details on the JpaDialect mechanism.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"As an advanced feature JpaTemplate, JpaTransactionManager and subclasses of AbstractEntityManagerFactoryBean support a custom JpaDialect, to be passed into the jpaDialect bean property. In such a scenario, the DAOs do not receive an EntityManagerFactory reference but rather a full JpaTemplate instance (for example, passed into the jpaTemplate property of JpaDaoSupport). A JpaDialect implementation can enable some advanced features supported by Spring, usually in a vendor-specific manner:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Applying specific transaction semantics such as custom isolation level or transaction timeout),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Retrieving the transactional JDBC Connection for exposure to JDBC-based DAOs),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"This is particularly valuable for special transaction semantics and for advanced translation of exception. The default implementation used (DefaultJpaDialect) does not provide any special capabilities and if the above features are required, you have to specify the appropriate dialect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The execute method used here takes a plain java.utils.Map as its only parameter. The important thing to note here is that the keys used for the Map must match the column names of the table as defined in the database. This is because we read the metadata in order to construct the actual insert statement.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This example uses the same insert as the preceding, but instead of passing in the id it retrieves the auto-generated key and sets it on the new Actor object. When you create the SimpleJdbcInsert, in addition to specifying the table name, you specify the name of the generated key column with the usingGeneratedKeyColumns method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The main difference when executing the insert by this second approach is that you do not add the id to the Map and you call the executeAndReturnKey method. This returns a java.lang.Number object with which you can create an instance of the numerical type that is used in our domain class.You cannot rely on all databases to return a specific Java class here; java.lang.Number is the base class that you can rely on. If you have multiple auto-generated columns, or the generated values are non-numeric, then you can use a KeyHolder that is returned from the executeAndReturnKeyHolder method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
You can limit the columns for an insert by specifying a list of column names with the usingColumns method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The execution of the insert is the same as if you had relied on the metadata to determine which columns to use.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Using a Map to provide parameter values works fine, but it's not the most convenient class to use. Spring provides a couple of implementations of the SqlParameterSource interface that can be used instead.The first one is BeanPropertySqlParameterSource, which is a very convenient class if you have a JavaBean-compliant class that contains your values. It will use the corresponding getter method to extract the parameter values. Here is an example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Another option is the MapSqlParameterSource that resembles a Map but provides a more convenient addValue method that can be chained.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"As you can see, the configuration is the same; only the executing code has to change to use these alternative input classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SimpleJdbcCall class leverages metadata in the database to look up names of in and out parameters, so that you do not have to declare them explicitly. You can declare parameters if you prefer to do that, or if you have parameters such as ARRAY or STRUCT that do not have an automatic mapping to a Java class. The first example shows a simple procedure that returns only scalar values in VARCHAR and DATE format from a MySQL database. The example procedure reads a specified actor entry and returns first_name, last_name, and birth_date columns in the form of out parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The in_id parameter contains the id of the actor you are looking up. The out parameters return the data read from the table.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SimpleJdbcCall is declared in a similar manner to the SimpleJdbcInsert. You should instantiate and configure the class in the initialization method of your data access layer. Compared to the StoredProcedure class, you don't have to create a subclass and you don't have to declare parameters that can be looked up in the database metadata. Following is an example of a SimpleJdbcCall configuration using the above stored procedure. The only configuration option, in addition to the DataSource, is the name of the stored procedure.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The code you write for the execution of the call involves creating an SqlParameterSource containing the IN parameter. It's important to match the name provided for the input value with that of the parameter name declared in the stored procedure. The case does not have to match because you use metadata to determine how database objects should be referred to in a stored procedure. What is specified in the source for the stored procedure is not necessarily the way it is stored in the database. Some databases transform names to all upper case while others use lower case or use the case as specified.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The execute method takes the IN parameters and returns a Map containing any out parameters keyed by the name as specified in the stored procedure. In this case they are out_first_name, out_last_name and out_birth_date.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The last part of the execute method creates an Actor instance to use to return the data retrieved. Again, it is important to use the names of the out parameters as they are declared in the stored procedure. Also, the case in the names of the out parameters stored in the results map matches that of the out parameter names in the database, which could vary between databases. To make your code more portable you should do a case-insensitive lookup or instruct Spring to use a CaseInsensitiveMap from the Jakarta Commons project. To do the latter, you create your own JdbcTemplate and set the setResultsMapCaseInsensitive property to true. Then you pass this customized JdbcTemplate instance into the constructor of your SimpleJdbcCall. You must include the commons-collections.jar in your classpath for this to work. Here is an example of this configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"By taking this action, you avoid conflicts in the case used for the names of your returned out parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You have seen how the parameters are deduced based on metadata, but you can declare then explicitly if you wish. You do this by creating and configuring SimpleJdbcCall with the declareParameters method, which takes a variable number of SqlParameter objects as input. See the next section for details on how to define an SqlParameter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Explicit declarations are necessary if the database you use is not a Spring-supported database. Currently Spring supports metadata lookup of stored procedure calls for the following databases: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase. We also support metadata lookup of stored functions for: MySQL, Microsoft SQL Server, and Oracle.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You can opt to declare one, some, or all the parameters explicitly. The parameter metadata is still used where you do not declare parameters explicitly. To bypass all processing of metadata lookups for potential parameters and only use the declared parameters, you call the method withoutProcedureColumnMetaDataAccess as part of the declaration. Suppose that you have two or more different call signatures declared for a database function. In this case you call the useInParameterNames to specify the list of IN parameter names to include for a given signature.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The following example shows a fully declared procedure call, using the information from the preceding example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The execution and end results of the two examples are the same; this one specifies all details explicitly rather than relying on metadata.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"To define a parameter for the SimpleJdbc classes and also for the RDBMS operations classes, covered in Section 14.6, “Modeling JDBC operations as Java objects”, you use an SqlParameter or one of its subclasses. You typically specify the parameter name and SQL type in the constructor. The SQL type is specified using the java.sql.Types constants. We have already seen declarations like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
An @RequestMapping handler method can have a very flexible signatures. The supported method arguments and return values are described in the following section. Most arguments can be used in arbitrary order with the only exception of BindingResult arguments. This is described in the next section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring 3.1 introduced a new set of support classes for @RequestMapping methods called RequestMappingHandlerMapping and RequestMappingHandlerAdapter respectively. They are recommended for use and even required to take advantage of new features in Spring MVC 3.1 and going forward. The new support classes are enabled by default from the MVC namespace and with use of the MVC Java config but must be configured explicitly if using neither.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following are the supported method arguments:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Request or response objects (Servlet API). Choose any specific request or response type, for example ServletRequest or HttpServletRequest.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Session object (Servlet API): of type HttpSession. An argument of this type enforces the presence of a corresponding session. As a consequence, such an argument is never null.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Session access may not be thread-safe, in particular in a Servlet environment. Consider setting the RequestMappingHandlerAdapter's ""synchronizeOnSession"" flag to ""true"" if multiple requests are allowed to access a session concurrently.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"java.util.Locale for the current request locale, determined by the most specific locale resolver available, in effect, the configured LocaleResolver in a Servlet environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
java.io.InputStream / java.io.Reader for access to the request's content. This value is the raw InputStream/Reader as exposed by the Servlet API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
java.io.OutputStream / java.io.Writer for generating the response's content. This value is the raw OutputStream/Writer as exposed by the Servlet API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
java.security.Principal containing the currently authenticated user.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@PathVariable annotated parameters for access to URI template variables. See the section called “URI Template Patterns”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@MatrixVariable annotated parameters for access to name-value pairs located in URI path segments. See the section called “Matrix Variables”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@RequestParam annotated parameters for access to specific Servlet request parameters. Parameter values are converted to the declared method argument type. See the section called “Binding request parameters to method parameters with @RequestParam”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@RequestHeader annotated parameters for access to specific Servlet request HTTP headers. Parameter values are converted to the declared method argument type.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@RequestBody annotated parameters for access to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the request body with the @RequestBody annotation”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"@RequestPart annotated parameters for access to the content of a ""multipart/form-data"" request part. See Section 17.10.5, “Handling a file upload request from programmatic clients” and Section 17.10, “Spring's multipart (file upload) support”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The request stream will be converted to the entity body using HttpMessageConverters. See the section called “Using HttpEntity<?>”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the web view.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the exact set of attributes to use in case of a redirect and also to add flash attributes (attributes stored temporarily on the server-side to make them available to the request after the redirect). RedirectAttributes is used instead of the implicit model if the method returns a ""redirect:"" prefixed view name or RedirectView.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Command or form objects to bind request parameters to bean properties (via setters) or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on RequestMappingHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default, using the command class class name - e.g. model attribute ""orderAddress"" for a command object of type ""some.package.OrderAddress"". The ModelAttribute annotation can be used on a method argument to customize the model attribute name used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
org.springframework.validation.Errors / org.springframework.validation.BindingResult validation results for a preceding command or form object (the immediately preceding method argument).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete, which triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Exception(s) that trigger rollback; comma-delimited. For example, com.foo.MyBusinessException,ServletException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Exception(s) that do not trigger rollback; comma-delimited. For example, com.foo.MyBusinessException,ServletException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In addition to the XML-based declarative approach to transaction configuration, you can use an annotation-based approach. Declaring transaction semantics directly in the Java source code puts the declarations much closer to the affected code. There is not much danger of undue coupling, because code that is meant to be used transactionally is almost always deployed that way anyway.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The ease-of-use afforded by the use of the @Transactional annotation is best illustrated with an example, which is explained in the text that follows. Consider the following class definition:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When the above POJO is defined as a bean in a Spring IoC container, the bean instance can be made transactional by adding merely one line of XML configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can omit the transaction-manager attribute in the <tx:annotation-driven/> tag if the bean name of the PlatformTransactionManager that you want to wire in has the name transactionManager. If the PlatformTransactionManager bean that you want to dependency-inject has any other name, then you have to use the transaction-manager attribute explicitly, as in the preceding example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The @EnableTransactionManagement annotation provides equivalent support if you are using Java based configuration. Simply add the annotation to a @Configuration class. See Javadoc for full details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When using proxies, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can place the @Transactional annotation before an interface definition, a method on an interface, a class definition, or a public method on a class. However, the mere presence of the @Transactional annotation is not enough to activate the transactional behavior. The @Transactional annotation is simply metadata that can be consumed by some runtime infrastructure that is @Transactional-aware and that can use the metadata to configure the appropriate beans with transactional behavior. In the preceding example, the <tx:annotation-driven/> element switches on the transactional behavior.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed to annotating interfaces. You certainly can place the @Transactional annotation on an interface (or an interface method), but this works only as you would expect it to if you are using interface-based proxies. The fact that Java annotations are not inherited from interfaces means that if you are using class-based proxies (proxy-target-class=""true"") or the weaving-based aspect (mode=""aspectj""), then the transaction settings are not recognized by the proxying and weaving infrastructure, and the object will not be wrapped in a transactional proxy, which would be decidedly bad.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation, in effect, a method within the target object calling another method of the target object, will not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Consider the use of AspectJ mode (see mode attribute in table below) if you expect self-invocations to be wrapped with transactions as well. In this case, there will not be a proxy in the first place; instead, the target class will be weaved (that is, its byte code will be modified) in order to turn @Transactional into runtime behavior on any kind of method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Name of transaction manager to use. Only required if the name of the transaction manager is not transactionManager, as in the example above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The default mode ""proxy"" processes annotated beans to be proxied using Spring's AOP framework (following proxy semantics, as discussed above, applying to method calls coming in through the proxy only). The alternative mode ""aspectj"" instead weaves the affected classes with Spring's AspectJ transaction aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See the section called “Spring configuration” for details on how to set up load-time weaving.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If the proxy-target-class attribute is set to true, then class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, then standard JDK interface-based proxies are created. (See Section 9.6, “Proxying mechanisms” for a detailed examination of the different proxy types.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Defines the order of the transaction advice that is applied to beans annotated with @Transactional. (For more information about the rules related to ordering of AOP advice, see the section called “Advice ordering”.) No specified ordering means that the AOP subsystem determines the order of the advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The proxy-target-class attribute controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If proxy-target-class is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based proxies are created. (See Section 9.6, “Proxying mechanisms” for a discussion of the different proxy types.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"@EnableTransactionManagement and <tx:annotation-driven/> only looks for @Transactional on beans in the same application context they are defined in. This means that, if you put annotation driven configuration in a WebApplicationContext for a DispatcherServlet, it only checks for @Transactional beans in your controllers, and not your services. See Section 17.2, “The DispatcherServlet” for more information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The most derived location takes precedence when evaluating the transactional settings for a method. In the case of the following example, the DefaultFooService class is annotated at the class level with the settings for a read-only transaction, but the @Transactional annotation on the updateFoo(Foo) method in the same class takes precedence over the transactional settings defined at the class level.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The @Transactional annotation is metadata that specifies that an interface, class, or method must have transactional semantics; for example, “start a brand new read-only transaction when this method is invoked, suspending any existing transaction”. The default @Transactional settings are as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Propagation setting is PROPAGATION_REQUIRED.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The bean name of the handler object.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The name of the handler method to invoke. If the ref points to a MessageListener or Spring SessionAwareMessageListener, this attribute may be omitted.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The name of the default response destination to send response messages to. This will be applied in case of a request message that does not carry a ""JMSReplyTo"" field. The type of this destination will be determined by the listener-container's ""destination-type"" attribute. Note: This only applies to a listener method with a return value, for which each result object will be converted into a response message.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The name of the durable subscription, if any.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
An optional message selector for this listener.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The <listener-container/> element also accepts several optional attributes. This allows for customization of the various strategies (for example, taskExecutor and destinationResolver) as well as basic JMS settings and resource references. Using these attributes, it is possible to define highly-customized listener containers while still benefiting from the convenience of the namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The following table describes all available attributes. Consult the class-level Javadoc of the AbstractMessageListenerContainer and its concrete subclasses for more details on the individual properties. The Javadoc also provides a discussion of transaction choices and message redelivery scenarios.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The type of this listener container. Available options are: default, simple, default102, or simple102 (the default value is 'default').",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the JMS ConnectionFactory bean (the default bean name is 'connectionFactory').,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the Spring TaskExecutor for the JMS listener invokers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the DestinationResolver strategy for resolving JMS Destinations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. Default is a SimpleMessageConverter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The JMS destination type for this listener: queue, topic or durableTopic. The default is queue.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The JMS client id for this listener container. Needs to be specified when using durable subscriptions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The cache level for JMS resources: none, connection, session, consumer or auto. By default (auto), the cache level will effectively be ""consumer"", unless an external transaction manager has been specified - in which case the effective default will be none (assuming Java EE-style transaction management where the given ConnectionFactory is an XA-aware pool).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The native JMS acknowledge mode: auto, client, dups-ok or transacted. A value of transacted activates a locally transacted Session. As an alternative, specify the transaction-manager attribute described below. Default is auto.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"A reference to an external PlatformTransactionManager (typically an XA-based transaction coordinator, e.g. Spring's JtaTransactionManager). If not specified, native acknowledging will be used (see ""acknowledge"" attribute).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The number of concurrent sessions/consumers to start for each listener. Can either be a simple number indicating the maximum number (e.g. ""5"") or a range indicating the lower as well as the upper limit (e.g. ""3-5""). Note that a specified minimum is just a hint and might be ignored at runtime. Default is 1; keep concurrency limited to 1 in case of a topic listener or if queue ordering is important; consider raising it for general queues.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers!,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"Configuring a JCA-based listener container with the ""jms"" schema support is very similar.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The available configuration options for the JCA variant are described in the following table:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the JCA ResourceAdapter bean (the default bean name is 'resourceAdapter').,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the JmsActivationSpecFactory. The default is to autodetect the JMS provider and its ActivationSpec class (see DefaultJmsActivationSpecFactory),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the DestinationResolver strategy for resolving JMS Destinations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. Default is a SimpleMessageConverter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The JMS destination type for this listener: queue, topic or durableTopic. The default is queue.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
On the server side using Axis registering bean mappings is usually done in the 'server-config.wsdd' file.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
We will use Axis to register bean mappings on the client side. To do this we need to register the bean mappings programmatically:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In this section we will register our own javax.rpc.xml.handler.Handler to the web service proxy where we can do custom code before the SOAP message is sent over the wire. The Handler is a callback interface. There is a convenience base class provided in jaxrpc.jar, namely javax.rpc.xml.handler.GenericHandler that we will extend:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"What we need to do now is to register our AccountHandler to JAX-RPC Service so it would invoke handleRequest(..) before the message is sent over the wire. Spring has at this time of writing no declarative support for registering handlers, so we must use the programmatic approach. However Spring has made it very easy for us to do this as we can override the postProcessJaxRpcService(..) method that is designed for this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The last thing we must remember to do is to change the Spring configuration to use our factory bean:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring provides a convenient base class for JAX-WS servlet endpoint implementations - SpringBeanAutowiringSupport. To expose our AccountService we extend Spring's SpringBeanAutowiringSupport class and implement our business logic here, usually delegating the call to the business layer. We'll simply use Spring 2.5's @Autowired annotation for expressing such dependencies on Spring-managed beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Our AccountServletEndpoint needs to run in the same web application as the Spring context to allow for access to Spring's facilities. This is the case by default in Java EE 5 environments, using the standard contract for JAX-WS servlet endpoint deployment. See Java EE 5 web service tutorials for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The built-in JAX-WS provider that comes with Sun's JDK 1.6 supports exposure of web services using the built-in HTTP server that's included in JDK 1.6 as well. Spring's SimpleJaxWsServiceExporter detects all @WebService annotated beans in the Spring application context, exporting them through the default JAX-WS server (the JDK 1.6 HTTP server).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In this scenario, the endpoint instances are defined and managed as Spring beans themselves; they will be registered with the JAX-WS engine but their lifecycle will be up to the Spring application context. This means that Spring functionality like explicit dependency injection may be applied to the endpoint instances. Of course, annotation-driven injection through @Autowired will work as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The AccountServiceEndpoint may derive from Spring's SpringBeanAutowiringSupport but doesn't have to since the endpoint is a fully Spring-managed bean here. This means that the endpoint implementation may look like as follows, without any superclass declared - and Spring's @Autowired configuration annotation still being honored:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Sun's JAX-WS RI, developed as part of the GlassFish project, ships Spring support as part of its JAX-WS Commons project. This allows for defining JAX-WS endpoints as Spring-managed beans, similar to the standalone mode discussed in the previous section - but this time in a Servlet environment. Note that this is not portable in a Java EE 5 environment; it is mainly intended for non-EE environments such as Tomcat, embedding the JAX-WS RI as part of the web application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The difference to the standard style of exporting servlet-based endpoints is that the lifecycle of the endpoint instances themselves will be managed by Spring here, and that there will be only one JAX-WS servlet defined in web.xml. With the standard Java EE 5 style (as illustrated above), you'll have one servlet definition per service endpoint, with each endpoint typically delegating to Spring beans (through the use of @Autowired, as shown above).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Check out https://jax-ws-commons.java.net/spring/ for the details on setup and usage style.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Analogous to the JAX-RPC support, Spring provides two factory beans to create JAX-WS web service proxies, namely LocalJaxWsServiceFactoryBean and JaxWsPortProxyFactoryBean. The former can only return a JAX-WS service class for us to work with. The latter is the full-fledged version that can return a proxy that implements our business service interface. In this example we use the latter to create a proxy for the AccountService endpoint (again):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Where serviceInterface is our business interface the clients will use. wsdlDocumentUrl is the URL for the WSDL file. Spring needs this a startup time to create the JAX-WS Service. namespaceUri corresponds to the targetNamespace in the .wsdl file. serviceName corresponds to the service name in the .wsdl file. portName corresponds to the port name in the .wsdl file.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Accessing the web service is now very easy as we have a bean factory for it that will expose it as AccountService interface. We can wire this up in Spring:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
From the client code we can access the web service just as if it was a normal class:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"NOTE: The above is slightly simplified in that JAX-WS requires endpoint interfaces and implementation classes to be annotated with @WebService, @SOAPBinding etc annotations. This means that you cannot (easily) use plain Java interfaces and implementation classes as JAX-WS endpoint artifacts; you need to annotate them accordingly first. Check the JAX-WS documentation for details on those requirements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"It is also possible to expose services transparently using JMS as the underlying communication protocol. The JMS remoting support in the Spring Framework is pretty basic - it sends and receives on the same thread and in the same non-transactional Session, and as such throughput will be very implementation dependent. Note that these single-threaded and non-transactional constraints apply only to Spring's JMS remoting support. See Chapter 23, JMS (Java Message Service) for information on Spring's rich support for JMS-based messaging.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The following interface is used on both the server and the client side.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The following simple implementation of the above interface is used on the server-side.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
This configuration file contains the JMS-infrastructure beans that are shared on both the client and server.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"On the server, you just need to expose the service object using the JmsInvokerServiceExporter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The client merely needs to create a client-side proxy that will implement the agreed upon interface (CheckingAccountService). The resulting object created off the back of the following bean definition can be injected into other client side objects, and the proxy will take care of forwarding the call to the server-side object via JMS.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"These command controllers are quite powerful, but they do require a detailed understanding of how they operate in order to use them efficiently. Carefully review the Javadocs for this entire hierarchy and then look at some sample implementations before you start using them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Instead of developing new controllers, it is possible to use existing portlets and map requests to them from a DispatcherPortlet. Using the PortletWrappingController, you can instantiate an existing Portlet as a Controller as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"This can be very valuable since you can then use interceptors to pre-process and post-process requests going to these portlets. Since JSR-286 does not support any kind of filter mechanism, this is quite handy. For example, this can be used to wrap the Hibernate OpenSessionInViewInterceptor around a MyFaces JSF Portlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Using a handler mapping you can map incoming portlet requests to appropriate handlers. There are some handler mappings you can use out of the box, for example, the PortletModeHandlerMapping, but let's first examine the general concept of a HandlerMapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Note: We are intentionally using the term “Handler” here instead of “Controller”. DispatcherPortlet is designed to be used with other ways to process requests than just Spring Portlet MVC’s own Controllers. A Handler is any Object that can handle portlet requests. Controllers are an example of Handlers, and they are of course the default. To use some other framework with DispatcherPortlet, a corresponding implementation of HandlerAdapter is all that is needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The functionality a basic HandlerMapping provides is the delivering of a HandlerExecutionChain, which must contain the handler that matches the incoming request, and may also contain a list of handler interceptors that are applied to the request. When a request comes in, the DispatcherPortlet will hand it over to the handler mapping to let it inspect the request and come up with an appropriate HandlerExecutionChain. Then the DispatcherPortlet will execute the handler and interceptors in the chain (if any). These concepts are all exactly the same as in Spring Web MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The concept of configurable handler mappings that can optionally contain interceptors (executed before or after the actual handler was executed, or both) is extremely powerful. A lot of supporting functionality can be built into a custom HandlerMapping. Think of a custom handler mapping that chooses a handler not only based on the portlet mode of the request coming in, but also on a specific state of the session associated with the request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"In Spring Web MVC, handler mappings are commonly based on URLs. Since there is really no such thing as a URL within a Portlet, we must use other mechanisms to control mappings. The two most common are the portlet mode and a request parameter, but anything available to the portlet request can be used in a custom handler mapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The rest of this section describes three of Spring Portlet MVC's most commonly used handler mappings. They all extend AbstractHandlerMapping and share the following properties:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"interceptors: The list of interceptors to use. HandlerInterceptors are discussed in Section 20.5.4, “Adding HandlerInterceptors”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"defaultHandler: The default handler to use, when this handler mapping does not result in a matching handler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"order: Based on the value of the order property (see the org.springframework.core.Ordered interface), Spring will sort all handler mappings available in the context and apply the first matching handler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
lazyInitHandlers: Allows for lazy initialization of singleton handlers (prototype handlers are always lazily initialized). Default value is false. This property is directly implemented in the three concrete Handlers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"This is a simple handler mapping that maps incoming requests based on the current mode of the portlet (e.g. ‘view’, ‘edit’, ‘help’). An example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"If we need to navigate around to multiple controllers without changing portlet mode, the simplest way to do this is with a request parameter that is used as the key to control the mapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"ParameterHandlerMapping uses the value of a specific request parameter to control the mapping. The default name of the parameter is 'action', but can be changed using the 'parameterName' property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The bean configuration for this mapping will look something like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The most powerful built-in handler mapping, PortletModeParameterHandlerMapping combines the capabilities of the two previous ones to allow different navigation within each portlet mode.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Again the default name of the parameter is ""action"", but can be changed using the parameterName property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"By default, the same parameter value may not be used in two different portlet modes. This is so that if the portal itself changes the portlet mode, the request will no longer be valid in the mapping. This behavior can be changed by setting the allowDupParameters property to true. However, this is not recommended.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The bean configuration for this mapping will look something like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"This mapping can be chained ahead of a PortletModeHandlerMapping, which can then provide defaults for each mode and an overall default as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Spring's handler mapping mechanism has a notion of handler interceptors, which can be extremely useful when you want to apply specific functionality to certain requests, for example, checking for a principal. Again Spring Portlet MVC implements these concepts in the same way as Web MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Interceptors located in the handler mapping must implement HandlerInterceptor from the org.springframework.web.portlet package. Just like the servlet version, this interface defines three methods: one that will be called before the actual handler will be executed (preHandle), one that will be called after the handler is executed (postHandle), and one that is called after the complete request has finished (afterCompletion). These three methods should provide enough flexibility to do all kinds of pre- and post- processing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The preHandle method returns a boolean value. You can use this method to break or continue the processing of the execution chain. When this method returns true, the handler execution chain will continue. When it returns false, the DispatcherPortlet assumes the interceptor itself has taken care of requests (and, for example, rendered an appropriate view) and does not continue executing the other interceptors and the actual handler in the execution chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"On a per-bean basis, you can exclude a bean from autowiring. In Spring's XML format, set the autowire-candidate attribute of the <bean/> element to false; the container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as @Autowired).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can also limit autowire candidates based on pattern-matching against bean names. The top-level <beans/> element accepts one or more patterns within its default-autowire-candidates attribute. For example, to limit autowire candidate status to any bean whose name ends with Repository, provide a value of *Repository. To provide multiple patterns, define them in a comma-separated list. An explicit value of true or false for a bean definitions autowire-candidate attribute always takes precedence, and for such beans, the pattern matching rules do not apply.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean, or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container only creates the singleton bean A once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(""B"") call to the container ask for (a typically new) bean B instance every time bean A needs it. The following is an example of this approach:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, allows this use case to be handled in a clean fashion.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can read more about the motivation for Method Injection in this blog entry.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Lookup method injection is the ability of the container to override methods on container managed beans, to return the lookup result for another named bean in the container. The lookup typically involves a prototype bean as in the scenario described in the preceding section. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For this dynamic subclassing to work, the class that the Spring container will subclass cannot be final, and the method to be overridden cannot be final either. Also, testing a class that has an abstract method requires you to subclass the class yourself and to supply a stub implementation of the abstract method. Finally, objects that have been the target of method injection cannot be serialized. As of Spring 3.2 it is no longer necessary to add CGLIB to your classpath, because CGLIB classes are repackaged under org.springframework and distributed within the spring-core JAR. This is done both for convenience as well as to avoid potential conflicts with other projects that use differing versions of CGLIB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Looking at the CommandManager class in the previous code snippet, you see that the Spring container will dynamically override the implementation of the createCommand() method. Your CommandManager class will not have any Spring dependencies, as can be seen in the reworked example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the client class containing the method to be injected (the CommandManager in this case), the method to be injected requires a signature of the following form:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If the method is abstract, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The bean identified as commandManager calls its own method createCommand() whenever it needs a new instance of the command bean. You must be careful to deploy the command bean as a prototype, if that is actually what is needed. If it is deployed as a singleton, the same instance of the command bean is returned each time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The interested reader may also find the ServiceLocatorFactoryBean (in the org.springframework.beans.factory.config package) to be of use. The approach used in ServiceLocatorFactoryBean is similar to that of another utility class, ObjectFactoryCreatingFactoryBean, but it allows you to specify your own lookup interface as opposed to a Spring-specific lookup interface. Consult the JavaDocs for these classes as well as this blog entry for additional information ServiceLocatorFactoryBean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A less useful form of method injection than lookup method Injection is the ability to replace arbitrary methods in a managed bean with another method implementation. Users may safely skip the rest of this section until the functionality is actually needed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With XML-based configuration metadata, you can use the replaced-method element to replace an existing method implementation with another, for a deployed bean. Consider the following class, with a method computeValue, which we want to override:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A class implementing the org.springframework.beans.factory.support.MethodReplacer interface provides the new method definition.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The bean definition to deploy the original class and specify the method override would look like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can use one or more contained <arg-type/> elements within the <replaced-method/> element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match java.lang.String:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by allowing you to type only the shortest string that will match an argument type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring offers the concept of a TargetSource, expressed in the org.springframework.aop.TargetSource interface. This interface is responsible for returning the ""target object"" implementing the join point. The TargetSource implementation is asked for a target instance each time the AOP proxy handles a method invocation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Developers using Spring AOP don't normally need to work directly with TargetSources, but this provides a powerful means of supporting pooling, hot swappable and other sophisticated targets. For example, a pooling TargetSource can return a different target instance for each invocation, using a pool to manage instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If you do not specify a TargetSource, a default implementation is used that wraps a local object. The same target is returned for each invocation (as you would expect).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Let's look at the standard target sources provided with Spring, and how you can use them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"When using a custom target source, your target will usually need to be a prototype rather than a singleton bean definition. This allows Spring to create a new target instance when required.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The org.springframework.aop.target.HotSwappableTargetSource exists to allow the target of an AOP proxy to be switched while allowing callers to keep their references to it.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Changing the target source's target takes effect immediately. The HotSwappableTargetSource is threadsafe.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
You can change the target via the swap() method on HotSwappableTargetSource as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The XML definitions required look as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"The above swap() call changes the target of the swappable bean. Clients who hold a reference to that bean will be unaware of the change, but will immediately start hitting the new target.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Although this example doesn't add any advice - and it's not necessary to add advice to use a TargetSource - of course any TargetSource can be used in conjunction with arbitrary advice.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Using a pooling target source provides a similar programming model to stateless session EJBs, in which a pool of identical instances is maintained, with method invocations going to free objects in the pool.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can be applied to any POJO. As with Spring in general, this service can be applied in a non-invasive way.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring provides out-of-the-box support for Jakarta Commons Pool 1.3, which provides a fairly efficient pooling implementation. You'll need the commons-pool Jar on your application's classpath to use this feature. It's also possible to subclass org.springframework.aop.target.AbstractPoolingTargetSource to support any other pooling API.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Sample configuration is shown below:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Note that the target object - ""businessObjectTarget"" in the example - must be a prototype. This allows the PoolingTargetSource implementation to create new instances of the target to grow the pool as necessary. See the javadoc for AbstractPoolingTargetSource and the concrete subclass you wish to use for information about its properties: ""maxSize"" is the most basic, and always guaranteed to be present.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"In this case, ""myInterceptor"" is the name of an interceptor that would need to be defined in the same IoC context. However, it isn't necessary to specify interceptors to use pooling. If you want only pooling, and no other advice, don't set the interceptorNames property at all.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"It's possible to configure Spring so as to be able to cast any pooled object to the org.springframework.aop.target.PoolingConfig interface, which exposes information about the configuration and current size of the pool through an introduction. You'll need to define an advisor like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"This advisor is obtained by calling a convenience method on the AbstractPoolingTargetSource class, hence the use of MethodInvokingFactoryBean. This advisor's name (""poolConfigAdvisor"" here) must be in the list of interceptors names in the ProxyFactoryBean exposing the pooled object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The cast will look as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Pooling stateless service objects is not usually necessary. We don't believe it should be the default choice, as most stateless objects are naturally thread safe, and instance pooling is problematic if resources are cached.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Simpler pooling is available using auto-proxying. It's possible to set the TargetSources used by any auto-proxy creator.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Setting up a ""prototype"" target source is similar to a pooling TargetSource. In this case, a new instance of the target will be created on every method invocation. Although the cost of creating a new object isn't high in a modern JVM, the cost of wiring up the new object (satisfying its IoC dependencies) may be more expensive. Thus you shouldn't use this approach without very good reason.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"To do this, you could modify the poolTargetSource definition shown above as follows. (I've also changed the name, for clarity.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"There's only one property: the name of the target bean. Inheritance is used in the TargetSource implementations to ensure consistent naming. As with the pooling target source, the target bean must be a prototype bean definition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
ThreadLocal target sources are useful if you need an object to be created for each incoming request (per thread that is). The concept of a ThreadLocal provide a JDK-wide facility to transparently store resource alongside a thread. Setting up a ThreadLocalTargetSource is pretty much the same as was explained for the other types of target source:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"ThreadLocals come with serious issues (potentially resulting in memory leaks) when incorrectly using them in a multi-threaded and multi-classloader environments. One should always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal itself (except of course in the wrapper class). Also, one should always remember to correctly set and unset (where the latter simply involved a call to ThreadLocal.set(null)) the resource local to the thread. Unsetting should be done in any case since not unsetting it might result in problematic behavior. Spring's ThreadLocal support does this for you and should always be considered in favor of using ThreadLocals without other proper handling code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"Spring AOP is designed to be extensible. While the interception implementation strategy is presently used internally, it is possible to support arbitrary advice types in addition to the out-of-the-box interception around advice, before, throws advice and after returning advice.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"If you do not want dependency injection applied to your test instances, simply do not annotate fields or setter methods with @Autowired or @Inject. Alternatively, you can disable dependency injection altogether by explicitly configuring your class with @TestExecutionListeners and omitting DependencyInjectionTestExecutionListener.class from the list of listeners.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Consider the scenario of testing a HibernateTitleRepository class, as outlined in the Goals section. The next two code listings demonstrate the use of @Autowired on fields and setter methods. The application context configuration is presented after all sample code listings.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The dependency injection behavior in the following code listings is not specific to JUnit. The same DI techniques can be used in conjunction with any testing framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following examples make calls to static assertion methods such as assertNotNull() but without prepending the call with Assert. In such cases, assume that the method was properly imported through an import static declaration that is not shown in the example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The first code listing shows a JUnit-based implementation of the test class that uses @Autowired for field injection.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Alternatively, you can configure the class to use @Autowired for setter injection as seen below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The preceding code listings use the same XML context file referenced by the @ContextConfiguration annotation (that is, repository-config.xml), which looks like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If you are extending from a Spring-provided test base class that happens to use @Autowired on one of its setter methods, you might have multiple beans of the affected type defined in your application context: for example, multiple DataSource beans. In such a case, you can override the setter method and use the @Qualifier annotation to indicate a specific target bean as follows, but make sure to delegate to the overridden method in the superclass as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The specified qualifier value indicates the specific DataSource bean to inject, narrowing the set of type matches to a specific bean. Its value is matched against <qualifier> declarations within the corresponding <bean> definitions. The bean name is used as a fallback qualifier value, so you may effectively also point to a specific bean by name there (as shown above, assuming that ""myDataSource"" is the bean id).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Request and session scoped beans have been supported by Spring for several years now, but it's always been a bit non-trivial to test them. As of Spring 3.2 it's now a breeze to test your request-scoped and session-scoped beans by following these steps.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Ensure that a WebApplicationContext is loaded for your test by annotating your test class with @WebAppConfiguration.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Inject the mock request or session into your test instance and prepare your test fixture as appropriate.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Invoke your web component that you retrieved from the configured WebApplicationContext (i.e., via dependency injection).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Perform assertions against the mocks.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following code snippet displays the XML configuration for a login use case. Note that the userService bean has a dependency on a request-scoped loginAction bean. Also, the LoginAction is instantiated using SpEL expressions that retrieve the username and password from the current HTTP request. In our test, we will want to configure these request parameters via the mock managed by the TestContext framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In RequestScopedBeanTests we inject both the UserService (i.e., the subject under test) and the MockHttpServletRequest into our test instance. Within our requestScope() test method we set up our test fixture by setting request parameters in the provided MockHttpServletRequest. When the loginUser() method is invoked on our userService we are assured that the user service has access to the request-scoped loginAction for the current MockHttpServletRequest (i.e., the one we just set parameters in). We can then perform assertions against the results based on the known inputs for the username and password.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The following code snippet is similar to the one we saw above for a request-scoped bean; however, this time the userService bean has a dependency on a session-scoped userPreferences bean. Note that the UserPreferences bean is instantiated using a SpEL expression that retrieves the theme from the current HTTP session. In our test, we will need to configure a theme in the mock session managed by the TestContext framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In SessionScopedBeanTests we inject the UserService and the MockHttpSession into our test instance. Within our sessionScope() test method we set up our test fixture by setting the expected ""theme"" attribute in the provided MockHttpSession. When the processUserPreferences() method is invoked on our userService we are assured that the user service has access to the session-scoped userPreferences for the current MockHttpSession, and we can perform assertions against the results based on the configured theme.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the TestContext framework, transactions are managed by the TransactionalTestExecutionListener. Note that TransactionalTestExecutionListener is configured by default, even if you do not explicitly declare @TestExecutionListeners on your test class. To enable support for transactions, however, you must provide a PlatformTransactionManager bean in the application context loaded by @ContextConfiguration semantics. In addition, you must declare @Transactional either at the class or method level for your tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"For class-level transaction configuration (i.e., setting an explicit bean name for the transaction manager and the default rollback flag), see the @TransactionConfiguration entry in the annotation support section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If transactions are not enabled for the entire test class, you can annotate methods explicitly with @Transactional. To control whether a transaction should commit for a particular test method, you can use the @Rollback annotation to override the class-level default rollback setting.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests are preconfigured for transactional support at the class level.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Occasionally you need to execute certain code before or after a transactional test method but outside the transactional context, for example, to verify the initial database state prior to execution of your test or to verify expected transactional commit behavior after test execution (if the test was configured not to roll back the transaction). TransactionalTestExecutionListener supports the @BeforeTransaction and @AfterTransaction annotations exactly for such scenarios. Simply annotate any public void method in your test class with one of these annotations, and the TransactionalTestExecutionListener ensures that your before transaction method or after transaction method is executed at the appropriate time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Any before methods (such as methods annotated with JUnit's @Before) and any after methods (such as methods annotated with JUnit's @After) are executed within a transaction. In addition, methods annotated with @BeforeTransaction or @AfterTransaction are naturally not executed for tests annotated with @NotTransactional. However, @NotTransactional is deprecated as of Spring 3.0.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The following JUnit-based example displays a fictitious integration testing scenario highlighting several transaction-related annotations. Consult the annotation support section for further information and configuration examples.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The implementation of the doBasicProfiling advice would be exactly the same as in the @AspectJ example (minus the annotation of course):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The schema based declaration style supports fully typed advice in the same way as described for the @AspectJ support - by matching pointcut parameters by name against advice method parameters. See the section called “Advice parameters” for details. If you wish to explicitly specify argument names for the advice methods (not relying on the detection strategies previously described) then this is done using the arg-names attribute of the advice element, which is treated in the same manner to the ""argNames"" attribute in an advice annotation as described in the section called “Determining argument names”. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The arg-names attribute accepts a comma-delimited list of parameter names.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Find below a slightly more involved example of the XSD-based approach that illustrates some around advice used in conjunction with a number of strongly typed parameters.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Next up is the aspect. Notice the fact that the profile(..) method accepts a number of strongly-typed parameters, the first of which happens to be the join point used to proceed with the method call: the presence of this parameter is an indication that the profile(..) is to be used as around advice:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Finally, here is the XML configuration that is required to effect the execution of the above advice for a particular join point:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If we had the following driver script, we would get output something like this on standard output:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
When multiple advice needs to execute at the same join point (executing method) the ordering rules are as described in the section called “Advice ordering”. The precedence between aspects is determined by either adding the Order annotation to the bean backing the aspect or by having the bean implement the Ordered interface.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"An introduction is made using the aop:declare-parents element inside an aop:aspect This element is used to declare that matching types have a new parent (hence the name). For example, given an interface UsageTracked, and an implementation of that interface DefaultUsageTracked, the following aspect declares that all implementors of service interfaces also implement the UsageTracked interface. (In order to expose statistics via JMX for example.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The class backing the usageTracking bean would contain the method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The interface to be implemented is determined by implement-interface attribute. The value of the types-matching attribute is an AspectJ type pattern :- any bean of a matching type will implement the UsageTracked interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the UsageTracked interface. If accessing a bean programmatically you would write the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The only supported instantiation model for schema-defined aspects is the singleton model. Other instantiation models may be supported in future releases.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The concept of ""advisors"" is brought forward from the AOP support defined in Spring 1.2 and does not have a direct equivalent in AspectJ. An advisor is like a small self-contained aspect that has a single piece of advice. The advice itself is represented by a bean, and must implement one of the advice interfaces described in Section 10.3.2, “Advice types in Spring”. Advisors can take advantage of AspectJ pointcut expressions though.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring 2.0 supports the advisor concept with the <aop:advisor> element. You will most commonly see it used in conjunction with transactional advice, which also has its own namespace support in Spring 2.0. Here's how it looks:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"As well as the pointcut-ref attribute used in the above example, you can also use the pointcut attribute to define a pointcut expression inline.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To define the precedence of an advisor so that the advice can participate in ordering, use the order attribute to define the Ordered value of the advisor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Let's see how the concurrent locking failure retry example from Section 9.2.7, “Example” looks when rewritten using the schema support.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely it will succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don't need to go back to the user for conflict resolution), we'd like to transparently retry the operation to avoid the client seeing a PessimisticLockingFailureException. This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Because we want to retry the operation, we'll need to use around advice so that we can call proceed multiple times. Here's how the basic aspect implementation looks (it's just a regular Java class using the schema support):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that the aspect implements the Ordered interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The maxRetries and order properties will both be configured by Spring. The main action happens in the doConcurrentOperation around advice method. We try to proceed, and if we fail with a PessimisticLockingFailureException we simply try again unless we have exhausted all of our retry attempts.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"This class is identical to the one used in the @AspectJ example, but with the annotations removed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The corresponding Spring configuration is:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Notice that for the time being we assume that all business services are idempotent. If this is not the case we can refine the aspect so that it only retries genuinely idempotent operations, by introducing an Idempotent annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
and using the annotation to annotate the implementation of service operations. The change to the aspect to retry only idempotent operations simply involves refining the pointcut expression so that only @Idempotent operations match:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Once you have decided that an aspect is the best approach for implementing a given requirement, how do you decide between using Spring AOP or AspectJ, and between the Aspect language (code) style, @AspectJ annotation style, or the Spring XML style? These decisions are influenced by a number of factors including application requirements, development tools, and team familiarity with AOP.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ as there is no requirement to introduce the AspectJ compiler / weaver into your development and build processes. If you only need to advise the execution of operations on Spring beans, then Spring AOP is the right choice. If you need to advise objects not managed by the Spring container (such as domain objects typically), then you will need to use AspectJ. You will also need to use AspectJ if you wish to advise join points other than simple method executions (for example, field get or set join points, and so on).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"First, let's amend the views.properties file (or xml equivalent) and add a simple view definition for both document types. The entire file now looks like this with the XSLT view shown from earlier:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The controller code we'll use remains exactly the same from the XSLT example earlier other than to change the name of the view to use. Of course, you could be clever and have this selected based on a URL parameter or some other logic - proof that Spring really is very good at decoupling the views from the controllers!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Exactly as we did for the XSLT example, we'll subclass suitable abstract classes in order to implement custom behavior in generating our output documents. For Excel, this involves writing a subclass of org.springframework.web.servlet.view.document.AbstractExcelView (for Excel files generated by POI) or org.springframework.web.servlet.view.document.AbstractJExcelView (for JExcelApi-generated Excel files) and implementing the buildExcelDocument() method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Here's the complete listing for our POI Excel view which displays the word list from the model map in consecutive rows of the first column of a new spreadsheet:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"And the following is a view generating the same Excel file, now using JExcelApi:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Note the differences between the APIs. We've found that the JExcelApi is somewhat more intuitive, and furthermore, JExcelApi has slightly better image-handling capabilities. There have been memory problems with large Excel files when using JExcelApi however.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If you now amend the controller such that it returns xl as the name of the view (return new ModelAndView(""xl"", map);) and run your application again, you should find that the Excel spreadsheet is created and downloaded automatically when you request the same page as before.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The PDF version of the word list is even simpler. This time, the class extends org.springframework.web.servlet.view.document.AbstractPdfView and implements the buildPdfDocument() method as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Once again, amend the controller to return the pdf view with return new ModelAndView(""pdf"", map);, and reload the URL in your application. This time a PDF document should appear listing each of the words in the model map.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"JasperReports (http://jasperreports.sourceforge.net) is a powerful open-source reporting engine that supports the creation of report designs using an easily understood XML file format. JasperReports is capable of rendering reports in four different formats: CSV, Excel, HTML and PDF.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Your application will need to include the latest release of JasperReports, which at the time of writing was 0.6.1. JasperReports itself depends on the following projects:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
JasperReports also requires a JAXP compliant XML parser.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
To configure JasperReports views in your Spring container configuration you need to define a ViewResolver to map view names to the appropriate view class depending on which format you want your report rendered in.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Typically, you will use the ResourceBundleViewResolver to map view names to view classes and files in a properties file.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Here we've configured an instance of the ResourceBundleViewResolver class that will look for view mappings in the resource bundle with base name views. (The content of this file is described in the next section.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The Spring Framework contains five different View implementations for JasperReports, four of which correspond to one of the four output formats supported by JasperReports, and one that allows for the format to be determined at runtime:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Mapping one of these classes to a view name and a report file is a matter of adding the appropriate entries in the resource bundle configured in the previous section as shown here:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here you can see that the view with name simpleReport is mapped to the JasperReportsPdfView class, causing the output of this report to be rendered in PDF format. The url property of the view is set to the location of the underlying report file.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"JasperReports has two distinct types of report file: the design file, which has a .jrxml extension, and the compiled report file, which has a .jasper extension. Typically, you use the JasperReports Ant task to compile your .jrxml design file into a .jasper file before deploying it into your application. With the Spring Framework you can map either of these files to your report file and the framework will take care of compiling the .jrxml file on the fly for you. You should note that after a .jrxml file is compiled by the Spring Framework, the compiled report is cached for the lifetime of the application. Thus, to make changes to the file you will need to restart your application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The JasperReportsMultiFormatView allows for the report format to be specified at runtime. The actual rendering of the report is delegated to one of the other JasperReports view classes - the JasperReportsMultiFormatView class simply adds a wrapper layer that allows for the exact implementation to be specified at runtime.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The JasperReportsMultiFormatView class introduces two concepts: the format key and the discriminator key. The JasperReportsMultiFormatView class uses the mapping key to look up the actual view implementation class, and it uses the format key to lookup up the mapping key. From a coding perspective you add an entry to your model with the format key as the key and the mapping key as the value, for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"In this example, the mapping key is determined from the extension of the request URI and is added to the model under the default format key: format. If you wish to use a different format key then you can configure this using the formatKey property of the JasperReportsMultiFormatView class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
By default the following mapping key mappings are configured in JasperReportsMultiFormatView:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
So in the example above a request to URI /foo/myReport.pdf would be mapped to the JasperReportsPdfView class. You can override the mapping key to view class mappings using the formatMappings property of JasperReportsMultiFormatView.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
See the JpaDialect Javadoc for more details of its operations and how they are used within Spring's JPA support.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The iBATIS support in the Spring Framework much resembles the JDBC support in that it supports the same template style programming, and as with JDBC and other ORM technologies, the iBATIS support works with Spring's exception hierarchy and lets you enjoy Spring's IoC features.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Transaction management can be handled through Spring's standard facilities. No special transaction strategies are necessary for iBATIS, because no special transactional resource involved other than a JDBC Connection. Hence, Spring's standard JDBC DataSourceTransactionManager or JtaTransactionManager are perfectly sufficient.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Spring supports iBATIS 2.x. The iBATIS 1.x support classes are no longer provided.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
Using iBATIS SQL Maps involves creating SqlMap configuration files containing statements and result maps. Spring takes care of loading those using the SqlMapClientFactoryBean. For the examples we will be using the following Account class:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
To map this Account class with iBATIS 2.x we need to create the following SQL map Account.xml:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The configuration file for iBATIS 2 looks like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"Remember that iBATIS loads resources from the class path, so be sure to add theAccount.xml file to the class path.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"We can use the SqlMapClientFactoryBean in the Spring container. Note that with iBATIS SQL Maps 2.x, the JDBC DataSource is usually specified on the SqlMapClientFactoryBean, which enables lazy loading. This is the configuration needed for these bean definitions:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The SqlMapClientDaoSupport class offers a supporting class similar to the SqlMapDaoSupport. We extend it to implement our DAO:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In the DAO, we use the pre-configured SqlMapClientTemplate to execute the queries, after setting up the SqlMapAccountDao in the application context and wiring it with our SqlMapClient instance:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"An SqlMapTemplate instance can also be created manually, passing in the SqlMapClient as constructor argument. The SqlMapClientDaoSupport base class simply preinitializes a SqlMapClientTemplate instance for us.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"The SqlMapClientTemplate offers a generic execute method, taking a custom SqlMapClientCallback implementation as argument. This can, for example, be used for batching:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In general, any combination of operations offered by the native SqlMapExecutor API can be used in such a callback. Any thrown SQLException is converted automatically to Spring's generic DataAccessException hierarchy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"DAOs can also be written against plain iBATIS API, without any Spring dependencies, directly using an injected SqlMapClient. The following example shows a corresponding DAO implementation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
"In this scenario, you need to handle the SQLException thrown by the iBATIS API in a custom fashion, usually by wrapping it in your own application-specific DAO exception. Wiring in the application context would still look like it does in the example for the SqlMapClientDaoSupport, due to the fact that the plain iBATIS-based DAO still follows the dependency injection pattern:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/orm.html
The first line with the SqlParameter declares an IN parameter. IN parameters can be used for both stored procedure calls and for queries using the SqlQuery and its subclasses covered in the following section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The second line with the SqlOutParameter declares an out parameter to be used in a stored procedure call. There is also an SqlInOutParameter for InOut parameters, parameters that provide an IN value to the procedure and that also return a value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Only parameters declared as SqlParameter and SqlInOutParameter will be used to provide input values. This is different from the StoredProcedure class, which for backwards compatibility reasons allows input values to be provided for parameters declared as SqlOutParameter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"For IN parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For out parameters, you can provide a RowMapper to handle mapping of rows returned from a REF cursor. Another option is to specify an SqlReturnType that provides an opportunity to define customized handling of the return values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You call a stored function in almost the same way as you call a stored procedure, except that you provide a function name rather than a procedure name. You use the withFunctionName method as part of the configuration to indicate that we want to make a call to a function, and the corresponding string for a function call is generated. A specialized execute call, executeFunction, is used to execute the function and it returns the function return value as an object of a specified type, which means you do not have to retrieve the return value from the results map. A similar convenience method named executeObject is also available for stored procedures that only have one out parameter. The following example is based on a stored function named get_actor_name that returns an actor's full name. Here is the MySQL source for this function:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
To call this function we again create a SimpleJdbcCall in the initialization method.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The execute method used returns a String containing the return value from the function call.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Calling a stored procedure or function that returns a result set is a bit tricky. Some databases return result sets during the JDBC results processing while others require an explicitly registered out parameter of a specific type. Both approaches need additional processing to loop over the result set and process the returned rows. With the SimpleJdbcCall you use the returningResultSet method and declare a RowMapper implementation to be used for a specific parameter. In the case where the result set is returned during the results processing, there are no names defined, so the returned results will have to match the order in which you declare the RowMapper implementations. The name specified is still used to store the processed list of results in the results map that is returned from the execute statement.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The next example uses a stored procedure that takes no IN parameters and returns all rows from the t_actor table. Here is the MySQL source for this procedure:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"To call this procedure you declare the RowMapper. Because the class you want to map to follows the JavaBean rules, you can use a ParameterizedBeanPropertyRowMapper that is created by passing in the required class to map to in the newInstance method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The execute call passes in an empty Map because this call does not take any parameters. The list of Actors is then retrieved from the results map and returned to the caller.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The org.springframework.jdbc.object package contains classes that allow you to access the database in a more object-oriented manner. As an example, you can execute queries and get the results back as a list containing business objects with the relational column data mapped to the properties of the business object. You can also execute stored procedures and run update, delete, and insert statements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Many Spring developers believe that the various RDBMS operation classes described below (with the exception of the StoredProcedure class) can often be replaced with straight JdbcTemplate calls. Often it is simpler to write a DAO method that simply calls a method on a JdbcTemplate directly (as opposed to encapsulating a query as a full-blown class).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"However, if you are getting measurable value from using the RDBMS operation classes, continue using these classes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"SqlQuery is a reusable, threadsafe class that encapsulates an SQL query. Subclasses must implement the newRowMapper(..) method to provide a RowMapper instance that can create one object per row obtained from iterating over the ResultSet that is created during the execution of the query. The SqlQuery class is rarely used directly because the MappingSqlQuery subclass provides a much more convenient implementation for mapping rows to Java classes. Other implementations that extend SqlQuery are MappingSqlQueryWithParameters and UpdatableSqlQuery.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
MappingSqlQuery is a reusable query in which concrete subclasses must implement the abstract mapRow(..) method to convert each row of the supplied ResultSet into an object of the type specified. The following example shows a custom query that maps the data from the t_actor relation to an instance of the Actor class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The class extends MappingSqlQuery parameterized with the Actor type. The constructor for this customer query takes the DataSource as the only parameter. In this constructor you call the constructor on the superclass with the DataSource and the SQL that should be executed to retrieve the rows for this query. This SQL will be used to create a PreparedStatement so it may contain place holders for any parameters to be passed in during execution.You must declare each parameter using the declareParameter method passing in an SqlParameter. The SqlParameter takes a name and the JDBC type as defined in java.sql.Types. After you define all parameters, you call the compile() method so the statement can be prepared and later executed. This class is thread-safe after it is compiled, so as long as these instances are created when the DAO is initialized they can be kept as instance variables and be reused.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The method in this example retrieves the customer with the id that is passed in as the only parameter. Since we only want one object returned we simply call the convenience method findObject with the id as parameter. If we had instead a query that returned a list of objects and took additional parameters then we would use one of the execute methods that takes an array of parameter values passed in as varargs.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SqlUpdate class encapsulates an SQL update. Like a query, an update object is reusable, and like all RdbmsOperation classes, an update can have parameters and is defined in SQL. This class provides a number of update(..) methods analogous to the execute(..) methods of query objects. The SQLUpdate class is concrete. It can be subclassed, for example, to add a custom update method, as in the following snippet where it's simply called execute. However, you don't have to subclass the SqlUpdate class since it can easily be parameterized by setting SQL and declaring parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The StoredProcedure class is a superclass for object abstractions of RDBMS stored procedures. This class is abstract, and its various execute(..) methods have protected access, preventing use other than through a subclass that offers tighter typing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The inherited sql property will be the name of the stored procedure in the RDBMS.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"To define a parameter for the StoredProcedure class, you use an SqlParameter or one of its subclasses. You must specify the parameter name and SQL type in the constructor like in the following code snippet. The SQL type is specified using the java.sql.Types constants.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The first line with the SqlParameter declares an IN parameter. IN parameters can be used for both stored procedure calls and for queries using the SqlQuery and its subclasses covered in the following section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The second line with the SqlOutParameter declares an out parameter to be used in the stored procedure call. There is also an SqlInOutParameter for InOut parameters, parameters that provide an in value to the procedure and that also return a value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"For in parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For out parameters you can provide a RowMapper to handle mapping of rows returned from a REF cursor. Another option is to specify an SqlReturnType that enables you to define customized handling of the return values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL relative to the current request's host, port, scheme, context path, and the literal part of the servlet mapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The Errors or BindingResult parameters have to follow the model object that is being bound immediately as the method signature might have more that one model object and Spring will create a separate BindingResult instance for each of them so the following sample won't work:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note, that there is a Model parameter in between Pet and BindingResult. To get this working you have to reorder the parameters as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following are the supported return types:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A String value that is interpreted as the logical view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the view name is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body with the @ResponseBody annotation”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity<?>”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A Callable<?> can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A DeferredResult<?> can be returned when the application wants to produce the return value from a thread of its own choosing.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Use the @RequestParam annotation to bind request parameters to a method parameter in your controller.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following code snippet shows the usage:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Parameters using this annotation are required by default, but you can specify that a parameter is optional by setting @RequestParam's required attribute to false (e.g., @RequestParam(value=""id"", required=false)).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Type conversion is applied automatically if the target method parameter type is not String. See the section called “Method Parameters And Type Conversion”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @RequestBody method parameter annotation indicates that a method parameter should be bound to the value of the HTTP request body. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You convert the request body to the method argument by using an HttpMessageConverter. HttpMessageConverter is responsible for converting from the HTTP request message to an object and converting from an object to the HTTP response body. The RequestMappingHandlerAdapter supports the @RequestBody annotation with the following default HttpMessageConverters:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
ByteArrayHttpMessageConverter converts byte arrays.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
StringHttpMessageConverter converts strings.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"FormHttpMessageConverter converts form data to/from a MultiValueMap<String, String>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"For more information on these converters, see Message Converters. Also note that if using the MVC namespace or the MVC Java config, a wider range of message converters are registered by default. See Enabling the MVC Java Config or the MVC XML Namespace for more information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you intend to read and write XML, you will need to configure the MarshallingHttpMessageConverter with a specific Marshaller and an Unmarshaller implementation from the org.springframework.oxm package. The example below shows how to do that directly in your configuration but if your application is configured through the MVC namespace or the MVC Java config see Enabling the MVC Java Config or the MVC XML Namespace instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An @RequestBody method parameter can be annotated with @Valid, in which case it will be validated using the configured Validator instance. When using the MVC namespace or the MVC Java config, a JSR-303 validator is configured automatically assuming a JSR-303 implementation is available on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Just like with @ModelAttribute parameters, an Errors argument can be used to examine the errors. If such an argument is not declared, a MethodArgumentNotValidException will be raised. The exception is handled in the DefaultHandlerExceptionResolver, which sends a 400 error back to the client.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Isolation level is ISOLATION_DEFAULT.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Transaction is read/write.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Any RuntimeException triggers rollback, and any checked Exception does not.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
These default settings can be changed; the various properties of the @Transactional annotation are summarized in the following table:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Currently you cannot have explicit control over the name of a transaction, where 'name' means the transaction name that will be shown in a transaction monitor, if applicable (for example, WebLogic's transaction monitor), and in logging output. For declarative transactions, the transaction name is always the fully-qualified class name + ""."" + method name of the transactionally-advised class. For example, if the handlePayment(..) method of the BusinessService class started a transaction, the name of the transaction would be: com.foo.BusinessService.handlePayment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
could be combined with the following transaction manager bean declarations in the application context.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In this case, the two methods on TransactionalService will run under separate transaction managers, differentiated by the ""order"" and ""account"" qualifiers. The default <tx:annotation-driven> target bean name transactionManager will still be used if no specifically qualified PlatformTransactionManager bean is found.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Here we have used the syntax to define the transaction manager qualifier, but could also have included propagation behavior, rollback rules, timeouts etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
This section describes some semantics of transaction propagation in Spring. Please note that this section is not an introduction to transaction propagation proper; rather it details some of the semantics regarding transaction propagation in Spring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"In Spring-managed transactions, be aware of the difference between physical and logical transactions, and how the propagation setting applies to this difference.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When the propagation setting is PROPAGATION_REQUIRED, a logical transaction scope is created for each method upon which the setting is applied. Each such logical transaction scope can determine rollback-only status individually, with an outer transaction scope being logically independent from the inner transaction scope. Of course, in case of standard PROPAGATION_REQUIRED behavior, all these scopes will be mapped to the same physical transaction. So a rollback-only marker set in the inner transaction scope does affect the outer transaction's chance to actually commit (as you would expect it to).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"However, in the case where an inner transaction scope sets the rollback-only marker, the outer transaction has not decided on the rollback itself, and so the rollback (silently triggered by the inner transaction scope) is unexpected. A corresponding UnexpectedRollbackException is thrown at that point. This is expected behavior so that the caller of a transaction can never be misled to assume that a commit was performed when it really was not. So if an inner transaction (of which the outer caller is not aware) silently marks a transaction as rollback-only, the outer caller still calls commit. The outer caller needs to receive an UnexpectedRollbackException to indicate clearly that a rollback was performed instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"PROPAGATION_REQUIRES_NEW, in contrast to PROPAGATION_REQUIRED, uses a completely independent transaction for each affected transaction scope. In that case, the underlying physical transactions are different and hence can commit or roll back independently, with an outer transaction not affected by an inner transaction's rollback status.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"PROPAGATION_NESTED uses a single physical transaction with multiple savepoints that it can roll back to. Such partial rollbacks allow an inner transaction scope to trigger a rollback for its scope, with the outer transaction being able to continue the physical transaction despite some operations having been rolled back. This setting is typically mapped onto JDBC savepoints, so will only work with JDBC resource transactions. See Spring's DataSourceTransactionManager.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Suppose you want to execute both transactional and some basic profiling advice. How do you effect this in the context of <tx:annotation-driven/>?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When you invoke the updateFoo(Foo) method, you want to see the following actions:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Configured profiling aspect starts up.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Transactional advice executes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Method on the advised object executes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Transaction commits.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Profiling aspect reports exact duration of the whole transactional method invocation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"This chapter is not concerned with explaining AOP in any great detail (except as it applies to transactions). See Chapter 9, Aspect Oriented Programming with Spring for detailed coverage of the following AOP configuration and AOP in general.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Here is the code for a simple profiling aspect discussed above. The ordering of advice is controlled through the Ordered interface. For full details on advice ordering, see the section called “Advice ordering”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The result of the above configuration is a fooService bean that has profiling and transactional aspects applied to it in the desired order. You configure any number of additional aspects in similar fashion.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The following example effects the same setup as above, but uses the purely XML declarative approach.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The JMS client id for this listener container. Needs to be specified when using durable subscriptions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The native JMS acknowledge mode: auto, client, dups-ok or transacted. A value of transacted activates a locally transacted Session. As an alternative, specify the transaction-manager attribute described below. Default is auto.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"A reference to a Spring JtaTransactionManager or a javax.transaction.TransactionManager for kicking off an XA transaction for each incoming message. If not specified, native acknowledging will be used (see the ""acknowledge"" attribute).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
"The number of concurrent sessions/consumers to start for each listener. Can either be a simple number indicating the maximum number (e.g. ""5"") or a range indicating the lower as well as the upper limit (e.g. ""3-5""). Note that a specified minimum is just a hint and will typically be ignored at runtime when using a JCA listener container. Default is 1.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers!,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jms.html
The main reason why auto-detection of implemented interfaces does not occur for remote interfaces is to avoid opening too many doors to remote callers. The target object might implement internal callback interfaces like InitializingBean or DisposableBean which one would not want to expose to callers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Offering a proxy with all interfaces implemented by the target usually does not matter in the local case. But when exporting a remote service, you should expose a specific service interface, with specific operations intended for remote usage. Besides internal callback interfaces, the target might implement multiple business interfaces, with just one of them intended for remote exposure. For these reasons, we require such a service interface to be specified.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"This is a trade-off between configuration convenience and the risk of accidental exposure of internal methods. Always specifying a service interface is not too much effort, and puts you on the safe side regarding controlled exposure of specific methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Each and every technology presented here has its drawbacks. You should carefully consider your needs, the services you are exposing and the objects you'll be sending over the wire when choosing a technology.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"When using RMI, it's not possible to access the objects through the HTTP protocol, unless you're tunneling the RMI traffic. RMI is a fairly heavy-weight protocol in that it supports full-object serialization which is important when using a complex data model that needs serialization over the wire. However, RMI-JRMP is tied to Java clients: It is a Java-to-Java remoting solution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring's HTTP invoker is a good choice if you need HTTP-based remoting but also rely on Java serialization. It shares the basic infrastructure with RMI invokers, just using HTTP as transport. Note that HTTP invokers are not only limited to Java-to-Java remoting but also to Spring on both the client and server side. (The latter also applies to Spring's RMI invoker for non-RMI interfaces.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Hessian and/or Burlap might provide significant value when operating in a heterogeneous environment, because they explicitly allow for non-Java clients. However, non-Java support is still limited. Known issues include the serialization of Hibernate objects in combination with lazily-initialized collections. If you have such a data model, consider using RMI or HTTP invokers instead of Hessian.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"JMS can be useful for providing clusters of services and allowing the JMS broker to take care of load balancing, discovery and auto-failover. By default: Java serialization is used when using JMS remoting but the JMS provider could use a different mechanism for the wire formatting, such as XStream to allow servers to be implemented in other technologies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Last but not least, EJB has an advantage over RMI in that it supports standard role-based authentication and authorization and remote transaction propagation. It is possible to get RMI invokers or HTTP invokers to support security context propagation as well, although this is not provided by core Spring: There are just appropriate hooks for plugging in third-party or custom solutions here.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The RestTemplate is the core class for client-side access to RESTful services. It is conceptually similar to other template classes in Spring, such as JdbcTemplate and JmsTemplate and other template classes found in other Spring portfolio projects. RestTemplate's behavior is customized by providing callback methods and configuring the HttpMessageConverter used to marshal objects into the HTTP request body and to unmarshal any response back into an object. As it is common to use XML as a message format, Spring provides a MarshallingHttpMessageConverter that uses the Object-to-XML framework that is part of the org.springframework.oxm package. This gives you a wide range of choices of XML to Object mapping technologies to choose from.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
This section describes how to use the RestTemplate and its associated HttpMessageConverters.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Invoking RESTful services in Java is typically done using a helper class such as Jakarta Commons HttpClient. For common REST operations this approach is too low level as shown below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
RestTemplate provides higher level methods that correspond to each of the six main HTTP methods that make invoking many RESTful services a one-liner and enforce REST best practices.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The names of RestTemplate methods follow a naming convention, the first part indicates what HTTP method is being invoked and the second part indicates what is returned. For example, the method getForObject() will perform a GET, convert the HTTP response into an object type of your choice and return that object. The method postForLocation() will do a POST, converting the given object into a HTTP request and return the response HTTP Location header where the newly created object can be found. In case of an exception processing the HTTP request, an exception of the type RestClientException will be thrown; this behavior can be changed by plugging in another ResponseErrorHandler implementation into the RestTemplate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Objects passed to and returned from these methods are converted to and from HTTP messages by HttpMessageConverter instances. Converters for the main mime types are registered by default, but you can also write your own converter and register it via the messageConverters() bean property. The default converter instances registered with the template are ByteArrayHttpMessageConverter, StringHttpMessageConverter, FormHttpMessageConverter and SourceHttpMessageConverter. You can override these defaults using the messageConverters() bean property as would be required if using the MarshallingHttpMessageConverter or MappingJackson2HttpMessageConverter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Each method takes URI template arguments in two forms, either as a String variable length argument or a Map<String,String>. For example,",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"using a Map<String,String>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
To create an instance of RestTemplate you can simply call the default no-arg constructor. This will use standard Java classes from the java.net package as the underlying implementation to create HTTP requests. This can be overridden by specifying an implementation of ClientHttpRequestFactory. Spring provides the implementation HttpComponentsClientHttpRequestFactory that uses the Apache HttpComponents HttpClient to create requests. HttpComponentsClientHttpRequestFactory is configured using an instance of org.apache.http.client.HttpClient which can in turn be configured with credentials information or connection pooling functionality.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Note that the java.net implementation for HTTP requests may raise an exception when accessing the status of a response that represents an error (e.g. 401). If this is an issue, switch to HttpComponentsClientHttpRequestFactory instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The general callback interface is RequestCallback and is called when the execute method is invoked.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"and allows you to manipulate the request headers and write to the request body. When using the execute method you do not have to worry about any resource management, the template will always close the request and handle any errors. Refer to the API documentation for more information on using the execute method and the meaning of its other method arguments.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"For each of the main HTTP methods, the RestTemplate provides variants that either take a String URI or java.net.URI as the first argument.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The String URI variants accept template arguments as a String variable length argument or as a Map<String,String>. They also assume the URL String is not encoded and needs to be encoded. For example the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"The postHandle method is only called on a RenderRequest. The preHandle and afterCompletion methods are called on both an ActionRequest and a RenderRequest. If you need to execute logic in these methods for just one type of request, be sure to check what kind of request it is before processing it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"As with the servlet package, the portlet package has a concrete implementation of HandlerInterceptor called HandlerInterceptorAdapter. This class has empty versions of all the methods so that you can inherit from this class and implement just one or two methods when that is all you need.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The portlet package also has a concrete interceptor named ParameterMappingInterceptor that is meant to be used directly with ParameterHandlerMapping and PortletModeParameterHandlerMapping. This interceptor will cause the parameter that is being used to control the mapping to be forwarded from an ActionRequest to the subsequent RenderRequest. This will help ensure that the RenderRequest is mapped to the same Handler as the ActionRequest. This is done in the preHandle method of the interceptor, so you can still modify the parameter value in your handler to change where the RenderRequest will be mapped.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Be aware that this interceptor is calling setRenderParameter on the ActionResponse, which means that you cannot call sendRedirect in your handler when using this interceptor. If you need to do external redirects then you will either need to forward the mapping parameter manually or write a different interceptor to handle this for you.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"As mentioned previously, Spring Portlet MVC directly reuses all the view technologies from Spring Web MVC. This includes not only the various View implementations themselves, but also the ViewResolver implementations. For more information, refer to Chapter 18, View technologies and Section 17.5, “Resolving views” respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
A few items on using the existing View and ViewResolver implementations are worth mentioning:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Most portals expect the result of rendering a portlet to be an HTML fragment. So, things like JSP/JSTL, Velocity, FreeMarker, and XSLT all make sense. But it is unlikely that views that return other document types will make any sense in a portlet context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"There is no such thing as an HTTP redirect from within a portlet (the sendRedirect(..) method of ActionResponse cannot be used to stay within the portal). So, RedirectView and use of the 'redirect:' prefix will not work correctly from within Portlet MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"It may be possible to use the 'forward:' prefix from within Portlet MVC. However, remember that since you are in a portlet, you have no idea what the current URL looks like. This means you cannot use a relative URL to access other resources in your web application and that you will have to use an absolute URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Also, for JSP development, the new Spring Taglib and the new Spring Form Taglib both work in portlet views in exactly the same way that they work in servlet views.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Spring Portlet MVC has built-in multipart support to handle file uploads in portlet applications, just like Web MVC does. The design for the multipart support is done with pluggable PortletMultipartResolver objects, defined in the org.springframework.web.portlet.multipart package. Spring provides a PortletMultipartResolver for use with Commons FileUpload. How uploading files is supported will be described in the rest of this section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"By default, no multipart handling will be done by Spring Portlet MVC, as some developers will want to handle multiparts themselves. You will have to enable it yourself by adding a multipart resolver to the web application's context. After you have done that, DispatcherPortlet will inspect each request to see if it contains a multipart. If no multipart is found, the request will continue as expected. However, if a multipart is found in the request, the PortletMultipartResolver that has been declared in your context will be used. After that, the multipart attribute in your request will be treated like any other attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Any configured PortletMultipartResolver bean must have the following id (or name): ""portletMultipartResolver"". If you have defined your PortletMultipartResolver with any other name, then the DispatcherPortlet will not find your PortletMultipartResolver, and consequently no multipart support will be in effect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following example shows how to use the CommonsPortletMultipartResolver:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Of course you also need to put the appropriate jars in your classpath for the multipart resolver to work. In the case of the CommonsMultipartResolver, you need to use commons-fileupload.jar. Be sure to use at least version 1.1 of Commons FileUpload as previous versions do not support JSR-286 Portlet applications.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Now that you have seen how to set Portlet MVC up to handle multipart requests, let's talk about how to actually use it. When DispatcherPortlet detects a multipart request, it activates the resolver that has been declared in your context and hands over the request. What the resolver then does is wrap the current ActionRequest in a MultipartActionRequest that has support for multipart file uploads. Using the MultipartActionRequest you can get information about the multiparts contained by this request and actually get access to the multipart files themselves in your controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Note that you can only receive multipart file uploads as part of an ActionRequest, not as part of a RenderRequest.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"After the PortletMultipartResolver has finished doing its job, the request will be processed like any other. To use the PortletMultipartResolver, create a form with an upload field (see example below), then let Spring bind the file onto your form (backing object). To actually let the user upload a file, we have to create a (JSP/HTML) form:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"As you can see, we've created a field named “file” that matches the property of the bean that holds the byte[] array. Furthermore we've added the encoding attribute (enctype=""multipart/form-data""), which is necessary to let the browser know how to encode the multipart fields (do not forget this!).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Just as with any other property that's not automagically convertible to a string or primitive type, to be able to put binary data in your objects you have to register a custom editor with the PortletRequestDataBinder. There are a couple of editors available for handling files and setting the results on an object. There's a StringMultipartFileEditor capable of converting files to Strings (using a user-defined character set), and there is a ByteArrayMultipartFileEditor which converts files to byte arrays. They function analogous to the CustomDateEditor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"So, to be able to upload files using a form, declare the resolver, a mapping to a controller that will process the bean, and the controller itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"After that, create the controller and the actual class to hold the file property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"As you can see, the FileUploadBean has a property of type byte[] that holds the file. The controller registers a custom editor to let Spring know how to actually convert the multipart objects the resolver has found to properties specified by the bean. In this example, nothing is done with the byte[] property of the bean itself, but in practice you can do whatever you want (save it in a database, mail it to somebody, etc).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
An equivalent example in which a file is bound straight to a String-typed property on a form backing object might look like this:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Of course, this last example only makes (logical) sense in the context of uploading a plain text file (it wouldn't work so well in the case of uploading an image file).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The third (and final) option is where one binds directly to a MultipartFile property declared on the (form backing) object's class. In this case one does not need to register any custom property editor because there is no type conversion to be performed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Just like Servlet MVC, Portlet MVC provides HandlerExceptionResolvers to ease the pain of unexpected exceptions that occur while your request is being processed by a handler that matched the request. Portlet MVC also provides a portlet-specific, concrete SimpleMappingExceptionResolver that enables you to take the class name of any exception that might be thrown and map it to a view name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition, but also the scope of the objects created from a particular bean definition. This approach is powerful and flexible in that you can choose the scope of the objects you create through configuration instead of having to bake in the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes: out of the box, the Spring Framework supports five scopes, three of which are available only if you use a web-aware ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following scopes are supported out of the box. You can also create a custom scope.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
(Default) Scopes a single bean definition to a single object instance per Spring IoC container.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Scopes a single bean definition to any number of object instances.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Scopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. Only valid in the context of a web-aware Spring ApplicationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As of Spring 3.0, a thread scope is available, but is not registered by default. For more information, see the documentation for SimpleThreadScope. For instructions on how to register this or any other custom scope, see the section called “Using a custom scope”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Only one shared instance of a singleton bean is managed, and all requests for beans with an id or ids matching that bean definition result in that one specific bean instance being returned by the Spring container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring's concept of a singleton bean differs from the Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an object such that one and only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as per container and per bean. This means that if you define one bean for a particular class in a single Spring container, then the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you would write, for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The non-singleton, prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a getBean() method call on the container. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following diagram illustrates the Spring prototype scope. A data access object (DAO) is not typically configured as a prototype, because a typical DAO does not hold any conversational state; it was just easier for this author to reuse the core of the singleton diagram.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example defines a bean as a prototype in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype bean(s) are holding. To get the Spring container to release resources held by prototype-scoped beans, try using a custom bean post-processor, which holds a reference to beans that need to be cleaned up.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In some respects, the Spring container's role in regard to a prototype-scoped bean is a replacement for the Java new operator. All lifecycle management past that point must be handled by the client. (For details on the lifecycle of a bean in the Spring container, see Section 5.6.1, “Lifecycle callbacks”.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The request, session, and global session scopes are only available if you use a web-aware Spring ApplicationContext implementation (such as XmlWebApplicationContext). If you use these scopes with regular Spring IoC containers such as the ClassPathXmlApplicationContext, you get an IllegalStateException complaining about an unknown bean scope.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To support the scoping of beans at the request, session, and global session levels (web-scoped beans), some minor initial configuration is required before you define your beans. (This initial setup is not required for the standard scopes, singleton and prototype.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
How you accomplish this initial setup depends on your particular Servlet environment..,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring DispatcherServlet, or DispatcherPortlet, then no special setup is necessary: DispatcherServlet and DispatcherPortlet already expose all relevant state.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you use a Servlet 2.4+ web container, with requests processed outside of Spring's DispatcherServlet (for example, when using JSF or Struts), you need to add the following javax.servlet.ServletRequestListener to the declarations in your web applications web.xml file:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you use an older web container (Servlet 2.3), use the provided javax.servlet.Filter implementation. The following snippet of XML configuration must be included in the web.xml file of your web application if you want to access web-scoped beans in requests outside of Spring's DispatcherServlet on a Servlet 2.3 container. (The filter mapping depends on the surrounding web application configuration, so you must change it as appropriate.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"DispatcherServlet, RequestContextListener and RequestContextFilter all do exactly the same thing, namely bind the HTTP request object to the Thread that is servicing that request. This makes beans that are request- and session-scoped available further down the call chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Consider the following bean definition:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The org.springframework.aop.framework.adapter package is an SPI package allowing support for new custom advice types to be added without changing the core framework. The only constraint on a custom Advice type is that it must implement the org.aopalliance.aop.Advice tag interface.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Please refer to the org.springframework.aop.framework.adapter package's Javadocs for further information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
Please refer to the Spring sample applications for further examples of Spring AOP:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The JPetStore's default configuration illustrates the use of the TransactionProxyFactoryBean for declarative transaction management.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
The /attributes directory of the JPetStore illustrates the use of attribute-driven declarative transaction management.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html
"When you test application code that manipulates the state of the Hibernate session, make sure to flush the underlying session within test methods that execute that code. Failing to flush the underlying session can produce false positives: your test may pass, but the same code throws an exception in a live, production environment. In the following Hibernate-based example test case, one method demonstrates a false positive, and the other method correctly exposes the results of flushing the session. Note that this applies to JPA and any other ORM frameworks that maintain an in-memory unit of work.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The org.springframework.test.context.junit4 package provides support classes for JUnit 4.5+ based test cases.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AbstractJUnit4SpringContextTests: Abstract base test class that integrates the Spring TestContext Framework with explicit ApplicationContext testing support in a JUnit 4.5+ environment.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When you extend AbstractJUnit4SpringContextTests, you can access the following protected instance variable:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
applicationContext: Use this variable to perform explicit bean lookups or to test the state of the context as a whole.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AbstractTransactionalJUnit4SpringContextTests: Abstract transactional extension of AbstractJUnit4SpringContextTests that also adds some convenience functionality for JDBC access. Expects a javax.sql.DataSource bean and a PlatformTransactionManager bean to be defined in the ApplicationContext. When you extend AbstractTransactionalJUnit4SpringContextTests you can access the following protected instance variables:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
applicationContext: Inherited from the AbstractJUnit4SpringContextTests superclass. Use this variable to perform explicit bean lookups or to test the state of the context as a whole.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"jdbcTemplate: Use this variable to execute SQL statements to query the database. Such queries can be used to confirm database state both prior to and after execution of database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy — for example, if you want to directly extend the class you are testing — you can configure your own custom test classes by using @RunWith(SpringJUnit4ClassRunner.class), @ContextConfiguration, @TestExecutionListeners, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The Spring TestContext Framework offers full integration with JUnit 4.5+ through a custom runner (tested on JUnit 4.5 – 4.10). By annotating test classes with @RunWith(SpringJUnit4ClassRunner.class), developers can implement standard JUnit-based unit and integration tests and simultaneously reap the benefits of the TestContext framework such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on. The following code listing displays the minimal requirements for configuring a test class to run with the custom Spring Runner. @TestExecutionListeners is configured with an empty list in order to disable the default listeners, which otherwise would require an ApplicationContext to be configured through @ContextConfiguration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The org.springframework.test.context.testng package provides support classes for TestNG based test cases.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
AbstractTestNGSpringContextTests: Abstract base test class that integrates the Spring TestContext Framework with explicit ApplicationContext testing support in a TestNG environment.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When you extend AbstractTestNGSpringContextTests, you can access the following protected instance variable:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
applicationContext: Use this variable to perform explicit bean lookups or to test the state of the context as a whole.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"AbstractTransactionalTestNGSpringContextTests: Abstract transactional extension of AbstractTestNGSpringContextTests that adds some convenience functionality for JDBC access. Expects a javax.sql.DataSource bean and a PlatformTransactionManager bean to be defined in the ApplicationContext. When you extend AbstractTransactionalTestNGSpringContextTests, you can access the following protected instance variables:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
applicationContext: Inherited from the AbstractTestNGSpringContextTests superclass. Use this variable to perform explicit bean lookups or to test the state of the context as a whole.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"jdbcTemplate: Use this variable to execute SQL statements to query the database. Such queries can be used to confirm database state both prior to and after execution of database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy — for example, if you want to directly extend the class you are testing — you can configure your own custom test classes by using @ContextConfiguration, @TestExecutionListeners, and so on, and by manually instrumenting your test class with a TestContextManager. See the source code of AbstractTestNGSpringContextTests for an example of how to instrument your test class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Before inclusion in Spring Framework 3.2, the Spring MVC Test framework had already existed as a separate project on GitHub where it grew and evolved through actual use, feedback, and the contribution of many.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The standalone spring-test-mvc project is still available on GitHub and can be used in conjunction with Spring Framework 3.1.x. Applications upgrading to 3.2 should replace the spring-test-mvc dependency with a dependency on spring-test.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The spring-test module uses a different package org.springframework.test.web but otherwise is nearly identical with two exceptions. One is support for features new in 3.2 (e.g. asynchronous web requests). The other relates to the options for creating a MockMvc instance. In Spring Framework 3.2, this can only be done through the TestContext framework, which provides caching benefits for the loaded configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The Spring MVC Test framework provides first class JUnit support for testing client and server-side Spring MVC code through a fluent API. Typically it loads the actual Spring configuration through the TestContext framework and always uses the DispatcherServlet to process requests thus approximating full integration tests without requiring a running Servlet container.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Client-side tests are RestTemplate-based and allow tests for code that relies on the RestTemplate without requiring a running server to respond to the requests.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Before Spring Framework 3.2, the most likely way to test a Spring MVC controller was to write a unit test that instantiates the controller, injects it with mock or stub dependencies, and then calls its methods directly, using a MockHttpServletRequest and MockHttpServletResponse where necessary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Although this is pretty easy to do, controllers have many annotations, and much remains untested. Request mappings, data binding, type conversion, and validation are just a few examples of what isn't tested. Furthermore, there are other types of annotated methods such as @InitBinder, @ModelAttribute, and @ExceptionHandler that get invoked as part of request processing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When using AspectJ, you have the choice of the AspectJ language syntax (also known as the ""code style"") or the @AspectJ annotation style. Clearly, if you are not using Java 5+ then the choice has been made for you... use the code style. If aspects play a large role in your design, and you are able to use the AspectJ Development Tools (AJDT) plugin for Eclipse, then the AspectJ language syntax is the preferred option: it is cleaner and simpler because the language was purposefully designed for writing aspects. If you are not using Eclipse, or have only a few aspects that do not play a major role in your application, then you may want to consider using the @AspectJ style and sticking with a regular Java compilation in your IDE, and adding an aspect weaving phase to your build script.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you have chosen to use Spring AOP, then you have a choice of @AspectJ or XML style. Clearly if you are not running on Java 5+, then the XML style is the appropriate choice; for Java 5 projects there are various tradeoffs to consider.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The XML style will be most familiar to existing Spring users. It can be used with any JDK level (referring to named pointcuts from within pointcut expressions does still require Java 5+ though) and is backed by genuine POJOs. When using AOP as a tool to configure enterprise services then XML can be a good choice (a good test is whether you consider the pointcut expression to be a part of your configuration you might want to change independently). With the XML style arguably it is clearer from your configuration what aspects are present in the system.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The XML style has two disadvantages. Firstly it does not fully encapsulate the implementation of the requirement it addresses in a single place. The DRY principle says that there should be a single, unambiguous, authoritative representation of any piece of knowledge within a system. When using the XML style, the knowledge of how a requirement is implemented is split across the declaration of the backing bean class, and the XML in the configuration file. When using the @AspectJ style there is a single module - the aspect - in which this information is encapsulated. Secondly, the XML style is slightly more limited in what it can express than the @AspectJ style: only the ""singleton"" aspect instantiation model is supported, and it is not possible to combine named pointcuts declared in XML. For example, in the @AspectJ style you can write something like:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
In the XML style I can declare the first two pointcuts:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The downside of the XML approach is that you cannot define the 'accountPropertyAccess' pointcut by combining these definitions.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The @AspectJ style supports additional instantiation models, and richer pointcut composition. It has the advantage of keeping the aspect as a modular unit. It also has the advantage the @AspectJ aspects can be understood (and thus consumed) both by Spring AOP and by AspectJ - so if you later decide you need the capabilities of AspectJ to implement additional requirements then it is very easy to migrate to an AspectJ-based approach. On balance the Spring team prefer the @AspectJ style whenever you have aspects that do more than simple ""configuration"" of enterprise services.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"It is perfectly possible to mix @AspectJ style aspects using the autoproxying support, schema-defined <aop:aspect> aspects, <aop:advisor> declared advisors and even proxies and interceptors defined using the Spring 1.2 style in the same configuration. All of these are implemented using the same underlying support mechanism and will co-exist without any difficulty.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. (JDK dynamic proxies are preferred whenever you have a choice).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
If the target object to be proxied implements at least one interface then a JDK dynamic proxy will be used. All of the interfaces implemented by the target type will be proxied. If the target object does not implement any interfaces then a CGLIB proxy will be created.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the target object, not just those implemented by its interfaces) you can do so. However, there are some issues to consider:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"final methods cannot be advised, as they cannot be overridden.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as CGLIB classes are repackaged under org.springframework and included directly in the spring-core JAR. This means that CGLIB-based proxy support 'just works' in the same way that JDK dynamic proxies always have.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The constructor of your proxied object will be called twice. This is a natural consequence of the CGLIB proxy model whereby a subclass is generated for each proxied object. For each proxied instance, two objects are created: the actual proxied object and an instance of the subclass that implements the advice. This behavior is not exhibited when using JDK proxies. Usually, calling the constructor of the proxied type twice, is not an issue, as there are usually only assignments taking place and no real logic is implemented in the constructor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
To force the use of CGLIB proxies set the value of the proxy-target-class attribute of the <aop:config> element to true:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To force CGLIB proxying when using the @AspectJ autoproxy support, set the 'proxy-target-class' attribute of the <aop:aspectj-autoproxy> element to true:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Multiple <aop:config/> sections are collapsed into a single unified auto-proxy creator at runtime, which applies the strongest proxy settings that any of the <aop:config/> sections (typically from different XML bean definition files) specified. This also applies to the <tx:annotation-driven/> and <aop:aspectj-autoproxy/> elements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To be clear: using 'proxy-target-class=""true""' on <tx:annotation-driven/>, <aop:aspectj-autoproxy/> or <aop:config/> elements will force the use of CGLIB proxies for all three of them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last statement actually means before you write your own aspects or use any of the Spring AOP-based aspects supplied with the Spring Framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Consider first the scenario where you have a plain-vanilla, un-proxied, nothing-special-about-it, straight object reference, as illustrated by the following code snippet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you invoke a method on an object reference, the method is invoked directly on that object reference, as can be seen below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Things change slightly when the reference that client code has is a proxy. Consider the following diagram and code snippet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The key thing to understand here is that the client code inside the main(..) of the Main class has a reference to the proxy. This means that method calls on that object reference will be calls on the proxy, and as such the proxy will be able to delegate to all of the interceptors (advice) that are relevant to that particular method call. However, once the call has finally reached the target object, the SimplePojo reference in this case, any method calls that it may make on itself, such as this.bar() or this.foo(), are going to be invoked against the this reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to execute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Okay, so what is to be done about this? The best approach (the term best is used loosely here) is to refactor your code such that the self-invocation does not happen. For sure, this does entail some work on your part, but it is the best, least-invasive approach. The next approach is absolutely horrendous, and I am almost reticent to point it out precisely because it is so horrendous. You can (choke!) totally tie the logic within your class to Spring AOP by doing this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is being used in an AOP context, which flies in the face of AOP. It also requires some additional configuration when the proxy is being created:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In order to render your report correctly in the format you have chosen, you must supply Spring with all of the data needed to populate your report. For JasperReports this means you must pass in all report parameters along with the report datasource. Report parameters are simple name/value pairs and can be added to the Map for your model as you would add any name/value pair.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"When adding the datasource to the model you have two approaches to choose from. The first approach is to add an instance of JRDataSource or a Collection type to the model Map under any arbitrary key. Spring will then locate this object in the model and treat it as the report datasource. For example, you may populate your model like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The second approach is to add the instance of JRDataSource or Collection under a specific key and then configure this key using the reportDataKey property of the view class. In both cases Spring will wrap instances of Collection in a JRBeanCollectionDataSource instance. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here you can see that two Collection instances are being added to the model. To ensure that the correct one is used, we simply modify our view configuration as appropriate:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Be aware that when using the first approach, Spring will use the first instance of JRDataSource or Collection that it encounters. If you need to place multiple instances of JRDataSource or Collection into the model you need to use the second approach.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"JasperReports provides support for embedded sub-reports within your master report files. There are a wide variety of mechanisms for including sub-reports in your report files. The easiest way is to hard code the report path and the SQL query for the sub report into your design files. The drawback of this approach is obvious: the values are hard-coded into your report files reducing reusability and making it harder to modify and update report designs. To overcome this you can configure sub-reports declaratively, and you can include additional data for these sub-reports directly from your controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"To control which sub-report files are included in a master report using Spring, your report file must be configured to accept sub-reports from an external source. To do this you declare a parameter in your report file like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Then, you define your sub-report to use this sub-report parameter:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This defines a master report file that expects the sub-report to be passed in as an instance of net.sf.jasperreports.engine.JasperReports under the parameter ProductsSubReport. When configuring your Jasper view class, you can instruct Spring to load a report file and pass it into the JasperReports engine as a sub-report using the subReportUrls property:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here, the key of the Map corresponds to the name of the sub-report parameter in the report design file, and the entry is the URL of the report file. Spring will load this report file, compiling it if necessary, and pass it into the JasperReports engine under the given key.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"This step is entirely optional when using Spring to configure your sub-reports. If you wish, you can still configure the data source for your sub-reports using static queries. However, if you want Spring to convert data returned in your ModelAndView into instances of JRDataSource then you need to specify which of the parameters in your ModelAndView Spring should convert. To do this, configure the list of parameter names using the subReportDataKeys property of your chosen view class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here, the key you supply must correspond to both the key used in your ModelAndView and the key used in your report design file.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"If you have special requirements for exporter configuration -- perhaps you want a specific page size for your PDF report -- you can configure these exporter parameters declaratively in your Spring configuration file using the exporterParameters property of the view class. The exporterParameters property is typed as a Map. In your configuration the key of an entry should be the fully-qualified name of a static field that contains the exporter parameter definition, and the value of an entry should be the value you want to assign to the parameter. An example of this is shown below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Here you can see that the JasperReportsHtmlView is configured with an exporter parameter for net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER which will output a footer in the resulting HTML.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
Both AbstractAtomFeedView and AbstractRssFeedView inherit from the base class AbstractFeedView and are used to provide Atom and RSS Feed views respectfully. They are based on java.net's ROME project and are located in the package org.springframework.web.servlet.view.feed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"AbstractAtomFeedView requires you to implement the buildFeedEntries() method and optionally override the buildFeedMetadata() method (the default implementation is empty), as shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Similar requirements apply for implementing AbstractRssFeedView, as shown below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
The buildFeedItems() and buildFeedEntires() methods pass in the HTTP request in case you need to access the Locale. The HTTP response is passed in only for the setting of cookies or other HTTP headers. The feed will automatically be written to the response object after the method returns.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
For an example of creating an Atom view please refer to Alef Arendsen's SpringSource Team Blog entry.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The MarhsallingView uses an XML Marshaller defined in the org.springframework.oxm package to render the response content as XML. The object to be marshalled can be set explicitly using MarhsallingView's modelKey bean property. Alternatively, the view will iterate over all model properties and marshal only those types that are supported by the Marshaller. For more information on the functionality in the org.springframework.oxm package refer to the chapter Marshalling XML using O/X Mappers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"The MappingJackson2JsonView (or MappingJacksonJsonView depending on the the Jackson version you have) uses the Jackson library's ObjectMapper to render the response content as JSON. By default, the entire contents of the model map (with the exception of framework-specific classes) will be encoded as JSON. For cases where the contents of the map need to be filtered, users may specify a specific set of model attributes to encode via the RenderedAttributes property. The extractValueFromSingleKeyModel property may also be used to have the value in single-key models extracted and serialized directly rather than as a map of model attributes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"JSON mapping can be customized as needed through the use of Jackson's provided annotations. When further control is needed, a custom ObjectMapper can be injected through the ObjectMapper property for cases where custom JSON serializers/deserializers need to be provided for specific types.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/view.html
"Here is an example of a simple DAO that uses a StoredProcedure to call a function, sysdate(),which comes with any Oracle database. To use the stored procedure functionality you have to create a class that extends StoredProcedure. In this example, the StoredProcedure class is an inner class, but if you need to reuse the StoredProcedure you declare it as a top-level class. This example has no input parameters, but an output parameter is declared as a date type using the class SqlOutParameter. The execute() method executes the procedure and extracts the returned date from the results Map. The results Map has an entry for each declared output parameter, in this case only one, using the parameter name as the key.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The following example of a StoredProcedure has two output parameters (in this case, Oracle REF cursors).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Notice how the overloaded variants of the declareParameter(..) method that have been used in the TitlesAndGenresStoredProcedure constructor are passed RowMapper implementation instances; this is a very convenient and powerful way to reuse existing functionality. The code for the two RowMapper implementations is provided below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The TitleMapper class maps a ResultSet to a Title domain object for each row in the supplied ResultSet:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The GenreMapper class maps a ResultSet to a Genre domain object for each row in the supplied ResultSet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"To pass parameters to a stored procedure that has one or more input parameters in its definition in the RDBMS, you can code a strongly typed execute(..) method that would delegate to the superclass' untyped execute(Map parameters) method (which has protected access); for example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Common problems with parameters and data values exist in the different approaches provided by the Spring Framework JDBC.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Usually Spring determines the SQL type of the parameters based on the type of parameter passed in. It is possible to explicitly provide the SQL type to be used when setting parameter values. This is sometimes necessary to correctly set NULL values.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
You can provide SQL type information in several ways:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Many update and query methods of the JdbcTemplate take an additional parameter in the form of an int array. This array is used to indicate the SQL type of the corresponding parameter using constant values from the java.sql.Types class. Provide one entry for each parameter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
You can use the SqlParameterValue class to wrap the parameter value that needs this additional information. Create a new instance for each value and pass in the SQL type and parameter value in the constructor. You can also provide an optional scale parameter for numeric values.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"For methods working with named parameters, use the SqlParameterSource classes BeanPropertySqlParameterSource or MapSqlParameterSource. They both have methods for registering the SQL type for any of the named parameter values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You can store images, other binary objects, and large chunks of text. These large object are called BLOB for binary data and CLOB for character data. In Spring you can handle these large objects by using the JdbcTemplate directly and also when using the higher abstractions provided by RDBMS Objects and the SimpleJdbc classes. All of these approaches use an implementation of the LobHandler interface for the actual management of the LOB data. The LobHandler provides access to a LobCreator class, through the getLobCreator method, used for creating new LOB objects to be inserted.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The LobCreator/LobHandler provides the following support for LOB input and output:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The next example shows how to create and insert a BLOB. Later you will see how to read it back from the database.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"This example uses a JdbcTemplate and an implementation of the AbstractLobCreatingPreparedStatementCallback. It implements one method, setValues. This method provides a LobCreator that you use to set the values for the LOB columns in your SQL insert statement.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"For this example we assume that there is a variable, lobHandler, that already is set to an instance of a DefaultLobHandler. You typically set this value through dependency injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Using the method setClobAsCharacterStream, pass in the contents of the CLOB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Using the method setBlobAsBinaryStream, pass in the contents of the BLOB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Now it's time to read the LOB data from the database. Again, you use a JdbcTemplate with the same instance variable lobHandler and a reference to a DefaultLobHandler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Using the method getClobAsString, retrieve the contents of the CLOB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Using the method getBlobAsBytes, retrieve the contents of the BLOB.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The SQL standard allows for selecting rows based on an expression that includes a variable list of values. A typical example would be select * from T_ACTOR where id in (1, 2, 3). This variable list is not directly supported for prepared statements by the JDBC standard; you cannot declare a variable number of placeholders. You need a number of variations with the desired number of placeholders prepared, or you need to generate the SQL string dynamically once you know how many placeholders are required. The named parameter support provided in the NamedParameterJdbcTemplate and JdbcTemplate takes the latter approach. Pass in the values as a java.util.List of primitive objects. This list will be used to insert the required placeholders and pass in the values during the statement execution.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Be careful when passing in many values. The JDBC standard does not guarantee that you can use more than 100 values for an in expression list. Various databases exceed this number, but they usually have a hard limit for how many values are allowed. Oracle's limit is 1000.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"In addition to the primitive values in the value list, you can create a java.util.List of object arrays. This list would support multiple expressions defined for the in clause such as select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop')). This of course requires that your database supports this syntax.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Also see Enabling the MVC Java Config or the MVC XML Namespace for information on configuring message converters and a validator through the MVC namespace or the MVC Java config.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The @ResponseBody annotation is similar to @RequestBody. This annotation can be put on a method and indicates that the return type should be written straight to the HTTP response body (and not placed in a Model, or interpreted as a view name). For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The above example will result in the text Hello World being written to the HTTP response stream.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As with @RequestBody, Spring converts the returned object to a response body by using an HttpMessageConverter. For more information on these converters, see the previous section and Message Converters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The HttpEntity is similar to @RequestBody and @ResponseBody. Besides getting access to the request and response body, HttpEntity (and the response-specific subclass ResponseEntity) also allows access to the request and response headers, like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The above example gets the value of the MyRequestHeader request header, and reads the body as a byte array. It adds the MyResponseHeader to the response, writes Hello World to the response stream, and sets the response status code to 201 (Created).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As with @RequestBody and @ResponseBody, Spring uses HttpMessageConverter to convert from and to the request and response streams. For more information on these converters, see the previous section and Message Converters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @ModelAttribute annotation can be used on methods or on method arguments. This section explains its usage on methods while the next section explains its usage on method arguments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An @ModelAttribute on a method indicates the purpose of that method is to add one or more model attributes. Such methods support the same argument types as @RequestMapping methods but cannot be mapped directly to requests. Instead @ModelAttribute methods in a controller are invoked before @RequestMapping methods, within the same controller. A couple of examples:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"@ModelAttribute methods are used to populate the model with commonly needed attributes for example to fill a drop-down with states or with pet types, or to retrieve a command object like Account in order to use it to represent the data on an HTML form. The latter case is further discussed in the next section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note the two styles of @ModelAttribute methods. In the first, the method adds an attribute implicitly by returning it. In the second, the method accepts a Model and adds any number of model attributes to it. You can choose between the two styles depending on your needs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods of the same controller.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@ModelAttribute methods can also be defined in an @ControllerAdvice-annotated class and such methods apply to all controllers. The @ControllerAdvice annotation is a component annotation allowing implementation classes to be autodetected through classpath scanning.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"What happens when a model attribute name is not explicitly specified? In such cases a default name is assigned to the model attribute based on its type. For example if the method returns an object of type Account, the default name used is ""account"". You can change that through the value of the @ModelAttribute annotation. If adding attributes directly to the Model, use the appropriate overloaded addAttribute(..) method - i.e., with or without an attribute name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The @ModelAttribute annotation can be used on @RequestMapping methods as well. In that case the return value of the @RequestMapping method is interpreted as a model attribute rather than as a view name. The view name is derived from view name conventions instead much like for methods returning void — see Section 17.12.3, “The View - RequestToViewNameTranslator”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
As explained in the previous section @ModelAttribute can be used on methods or on method arguments. This section explains its usage on method arguments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. If not present in the model, the argument should be instantiated first and then added to the model. Once present in the model, the argument's fields should be populated from all request parameters that have matching names. This is known as data binding in Spring MVC, a very useful mechanism that saves you from having to parse each form field individually.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Given the above example where can the Pet instance come from? There are several options:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
It may already be in the model due to use of @SessionAttributes — see the section called “Using @SessionAttributes to store model attributes in the HTTP session between requests”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
It may already be in the model due to an @ModelAttribute method in the same controller — as explained in the previous section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
It may be retrieved based on a URI template variable and type converter (explained in more detail below).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
It may be instantiated using its default constructor.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An @ModelAttribute method is a common way to to retrieve an attribute from the database, which may optionally be stored between requests through the use of @SessionAttributes. In some cases it may be convenient to retrieve the attribute by using an URI template variable and a type converter. Here is an example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In this example the name of the model attribute (i.e. ""account"") matches the name of a URI template variable. If you register Converter<String, Account> that can turn the String account value into an Account instance, then the above example will work without the need for an @ModelAttribute method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The next step is data binding. The WebDataBinder class matches request parameter names — including query string parameters and form fields — to model attribute fields by name. Matching fields are populated after type conversion (from String to the target field type) has been applied where necessary. Data binding and validation are covered in Chapter 7, Validation, Data Binding, and Type Conversion. Customizing the data binding process for a controller level is covered in the section called “Customizing WebDataBinder initialization”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The result of the above configuration will be a fooService bean that has profiling and transactional aspects applied to it in that order. If you want the profiling advice to execute after the transactional advice on the way in, and before the transactional advice on the way out, then you simply swap the value of the profiling aspect bean's order property so that it is higher than the transactional advice's order value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
You configure additional aspects in similar fashion.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"It is also possible to use the Spring Framework's @Transactional support outside of a Spring container by means of an AspectJ aspect. To do so, you first annotate your classes (and optionally your classes' methods) with the @Transactional annotation, and then you link (weave) your application with the org.springframework.transaction.aspectj.AnnotationTransactionAspect defined in the spring-aspects.jar file. The aspect must also be configured with a transaction manager. You can of course use the Spring Framework's IoC container to take care of dependency-injecting the aspect. The simplest way to configure the transaction management aspect is to use the <tx:annotation-driven/> element and specify the mode attribute to aspectj as described in Section 12.5.6, “Using @Transactional”. Because we're focusing here on applications running outside of a Spring container, we'll show you how to do it programmatically.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Prior to continuing, you may want to read Section 12.5.6, “Using @Transactional” and Chapter 9, Aspect Oriented Programming with Spring respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"When using this aspect, you must annotate the implementation class (and/or methods within that class), not the interface (if any) that the class implements. AspectJ follows Java's rule that annotations on interfaces are not inherited.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The @Transactional annotation on a class specifies the default transaction semantics for the execution of any method in the class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The @Transactional annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Any method may be annotated, regardless of visibility.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"To weave your applications with the AnnotationTransactionAspect you must either build your application with AspectJ (see the AspectJ Development Guide) or use load-time weaving. See Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework” for a discussion of load-time weaving with AspectJ.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
The Spring Framework provides two means of programmatic transaction management:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Using the TransactionTemplate.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Using a PlatformTransactionManager implementation directly.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The Spring team generally recommends the TransactionTemplate for programmatic transaction management. The second approach is similar to using the JTA UserTransaction API, although exception handling is less cumbersome.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The TransactionTemplate adopts the same approach as other Spring templates such as the JdbcTemplate. It uses a callback approach, to free application code from having to do the boilerplate acquisition and release of transactional resources, and results in code that is intention driven, in that the code that is written focuses solely on what the developer wants to do.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"As you will see in the examples that follow, using the TransactionTemplate absolutely couples you to Spring's transaction infrastructure and APIs. Whether or not programmatic transaction management is suitable for your development needs is a decision that you will have to make yourself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Application code that must execute in a transactional context, and that will use the TransactionTemplate explicitly, looks like the following. You, as an application developer, write a TransactionCallback implementation (typically expressed as an anonymous inner class) that contains the code that you need to execute in the context of a transaction. You then pass an instance of your custom TransactionCallback to the execute(..) method exposed on the TransactionTemplate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"If there is no return value, use the convenient TransactionCallbackWithoutResult class with an anonymous class as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Code within the callback can roll the transaction back by calling the setRollbackOnly() method on the supplied TransactionStatus object:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can specify transaction settings such as the propagation mode, the isolation level, the timeout, and so forth on the TransactionTemplate either programmatically or in configuration. TransactionTemplate instances by default have the default transactional settings. The following example shows the programmatic customization of the transactional settings for a specific TransactionTemplate:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The following example defines a TransactionTemplate with some custom transactional settings, using Spring XML configuration. The sharedTransactionTemplate can then be injected into as many services as are required.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Finally, instances of the TransactionTemplate class are threadsafe, in that instances do not maintain any conversational state. TransactionTemplate instances do however maintain configuration state, so while a number of classes may share a single instance of a TransactionTemplate, if a class needs to use a TransactionTemplate with different settings (for example, a different isolation level), then you need to create two distinct TransactionTemplate instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"You can also use the org.springframework.transaction.PlatformTransactionManager directly to manage your transaction. Simply pass the implementation of the PlatformTransactionManager you are using to your bean through a bean reference. Then, using the TransactionDefinition and TransactionStatus objects you can initiate transactions, roll back, and commit.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Programmatic transaction management is usually a good idea only if you have a small number of transactional operations. For example, if you have a web application that require transactions only for certain update operations, you may not want to set up transactional proxies using Spring or any other technology. In this case, using the TransactionTemplate may be a good approach. Being able to set the transaction name explicitly is also something that can only be done using the programmatic approach to transaction management.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"On the other hand, if your application has numerous transactional operations, declarative transaction management is usually worthwhile. It keeps transaction management out of business logic, and is not difficult to configure. When using the Spring Framework, rather than EJB CMT, the configuration cost of declarative transaction management is greatly reduced.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Spring's transaction abstraction generally is application server agnostic. Additionally, Spring's JtaTransactionManager class, which can optionally perform a JNDI lookup for the JTA UserTransaction and TransactionManager objects, autodetects the location for the latter object, which varies by application server. Having access to the JTA TransactionManager allows for enhanced transaction semantics, in particular supporting transaction suspension. See the JtaTransactionManager Javadocs for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Spring's JtaTransactionManager is the standard choice to run on Java EE application servers, and is known to work on all common servers. Advanced functionality such as transaction suspension works on many servers as well -- including GlassFish, JBoss, Geronimo, and Oracle OC4J -- without any special configuration required. However, for fully supported transaction suspension and further advanced integration, Spring ships special adapters for IBM WebSphere, BEA WebLogic Server, and Oracle OC4J. These adapters are discussed in the following sections.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"For standard scenarios, including WebLogic Server, WebSphere and OC4J, consider using the convenient <tx:jta-transaction-manager/> configuration element. When configured, this element automatically detects the underlying server and chooses the best transaction manager available for the platform. This means that you won't have to configure server-specific adapter classes (as discussed in the following sections) explicitly; rather, they are chosen automatically, with the standard JtaTransactionManager as default fallback.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"On WebSphere 6.1.0.9 and above, the recommended Spring JTA transaction manager to use is WebSphereUowTransactionManager. This special adapter leverages IBM's UOWManager API, which is available in WebSphere Application Server 6.0.2.19 and later and 6.1.0.9 and later. With this adapter, Spring-driven transaction suspension (suspend/resume as initiated by PROPAGATION_REQUIRES_NEW) is officially supported by IBM!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"On WebLogic Server 9.0 or above, you typically would use the WebLogicJtaTransactionManager instead of the stock JtaTransactionManager class. This special WebLogic-specific subclass of the normal JtaTransactionManager supports the full power of Spring's transaction definitions in a WebLogic-managed transaction environment, beyond standard JTA semantics: Features include transaction names, per-transaction isolation levels, and proper resuming of transactions in all cases.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"will perform a GET on http://example.com/hotel%20list. That means if the input URL String is already encoded, it will be encoded twice -- i.e. http://example.com/hotel%20list will become http://example.com/hotel%2520list. If this is not the intended effect, use the java.net.URI method variant, which assumes the URL is already encoded is also generally useful if you want to reuse a single (fully expanded) URI multiple times.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
The UriComponentsBuilder class can be used to build and encode the URI including support for URI templates. For example you can start with a URL String:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Or specify each URI component individually:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Besides the methods described above, the RestTemplate also has the exchange() method, which can be used for arbitrary HTTP method execution based on the HttpEntity class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Perhaps most importantly, the exchange() method can be used to add request headers and read response headers. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"In the above example, we first prepare a request entity that contains the MyRequestHeader header. We then retrieve the response, and read the MyResponseHeader and body.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
Concrete implementations for the main media (mime) types are provided in the framework and are registered by default with the RestTemplate on the client-side and with AnnotationMethodHandlerAdapter on the server-side.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An HttpMessageConverter implementation that can read and write Strings from the HTTP request and response. By default, this converter supports all text media types (text/*), and writes with a Content-Type of text/plain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An HttpMessageConverter implementation that can read and write form data from the HTTP request and response. By default, this converter reads and writes the media type application/x-www-form-urlencoded. Form data is read from and written into a MultiValueMap<String, String>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An HttpMessageConverter implementation that can read and write byte arrays from the HTTP request and response. By default, this converter supports all media types (*/*), and writes with a Content-Type of application/octet-stream. This can be overridden by setting the supportedMediaTypes property, and overriding getContentType(byte[]).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
An HttpMessageConverter implementation that can read and write XML using Spring's Marshaller and Unmarshaller abstractions from the org.springframework.oxm package. This converter requires a Marshaller and Unmarshaller before it can be used. These can be injected via constructor or bean properties. By default this converter supports (text/xml) and (application/xml).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An HttpMessageConverter implementation that can read and write JSON using Jackson's ObjectMapper. JSON mapping can be customized as needed through the use of Jackson's provided annotations. When further control is needed, a custom ObjectMapper can be injected through the ObjectMapper property for cases where custom JSON serializers/deserializers need to be provided for specific types. By default this converter supports (application/json).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"An HttpMessageConverter implementation that can read and write javax.xml.transform.Source from the HTTP request and response. Only DOMSource, SAXSource, and StreamSource are supported. By default, this converter supports (text/xml) and (application/xml).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
An HttpMessageConverter implementation that can read and write java.awt.image.BufferedImage from the HTTP request and response. This converter reads and writes the media type supported by the Java I/O API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html
"Spring 2.5 introduced an annotation-based programming model for MVC controllers, using annotations such as @RequestMapping, @RequestParam, @ModelAttribute, etc. This annotation support is available for both Servlet MVC and Portlet MVC. Controllers implemented in this style do not have to extend specific base classes or implement specific interfaces. Furthermore, they do not usually have direct dependencies on Servlet or Portlet API's, although they can easily get access to Servlet or Portlet facilities if desired.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following sections document these annotations and how they are most commonly used in a Portlet environment.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
@RequestMapping will only be processed if a corresponding HandlerMapping (for type level annotations) and/or HandlerAdapter (for method level annotations) is present in the dispatcher. This is the case by default in both DispatcherServlet and DispatcherPortlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"However, if you are defining custom HandlerMappings or HandlerAdapters, then you need to make sure that a corresponding custom DefaultAnnotationHandlerMapping and/or AnnotationMethodHandlerAdapter is defined as well - provided that you intend to use @RequestMapping.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Defining a DefaultAnnotationHandlerMapping and/or AnnotationMethodHandlerAdapter explicitly also makes sense if you would like to customize the mapping strategy, e.g. specifying a custom WebBindingInitializer (see below).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The @Controller annotation indicates that a particular class serves the role of a controller. There is no need to extend any controller base class or reference the Portlet API. You are of course still able to reference Portlet-specific features if you need to.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The basic purpose of the @Controller annotation is to act as a stereotype for the annotated class, indicating its role. The dispatcher will scan such annotated classes for mapped methods, detecting @RequestMapping annotations (see the next section).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Annotated controller beans may be defined explicitly, using a standard Spring bean definition in the dispatcher's context. However, the @Controller stereotype also allows for autodetection, aligned with Spring 2.5's general support for detecting component classes in the classpath and auto-registering bean definitions for them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"To enable autodetection of such annotated controllers, you have to add component scanning to your configuration. This is easily achieved by using the spring-context schema as shown in the following XML snippet:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The @RequestMapping annotation is used to map portlet modes like 'VIEW'/'EDIT' onto an entire class or a particular handler method. Typically the type-level annotation maps a specific mode (or mode plus parameter condition) onto a form controller, with additional method-level annotations 'narrowing' the primary mapping for specific portlet request parameters.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"@RequestMapping at the type level may be used for plain implementations of the Controller interface as well. In this case, the request processing code would follow the traditional handle(Action|Render)Request signature, while the controller's mapping would be expressed through an @RequestMapping annotation. This works for pre-built Controller base classes, such as SimpleFormController, too.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"In the following discussion, we'll focus on controllers that are based on annotated handler methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following is an example of a form controller from the PetPortal sample application using this annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Handler methods which are annotated with @RequestMapping are allowed to have very flexible signatures. They may have arguments of the following types, in arbitrary order (except for validation results, which need to follow right after the corresponding command object, if desired):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Request and/or response objects (Portlet API). You may choose any specific request/response type, e.g. PortletRequest / ActionRequest / RenderRequest. An explicitly declared action/render argument is also used for mapping specific request types onto a handler method (in case of no other information given that differentiates between action and render requests).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Session object (Portlet API): of type PortletSession. An argument of this type will enforce the presence of a corresponding session. As a consequence, such an argument will never be null.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
java.util.Locale for the current request locale (the portal locale in a Portlet environment).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
java.io.InputStream / java.io.Reader for access to the request's content. This will be the raw InputStream/Reader as exposed by the Portlet API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
java.io.OutputStream / java.io.Writer for generating the response's content. This will be the raw OutputStream/Writer as exposed by the Portlet API.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
@RequestParam annotated parameters for access to specific Portlet request parameters. Parameter values will be converted to the declared method argument type.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
java.util.Map / org.springframework.ui.Model / org.springframework.ui.ModelMap for enriching the implicit model that will be exposed to the web view.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Command/form objects to bind parameters to: as bean properties or fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration - see the ""webBindingInitializer"" property on AnnotationMethodHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes, by default using the non-qualified command class name in property notation (e.g. ""orderAddress"" for type ""mypackage.OrderAddress""). Specify a parameter-level ModelAttribute annotation for declaring a specific model attribute name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
org.springframework.validation.Errors / org.springframework.validation.BindingResult validation results for a preceding command/form object (the immediate preceding argument).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete (triggering the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following return types are supported for handler methods:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The Spring container creates a new instance of the LoginAction bean by using the loginAction bean definition for each and every HTTP request. That is, the loginAction bean is scoped at the HTTP request level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same loginAction bean definition will not see these changes in state; they are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Consider the following bean definition:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring container creates a new instance of the UserPreferences bean by using the userPreferences bean definition for the lifetime of a single HTTP Session. In other words, the userPreferences bean is effectively scoped at the HTTP Session level. As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP Session instances that are also using instances created from the same userPreferences bean definition do not see these changes in state, because they are particular to an individual HTTP Session. When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is also discarded.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Consider the following bean definition:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The global session scope is similar to the standard HTTP Session scope (described above), and applies only in the context of portlet-based web applications. The portlet specification defines the notion of a global Session that is shared among all portlets that make up a single portlet web application. Beans defined at the global session scope are scoped (or bound) to the lifetime of the global portlet Session.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you write a standard Servlet-based web application and you define one or more beans as having global session scope, the standard HTTP Session scope is used, and no error is raised.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request scoped bean into another bean, you must inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real, target object from the relevant scope (for example, an HTTP request) and delegate method calls onto the real object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You do not need to use the <aop:scoped-proxy/> in conjunction with beans that are scoped as singletons or prototypes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The configuration in the following example is only one line, but it is important to understand the “why” as well as the “how” behind it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To create such a proxy, you insert a child <aop:scoped-proxy/> element into a scoped bean definition. See the section called “Choosing the type of proxy to create” and Appendix E, XML Schema-based configuration.) Why do definitions of beans scoped at the request, session, globalSession and custom-scope levels require the <aop:scoped-proxy/> element ? Let's examine the following singleton bean definition and contrast it with what you need to define for the aforementioned scopes. (The following userPreferences bean definition as it stands is incomplete.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the preceding example, the singleton bean userManager is injected with a reference to the HTTP Session-scoped bean userPreferences. The salient point here is that the userManager bean is a singleton: it will be instantiated exactly once per container, and its dependencies (in this case only one, the userPreferences bean) are also injected only once. This means that the userManager bean will only operate on the exact same userPreferences object, that is, the one that it was originally injected with.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived scoped bean, for example injecting an HTTP Session-scoped collaborating bean as a dependency into singleton bean. Rather, you need a single userManager object, and for the lifetime of an HTTP Session, you need a userPreferences object that is specific to said HTTP Session. Thus the container creates an object that exposes the exact same public interface as the UserPreferences class (ideally an object that is a UserPreferences instance) which can fetch the real UserPreferences object from the scoping mechanism (HTTP request, Session, etc.). The container injects this proxy object into the userManager bean, which is unaware that this UserPreferences reference is a proxy. In this example, when a UserManager instance invokes a method on the dependency-injected UserPreferences object, it actually is invoking a method on the proxy. The proxy then fetches the real UserPreferences object from (in this case) the HTTP Session, and delegates the method invocation onto the retrieved real UserPreferences object.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Thus you need the following, correct and complete, configuration when injecting request-, session-, and globalSession-scoped beans into collaborating objects:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"By default, when the Spring container creates a proxy for a bean that is marked up with the <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Note: CGLIB proxies only intercept public method calls! Do not call non-public methods on such a proxy; they will not be delegated to the scoped target object.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying false for the value of the proxy-target-class attribute of the <aop:scoped-proxy/> element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to effect such proxying. However, it also means that the class of the scoped bean must implement at least one interface, and that all collaborators into which the scoped bean is injected must reference the bean through one of its interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For more detailed information about choosing class-based or interface-based proxying, see Section 9.6, “Proxying mechanisms”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As of Spring 2.0, the bean scoping mechanism is extensible. You can define your own scopes, or even redefine existing scopes, although the latter is considered bad practice and you cannot override the built-in singleton and prototype scopes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To integrate your custom scope(s) into the Spring container, you need to implement the org.springframework.beans.factory.config.Scope interface, which is described in this section. For an idea of how to implement your own scopes, see the Scope implementations that are supplied with the Spring Framework itself and the Scope Javadoc, which explains the methods you need to implement in more detail.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Scope interface has four methods to get objects from the scope, remove them from the scope, and allow them to be destroyed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following method returns the object from the underlying scope. The session scope implementation, for example, returns the session-scoped bean (and if it does not exist, the method returns a new instance of the bean, after having bound it to the session for future reference).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following method removes the object from the underlying scope. The session scope implementation for example, removes the session-scoped bean from the underlying session. The object should be returned, but you can return null if the object with the specified name is not found.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following method registers the callbacks the scope should execute when it is destroyed or when the specified object in the scope is destroyed. Refer to the Javadoc or a Spring scope implementation for more information on destruction callbacks.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The idea behind Spring MVC Test is to be able to re-write those controller tests by performing actual requests and generating responses, as they would be at runtime, along the way invoking controllers through the Spring MVC DispatcherServlet. Controllers can still be injected with mock dependencies, so tests can remain focused on the web layer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Spring MVC Test builds on the familiar ""mock"" implementations of the Servlet API available in the spring-test module. This allows performing requests and generating responses without the need for running in a Servlet container. For the most part everything should work as it does at runtime with the exception of JSP rendering, which is not available outside a Servlet container. Furthermore, if you are familiar with how the MockHttpServletResponse works, you'll know that forwards and redirects are not actually executed. Instead ""forwarded"" and ""redirected"" URLs are saved and can be asserted in tests. This means if you are using JSPs, you can verify the JSP page to which the request was forwarded.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"All other means of rendering including @ResponseBody methods and View types (besides JSPs) such as Freemarker, Velocity, Thymeleaf, and others for rendering HTML, JSON, XML, and so on should work as expected, and the response will contain the generated content.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Below is an example of a test requesting account information in JSON format:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The test relies on the WebApplicationContext support of the TestContext framework. It loads Spring configuration from an XML configuration file located in the same package as the test class (also supports JavaConfig) and injects the created WebApplicationContext into the test so a MockMvc instance can be created with it.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The MockMvc is then used to perform a request to ""/accounts/1"" and verify the resulting response status is 200, the response content type is ""application/json"", and response content has a JSON property called ""name"" with the value ""Lee"". JSON content is inspected with the help of Jayway's JsonPath project. There are lots of other options for verifying the result of the performed request and those will be discussed later.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The fluent API in the example above requires a few static imports such as MockMvcRequestBuilders.*, MockMvcResultMatchers.*, and MockMvcBuilders.*. An easy way to find these classes is to search for types matching ""MockMvc*"". If using Eclipse, be sure to add them as ""favorite static members"" in the Eclipse preferences under Java -> Editor -> Content Assist -> Favorites. That will allow use of content assist after typing the first character of the static method name. Other IDEs (e.g. IntelliJ) may not require any additional configuration. Just check the support for code completion on static members.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The goal of server-side test setup is to create an instance of MockMvc that can be used to perform requests. There are two main options.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The first option is to point to Spring MVC configuration through the TestContext framework, which loads the Spring configuration and injects a WebApplicationContext into the test to use to create a MockMvc:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The second option is to simply register a controller instance without loading any Spring configuration. Instead basic Spring MVC configuration suitable for testing annotated controllers is automatically created. The created configuration is comparable to that of the MVC JavaConfig (and the MVC namespace) and can be customized to a degree through builder-style methods:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Which option should you use?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The ""webAppContextSetup"" loads the actual Spring MVC configuration resulting in a more complete integration test. Since the TestContext framework caches the loaded Spring configuration, it helps to keep tests running fast even as more tests get added. Furthermore, you can inject mock services into controllers through Spring configuration, in order to remain focused on testing the web layer. Here is an example of declaring a mock service with Mockito:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Then you can inject the mock service into the test in order set up and verify expectations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The ""standaloneSetup"" on the other hand is a little closer to a unit test. It tests one controller at a time, the controller can be injected with mock dependencies manually, and it doesn't involve loading Spring configuration. Such tests are more focused in style and make it easier to see which controller is being tested, whether any specific Spring MVC configuration is required to work, and so on. The ""standaloneSetup"" is also a very convenient way to write ad-hoc tests to verify some behavior or to debug an issue.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Just like with integration vs unit testing, there is no right or wrong answer. Using the ""standaloneSetup"" does imply the need for some additional ""webAppContextSetup"" tests to verify the Spring MVC configuration. Alternatively, you can decide write all tests with ""webAppContextSetup"" and always test against actual Spring MVC configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"To perform requests, use the appropriate HTTP method and additional builder-style methods corresponding to properties of MockHttpServletRequest. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In addition to all the HTTP methods, you can also perform file upload requests, which internally creates an instance of MockMultipartHttpServletRequest:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Query string parameters can be specified in the URI template:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Or by adding Servlet request parameters:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"If application code relies on Servlet request parameters, and doesn't check the query string, as is most often the case, then it doesn't matter how parameters are added. Keep in mind though that parameters provided in the URI template will be decoded while parameters provided through the param(...) method are expected to be decoded.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In most cases it's preferable to leave out the context path and the Servlet path from the request URI. If you must test with the full request URI, be sure to set the contextPath and servletPath accordingly so that request mappings will work:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Looking at the above example, it would be cumbersome to set the contextPath and servletPath with every performed request. That's why you can define default request properties when building the MockMvc:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The above properties will apply to every request performed through the MockMvc. If the same property is also specified on a given request, it will override the default value. That is why, the HTTP method and URI don't matter, when setting default request properties, since they must be specified on every request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Expectations can be defined by appending one or more .andExpect(..) after call to perform the request:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"MockMvcResultMatchers.* defines a number of static members, some of which return types with additional methods, for asserting the result of the performed request. The assertions fall in two general categories.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The first category of assertions verify properties of the response, i.e the response status, headers, and content. Those are the most important things to test for.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In addition to declaring aspects in your configuration using either <aop:config> or <aop:aspectj-autoproxy>, it is also possible programmatically to create proxies that advise target objects. For the full details of Spring's AOP API, see the next chapter. Here we want to focus on the ability to automatically create proxies using @AspectJ aspects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The class org.springframework.aop.aspectj.annotation.AspectJProxyFactory can be used to create a proxy for a target object that is advised by one or more @AspectJ aspects. Basic usage for this class is very simple, as illustrated below. See the Javadocs for full information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Everything we've covered so far in this chapter is pure Spring AOP. In this section, we're going to look at how you can use the AspectJ compiler/weaver instead of, or in addition to, Spring AOP if your needs go beyond the facilities offered by Spring AOP alone.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring ships with a small AspectJ aspect library, which is available standalone in your distribution as spring-aspects.jar; you'll need to add this to your classpath in order to use the aspects in it. Section 9.8.1, “Using AspectJ to dependency inject domain objects with Spring” and Section 9.8.2, “Other Spring aspects for AspectJ” discuss the content of this library and how you can use it. Section 9.8.3, “Configuring AspectJ aspects using Spring IoC” discusses how to dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally, Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework” provides an introduction to load-time weaving for Spring applications using AspectJ.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The Spring container instantiates and configures beans defined in your application context. It is also possible to ask a bean factory to configure a pre-existing object given the name of a bean definition containing the configuration to be applied. The spring-aspects.jar contains an annotation-driven aspect that exploits this capability to allow dependency injection of any object. The support is intended to be used for objects created outside of the control of any container. Domain objects often fall into this category because they are often created programmatically using the new operator, or by an ORM tool as a result of a database query.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The @Configurable annotation marks a class as eligible for Spring-driven configuration. In the simplest case it can be used just as a marker annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When used as a marker interface in this way, Spring will configure new instances of the annotated type (Account in this case) using a bean definition (typically prototype-scoped) with the same name as the fully-qualified type name (com.xyz.myapp.domain.Account). Since the default name for a bean is the fully-qualified name of its type, a convenient way to declare the prototype definition is simply to omit the id attribute:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you want to explicitly specify the name of the prototype bean definition to use, you can do so directly in the annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Spring will now look for a bean definition named ""account"" and use that as the definition to configure new Account instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"You can also use autowiring to avoid having to specify a dedicated bean definition at all. To have Spring apply autowiring use the 'autowire' property of the @Configurable annotation: specify either @Configurable(autowire=Autowire.BY_TYPE) or @Configurable(autowire=Autowire.BY_NAME for autowiring by type or by name respectively. As an alternative, as of Spring 2.5 it is preferable to specify explicit, annotation-driven dependency injection for your @Configurable beans by using @Autowired or @Inject at the field or method level (see Section 5.9, “Annotation-based container configuration” for further details).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Finally you can enable Spring dependency checking for the object references in the newly created and configured object by using the dependencyCheck attribute (for example: @Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)). If this attribute is set to true, then Spring will validate after configuration that all properties (which are not primitives or collections) have been set.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Using the annotation on its own does nothing of course. It is the AnnotationBeanConfigurerAspect in spring-aspects.jar that acts on the presence of the annotation. In essence the aspect says ""after returning from the initialization of a new object of a type annotated with @Configurable, configure the newly created object using Spring in accordance with the properties of the annotation"". In this context, initialization refers to newly instantiated objects (e.g., objects instantiated with the 'new' operator) as well as to Serializable objects that are undergoing deserialization (e.g., via readResolve()).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"One of the key phrases in the above paragraph is 'in essence'. For most cases, the exact semantics of 'after returning from the initialization of a new object' will be fine... in this context, 'after initialization' means that the dependencies will be injected after the object has been constructed - this means that the dependencies will not be available for use in the constructor bodies of the class. If you want the dependencies to be injected before the constructor bodies execute, and thus be available for use in the body of the constructors, then you need to define this on the @Configurable declaration like so:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
You can find out more information about the language semantics of the various pointcut types in AspectJ in this appendix of the AspectJ Programming Guide.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"For this to work the annotated types must be woven with the AspectJ weaver - you can either use a build-time Ant or Maven task to do this (see for example the AspectJ Development Environment Guide) or load-time weaving (see Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework”). The AnnotationBeanConfigurerAspect itself needs configuring by Spring (in order to obtain a reference to the bean factory that is to be used to configure new objects). If you are using Java based configuration simply add @EnableSpringConfigured to any @Configuration class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you prefer XML based configuration, the Spring context namespace defines a convenient context:spring-configured element:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are using the DTD instead of schema, the equivalent definition is:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Instances of @Configurable objects created before the aspect has been configured will result in a message being issued to the debug log and no configuration of the object taking place. An example might be a bean in the Spring configuration that creates domain objects when it is initialized by Spring. In this case you can use the ""depends-on"" bean attribute to manually specify that the bean depends on the configuration aspect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Do not activate @Configurable processing through the bean configurer aspect unless you really mean to rely on its semantics at runtime. In particular, make sure that you do not use @Configurable on bean classes which are registered as regular Spring beans with the container: You would get double initialization otherwise, once through the container and once through the aspect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"One of the goals of the @Configurable support is to enable independent unit testing of domain objects without the difficulties associated with hard-coded lookups. If @Configurable types have not been woven by AspectJ then the annotation has no affect during unit testing, and you can simply set mock or stub property references in the object under test and proceed as normal. If @Configurable types have been woven by AspectJ then you can still unit test outside of the container as normal, but you will see a warning message each time that you construct an @Configurable object indicating that it has not been configured by Spring.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The AnnotationBeanConfigurerAspect used to implement the @Configurable support is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of static members, that is to say there is one aspect instance per classloader that defines the type. This means that if you define multiple application contexts within the same classloader hierarchy you need to consider where to define the @EnableSpringConfigured bean and where to place spring-aspects.jar on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Consider a typical Spring web-app configuration with a shared parent application context defining common business services and everything needed to support them, and one child application context per servlet containing definitions particular to that servlet. All of these contexts will co-exist within the same classloader hierarchy, and so the AnnotationBeanConfigurerAspect can only hold a reference to one of them. In this case we recommend defining the @EnableSpringConfigured bean in the shared (parent) application context: this defines the services that you are likely to want to inject into domain objects. A consequence is that you cannot configure domain objects with references to beans defined in the child (servlet-specific) contexts using the @Configurable mechanism (probably not something you want to do anyway!).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When you call stored procedures you can sometimes use complex types specific to the database. To accommodate these types, Spring provides a SqlReturnType for handling them when they are returned from the stored procedure call and SqlTypeValue when they are passed in as a parameter to the stored procedure.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Here is an example of returning the value of an Oracle STRUCT object of the user declared type ITEM_TYPE. The SqlReturnType interface has a single method named getTypeValue that must be implemented. This interface is used as part of the declaration of an SqlOutParameter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"You use the SqlTypeValue to pass in the value of a Java object like TestItem into a stored procedure. The SqlTypeValue interface has a single method named createTypeValue that you must implement. The active connection is passed in, and you can use it to create database-specific objects such as StructDescriptors, as shown in the following example, or ArrayDescriptors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
This SqlTypeValue can now be added to the Map containing the input parameters for the execute call of the stored procedure.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Another use for the SqlTypeValue is passing in an array of values to an Oracle stored procedure. Oracle has its own internal ARRAY class that must be used in this case, and you can use the SqlTypeValue to create an instance of the Oracle ARRAY and populate it with values from the Java ARRAY.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The org.springframework.jdbc.datasource.embedded package provides support for embedded Java database engines. Support for HSQL, H2, and Derby is provided natively. You can also use an extensible API to plug in new embedded database types and DataSource implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"An embedded database is useful during the development phase of a project because of its lightweight nature. Benefits include ease of configuration, quick startup time, testability, and the ability to rapidly evolve SQL during development.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If you want to expose an embedded database instance as a bean in a Spring ApplicationContext, use the embedded-database tag in the spring-jdbc namespace:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The preceding configuration creates an embedded HSQL database populated with SQL from schema.sql and testdata.sql resources in the classpath. The database instance is made available to the Spring container as a bean of type javax.sql.DataSource. This bean can then be injected into data access objects as needed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The EmbeddedDatabaseBuilder class provides a fluent API for constructing an embedded database programmatically. Use this when you need to create an embedded database instance in a standalone environment, such as a data access object unit test:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Spring JDBC embedded database support can be extended in two ways:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Implement EmbeddedDatabaseConfigurer to support a new embedded database type, such as Apache Derby.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Implement DataSourceFactory to support a new DataSource implementation, such as a connection pool, to manage embedded database connections.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
You are encouraged to contribute back extensions to the Spring community at jira.springframework.org.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Spring supports HSQL 1.8.0 and above. HSQL is the default embedded database if no type is specified explicitly. To specify HSQL explicitly, set the type attribute of the embedded-database tag to HSQL. If you are using the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType.HSQL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Spring supports the H2 database as well. To enable H2, set the type attribute of the embedded-database tag to H2. If you are using the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType.H2.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Spring also supports Apache Derby 10.5 and above. To enable Derby, set the type attribute of the embedded-database tag to Derby. If using the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType.Derby.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Embedded databases provide a lightweight way to test data access code. The following is a data access unit test template that uses an embedded database:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The org.springframework.jdbc.datasource.init package provides support for initializing an existing DataSource. The embedded database support provides one option for creating and initializing a DataSource for an application, but sometimes you need to initialize an instance running on a server somewhere.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If you want to initialize a database and you can provide a reference to a DataSource bean, use the initialize-database tag in the spring-jdbc namespace:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The example above runs the two scripts specified against the database: the first script is a schema creation, and the second is a test data set insert. The script locations can also be patterns with wildcards in the usual ant style used for resources in Spring (e.g. classpath*:/com/foo/**/sql/*-data.sql). If a pattern is used the scripts are executed in lexical order of their URL or filename.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The default behavior of the database initializer is to unconditionally execute the scripts provided. This will not always be what you want, for instance if running against an existing database that already has test data in it. The likelihood of accidentally deleting data is reduced by the commonest pattern (as shown above) that creates the tables first and then inserts the data - the first step will fail if the tables already exist.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"However, to get more control over the creation and deletion of existing data, the XML namespace provides a couple more options. The first is flag to switch the initialization on and off. This can be set according to the environment (e.g. to pull a boolean value from system properties or an environment bean), e.g.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"The second option to control what happens with existing data is to be more tolerant of failures. To this end you can control the ability of the initializer to ignore certain errors in the SQL it executes from the scripts, e.g.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"In this example we are saying we expect that sometimes the scripts will be run against an empty database and there are some DROP statements in the scripts which would therefore fail. So failed SQL DROP statements will be ignored, but other failures will cause an exception. This is useful if your SQL dialect doesn't support DROP ... IF EXISTS (or similar) but you want to unconditionally remove all test data before re-creating it. In that case the first script is usually a set of drops, followed by a set of CREATE statements.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
As a result of data binding there may be errors such as missing required fields or type conversion errors. To check for such errors add a BindingResult argument immediately following the @ModelAttribute argument:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
With a BindingResult you can check if errors were found in which case it's common to render the same form where the errors can be shown with the help of Spring's <errors> form tag.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
In addition to data binding you can also invoke validation using your own custom validator passing the same BindingResult that was used to record data binding errors. That allows for data binding and validation errors to be accumulated in one place and subsequently reported back to the user:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Or you can have validation invoked automatically by adding the JSR-303 @Valid annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"See Section 7.8, “Spring 3 Validation” and Chapter 7, Validation, Data Binding, and Type Conversion for details on how to configure and use validation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The type-level @SessionAttributes annotation declares session attributes used by a specific handler. This will typically list the names of model attributes or types of model attributes which should be transparently stored in the session or some conversational storage, serving as form-backing beans between subsequent requests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The following code snippet shows the usage of this annotation, specifying the model attribute name:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When using controller interfaces (e.g., for AOP proxying), make sure to consistently put all your mapping annotations - such as @RequestMapping and @SessionAttributes - on the controller interface rather than on the implementation class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
By default all model attributes are considered to be exposed as URI template variables in the redirect URL. Of the remaining attributes those that are primitive types or collections/arrays of primitive types are automatically appended as query parameters.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In annotated controllers however the model may contain additional attributes originally added for rendering purposes (e.g. drop-down field values). To gain precise control over the attributes used in a redirect scenario, an @RequestMapping method can declare an argument of type RedirectAttributes and use it to add attributes for use in RedirectView. If the controller method does redirect, the content of RedirectAttributes is used. Otherwise the content of the default Model is used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The RedirectAttributes interface can also be used to add flash attributes. Unlike other redirect attributes, which end up in the target redirect URL, flash attributes are saved in the HTTP session (and hence do not appear in the URL). The model of the controller serving the target redirect URL automatically receives these flash attributes after which they are removed from the session. See Section 17.6, “Using flash attributes” for an overview of the general support for flash attributes in Spring MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The previous sections covered use of @ModelAttribute to support form submission requests from browser clients. The same annotation is recommended for use with requests from non-browser clients as well. However there is one notable difference when it comes to working with HTTP PUT requests. Browsers can submit form data via HTTP GET or HTTP POST. Non-browser clients can also submit forms via HTTP PUT. This presents a challenge because the Servlet specification requires the ServletRequest.getParameter*() family of methods to support form field access only for HTTP POST, not for HTTP PUT.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To support HTTP PUT and PATCH requests, the spring-web module provides the filter HttpPutFormContentFilter, which can be configured in web.xml:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The above filter intercepts HTTP PUT and PATCH requests with content type application/x-www-form-urlencoded, reads the form data from the body of the request, and wraps the ServletRequest in order to make the form data available through the ServletRequest.getParameter*() family of methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As HttpPutFormContentFilter consumes the body of the request, it should not be configured for PUT or PATCH URLs that rely on other converters for application/x-www-form-urlencoded. This includes @RequestBody MultiValueMap<String, String> and HttpEntity<MultiValueMap<String, String>>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @CookieValue annotation allows a method parameter to be bound to the value of an HTTP cookie.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Let us consider that the following cookie has been received with an http request:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following code sample demonstrates how to get the value of the JSESSIONID cookie:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Type conversion is applied automatically if the target method parameter type is not String. See the section called “Method Parameters And Type Conversion”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This annotation is supported for annotated handler methods in Servlet and Portlet environments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @RequestHeader annotation allows a method parameter to be bound to a request header.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Here is a sample request header:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following code sample demonstrates how to get the value of the Accept-Encoding and Keep-Alive headers:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Type conversion is applied automatically if the method parameter is not String. See the section called “Method Parameters And Type Conversion”.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Built-in support is available for converting a comma-separated string into an array/collection of strings or other types known to the type conversion system. For example a method parameter annotated with @RequestHeader(""Accept"") may be of type String but also String[] or List<String>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This annotation is supported for annotated handler methods in Servlet and Portlet environments.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring ships a special adapter class for OC4J 10.1.3 or later called OC4JJtaTransactionManager. This class is analogous to the WebLogicJtaTransactionManager class discussed in the previous section, providing similar value-adds on OC4J: transaction names and per-transaction isolation levels.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"The full JTA functionality, including transaction suspension, works fine with Spring's JtaTransactionManager on OC4J as well. The special OC4JJtaTransactionManager adapter simply provides value-adds beyond standard JTA.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Use the correct PlatformTransactionManager implementation based on your choice of transactional technologies and requirements. Used properly, the Spring Framework merely provides a straightforward and portable abstraction. If you are using global transactions, you must use the org.springframework.transaction.jta.JtaTransactionManager class (or an application server-specific subclass of it) for all your transactional operations. Otherwise the transaction infrastructure attempts to perform local transactions on resources such as container DataSource instances. Such local transactions do not make sense, and a good application server treats them as errors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
For more information about the Spring Framework's transaction support:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"Distributed transactions in Spring, with and without XA is a JavaWorld presentation in which SpringSource's David Syer guides you through seven patterns for distributed transactions in Spring applications, three of them with XA and four without.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
Java Transaction Design Strategies is a book available from InfoQ that provides a well-paced introduction to transactions in Java. It also includes side-by-side examples of how to configure and use transactions with both the Spring Framework and EJB3.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/transaction.html
"A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"A String value which is interpreted as view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
void if the method handles the response itself (e.g. by writing the response content directly).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Any other return type will be considered a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type's class name otherwise). The model will be implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The @RequestParam annotation is used to bind request parameters to a method parameter in your controller.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following code snippet from the PetPortal sample application shows the usage:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Parameters using this annotation are required by default, but you can specify that a parameter is optional by setting @RequestParam's required attribute to false (e.g., @RequestParam(value=""id"", required=false)).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"@ModelAttribute has two usage scenarios in controllers. When placed on a method parameter, @ModelAttribute is used to map a model attribute to the specific, annotated method parameter (see the populateSite() method below). This is how the controller gets a reference to the object holding the data entered in the form. In addition, the parameter can be declared as the specific type of the form backing object rather than as a generic java.lang.Object, thus increasing type safety.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
@ModelAttribute is also used at the method level to provide reference data for the model (see the getPetSites() method below). For this usage the method signature can contain the same types as documented above for the @RequestMapping annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Note: @ModelAttribute annotated methods will be executed before the chosen @RequestMapping annotated handler method. They effectively pre-populate the implicit model with specific attributes, often loaded from a database. Such an attribute can then already be accessed through @ModelAttribute annotated handler method parameters in the chosen handler method, potentially with binding and validation applied to it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following code snippet shows these two usages of this annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The type-level @SessionAttributes annotation declares session attributes used by a specific handler. This will typically list the names of model attributes or types of model attributes which should be transparently stored in the session or some conversational storage, serving as form-backing beans between subsequent requests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following code snippet shows the usage of this annotation:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"To customize request parameter binding with PropertyEditors, etc. via Spring's WebDataBinder, you can either use @InitBinder-annotated methods within your controller or externalize your configuration by providing a custom WebBindingInitializer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Annotating controller methods with @InitBinder allows you to configure web data binding directly within your controller class. @InitBinder identifies methods which initialize the WebDataBinder which will be used for populating command and form object arguments of annotated handler methods.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Such init-binder methods support all arguments that @RequestMapping supports, except for command/form objects and corresponding validation result objects. Init-binder methods must not have a return value. Thus, they are usually declared as void. Typical arguments include WebDataBinder in combination with WebRequest or java.util.Locale, allowing code to register context-specific editors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
The following example demonstrates the use of @InitBinder for configuring a CustomDateEditor for all java.util.Date form properties.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"To externalize data binding initialization, you can provide a custom implementation of the WebBindingInitializer interface, which you then enable by supplying a custom bean configuration for an AnnotationMethodHandlerAdapter, thus overriding the default configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The process of deploying a Spring Portlet MVC application is no different than deploying any JSR-286 Portlet application. However, this area is confusing enough in general that it is worth talking about here briefly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Generally, the portal/portlet container runs in one webapp in your servlet container and your portlets run in another webapp in your servlet container. In order for the portlet container webapp to make calls into your portlet webapp it must make cross-context calls to a well-known servlet that provides access to the portlet services defined in your portlet.xml file.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The JSR-286 specification does not specify exactly how this should happen, so each portlet container has its own mechanism for this, which usually involves some kind of “deployment process” that makes changes to the portlet webapp itself and then registers the portlets within the portlet container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"At a minimum, the web.xml file in your portlet webapp is modified to inject the well-known servlet that the portlet container will call. In some cases a single servlet will service all portlets in the webapp, in other cases there will be an instance of the servlet for each portlet.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Some portlet containers will also inject libraries and/or configuration files into the webapp as well. The portlet container must also make its implementation of the Portlet JSP Tag Library available to your webapp.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"The following method obtains the conversation identifier for the underlying scope. This identifier is different for each scope. For a session scoped implementation, this identifier can be the session identifier.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"After you write and test one or more custom Scope implementations, you need to make the Spring container aware of your new scope(s). The following method is the central method to register a new Scope with the Spring container:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This method is declared on the ConfigurableBeanFactory interface, which is available on most of the concrete ApplicationContext implementations that ship with Spring via the BeanFactory property.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The first argument to the registerScope(..) method is the unique name associated with a scope; examples of such names in the Spring container itself are singleton and prototype. The second argument to the registerScope(..) method is an actual instance of the custom Scope implementation that you wish to register and use.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Suppose that you write your custom Scope implementation, and then register it as below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The example below uses SimpleThreadScope which is included with Spring, but not registered by default. The instructions would be the same for your own custom Scope implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You then create bean definitions that adhere to the scoping rules of your custom Scope:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With a custom Scope implementation, you are not limited to programmatic registration of the scope. You can also do the Scope registration declaratively, using the CustomScopeConfigurer class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you place <aop:scoped-proxy/> in a FactoryBean implementation, it is the factory bean itself that is scoped, not the object returned from getObject().",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To interact with the container's management of the bean lifecycle, you can implement the Spring InitializingBean and DisposableBean interfaces. The container calls afterPropertiesSet() for the former and destroy() for the latter to allow the bean to perform certain actions upon initialization and destruction of your beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces. For details see Section 5.9.6, “@PostConstruct and @PreDestroy”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
If you don't want to use the JSR-250 annotations but you are still looking to remove coupling consider the use of init-method and destroy-method object definition metadata.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not offer out-of-the-box, you can implement a BeanPostProcessor yourself. For more information, see Section 5.8, “Container Extension Points”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the Lifecycle interface so that those objects can participate in the startup and shutdown process as driven by the container's own lifecycle.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The lifecycle callback interfaces are described in this section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The org.springframework.beans.factory.InitializingBean interface allows a bean to perform initialization work after all necessary properties on the bean have been set by the container. The InitializingBean interface specifies a single method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It is recommended that you do not use the InitializingBean interface because it unnecessarily couples the code to Spring. Alternatively, use the @PostConstruct annotation or specify a POJO initialization method. In the case of XML-based configuration metadata, you use the init-method attribute to specify the name of the method that has a void no-argument signature. For example, the following definition:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
...is exactly the same as...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
... but does not couple the code to Spring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Implementing the org.springframework.beans.factory.DisposableBean interface allows a bean to get a callback when the container containing it is destroyed. The DisposableBean interface specifies a single method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It is recommended that you do not use the DisposableBean callback interface because it unnecessarily couples the code to Spring. Alternatively, use the @PreDestroy annotation or specify a generic method that is supported by bean definitions. With XML-based configuration metadata, you use the destroy-method attribute on the <bean/>. For example, the following definition:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
...is exactly the same as...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
... but does not couple the code to Spring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you write initialization and destroy method callbacks that do not use the Spring-specific InitializingBean and DisposableBean callback interfaces, you typically write methods with names such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can configure the Spring container to look for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called init(), without having to configure an init-method=""init"" attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The second category of assertions go beyond the response, and allow inspecting Spring MVC specific constructs such as which controller method processed the request, whether an exception was raised and handled, what the content of the model is, what view was selected, what flash attributes were added, and so on. It is also possible to verify Servlet specific constructs such as request and session attributes. The following test asserts that binding/validation failed:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Many times when writing tests, it's useful to dump the result of the performed request. This can be done as follows, where print() is a static import from MockMvcResultHandlers:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"As long as request processing causes an unhandled exception, the print() method will print all the available result data to System.out.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In some cases, you may want to get direct access to the result and verify something that cannot be verified otherwise. This can be done by appending .andReturn() at the end after all expectations:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When all tests repeat the same expectations, you can define the common expectations once when building the MockMvc:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Note that the expectation is always applied and cannot be overridden without creating a separate MockMvc instance.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When JSON response content contains hypermedia links created with Spring HATEOAS, the resulting links can be verified:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When XML response content contains hypermedia links created with Spring HATEOAS, the resulting links can be verified:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When setting up a MockMvc, you can register one or more Filter instances:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Registered filters will be invoked through MockFilterChain from spring-test and the last filter will delegates to the DispatcherServlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The framework's own tests include many sample tests intended to demonstrate how to use Spring MVC Test. Browse these examples for further ideas. Also the spring-mvc-showcase has full test coverage based on Spring MVC Test.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Client-side tests are for code using the RestTemplate. The goal is to define expected requests and provide ""stub"" responses:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In the above example, MockRestServiceServer -- the central class for client-side REST tests -- configures the RestTemplate with a custom ClientHttpRequestFactory that asserts actual requests against expectations and returns ""stub"" responses. In this case we expect a single request to ""/greeting"" and want to return a 200 response with ""text/plain"" content. We could define as many additional requests and stub responses as necessary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Once expected requests and stub responses have been defined, the RestTemplate can be used in client-side code as usual. At the end of the tests mockServer.verify() can be used to verify that all expected requests were performed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Just like with server-side tests, the fluent API for client-side tests requires a few static imports. Those are easy to find by searching ""MockRest*"". Eclipse users should add ""MockRestRequestMatchers.*"" and ""MockRestResponseCreators.*"" as ""favorite static members"" in the Eclipse preferences under Java -> Editor -> Content Assist -> Favorites. That allows using content assist after typing the first character of the static method name. Other IDEs (e.g. IntelliJ) may not require any additional configuration. Just check the support for code completion on static members.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Spring MVC Test's own tests include example tests of client-side REST tests.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The PetClinic application, available from the samples repository, illustrates several features of the Spring TestContext Framework in a JUnit 4.5+ environment. Most test functionality is included in the AbstractClinicTests, for which a partial listing is shown below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"This test case extends the AbstractTransactionalJUnit4SpringContextTests class, from which it inherits configuration for Dependency Injection (through the DependencyInjectionTestExecutionListener) and transactional behavior (through the TransactionalTestExecutionListener).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The clinic instance variable — the application object being tested — is set by Dependency Injection through @Autowired semantics.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The testGetVets() method illustrates how you can use the inherited countRowsInTable() method to easily verify the number of rows in a given table, thus verifying correct behavior of the application code being tested. This allows for stronger tests and lessens dependency on the exact test data. For example, you can add additional rows in the database without breaking tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"Like many integration tests that use a database, most of the tests in AbstractClinicTests depend on a minimum amount of data already in the database before the test cases run. Alternatively, you might choose to populate the database within the test fixture set up of your test cases — again, within the same transaction as the tests.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The PetClinic application supports three data access technologies: JDBC, Hibernate, and JPA. By declaring @ContextConfiguration without any specific resource locations, the AbstractClinicTests class will have its application context loaded from the default location, AbstractClinicTests-context.xml, which declares a common DataSource. Subclasses specify additional context locations that must declare a PlatformTransactionManager and a concrete implementation of Clinic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"For example, the Hibernate implementation of the PetClinic tests contains the following implementation. For this example, HibernateClinicTests does not contain a single line of code: we only need to declare @ContextConfiguration, and the tests are inherited from AbstractClinicTests. Because @ContextConfiguration is declared without any specific resource locations, the Spring TestContext Framework loads an application context from all the beans defined in AbstractClinicTests-context.xml (i.e., the inherited locations) and HibernateClinicTests-context.xml, with HibernateClinicTests-context.xml possibly overriding beans defined in AbstractClinicTests-context.xml.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"In a large-scale application, the Spring configuration is often split across multiple files. Consequently, configuration locations are typically specified in a common base class for all application-specific integration tests. Such a base class may also add useful instance variables — populated by Dependency Injection, naturally — such as a SessionFactory in the case of an application using Hibernate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"When deploying multiple web-apps within the same container, ensure that each web-application loads the types in spring-aspects.jar using its own classloader (for example, by placing spring-aspects.jar in 'WEB-INF/lib'). If spring-aspects.jar is only added to the container wide classpath (and hence loaded by the shared parent classloader), all web applications will share the same aspect instance which is probably not what you want.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In addition to the @Configurable aspect, spring-aspects.jar contains an AspectJ aspect that can be used to drive Spring's transaction management for types and methods annotated with the @Transactional annotation. This is primarily intended for users who want to use the Spring Framework's transaction support outside of the Spring container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The aspect that interprets @Transactional annotations is the AnnotationTransactionAspect. When using this aspect, you must annotate the implementation class (and/or methods within that class), not the interface (if any) that the class implements. AspectJ follows Java's rule that annotations on interfaces are not inherited.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
A @Transactional annotation on a class specifies the default transaction semantics for the execution of any public operation in the class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"A @Transactional annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Methods with public, protected, and default visibility may all be annotated. Annotating protected and default visibility methods directly is the only way to get transaction demarcation for the execution of such methods.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"For AspectJ programmers that want to use the Spring configuration and transaction management support but don't want to (or cannot) use annotations, spring-aspects.jar also contains abstract aspects you can extend to provide your own pointcut definitions. See the sources for the AbstractBeanConfigurerAspect and AbstractTransactionAspect aspects for more information. As an example, the following excerpt shows how you could write an aspect to configure all instances of objects defined in the domain model using prototype bean definitions that match the fully-qualified class names:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When using AspectJ aspects with Spring applications, it is natural to both want and expect to be able to configure such aspects using Spring. The AspectJ runtime itself is responsible for aspect creation, and the means of configuring the AspectJ created aspects via Spring depends on the AspectJ instantiation model (the 'per-xxx' clause) used by the aspect.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The majority of AspectJ aspects are singleton aspects. Configuration of these aspects is very easy: simply create a bean definition referencing the aspect type as normal, and include the bean attribute 'factory-method=""aspectOf""'. This ensures that Spring obtains the aspect instance by asking AspectJ for it rather than trying to create an instance itself. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Non-singleton aspects are harder to configure: however it is possible to do so by creating prototype bean definitions and using the @Configurable support from spring-aspects.jar to configure the aspect instances once they have bean created by the AspectJ runtime.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you have some @AspectJ aspects that you want to weave with AspectJ (for example, using load-time weaving for domain model types) and other @AspectJ aspects that you want to use with Spring AOP, and these aspects are all configured using Spring, then you will need to tell the Spring AOP @AspectJ autoproxying support which exact subset of the @AspectJ aspects defined in the configuration should be used for autoproxying. You can do this by using one or more <include/> elements inside the <aop:aspectj-autoproxy/> declaration. Each <include/> element specifies a name pattern, and only beans with names matched by at least one of the patterns will be used for Spring AOP autoproxy configuration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Do not be misled by the name of the <aop:aspectj-autoproxy/> element: using it will result in the creation of Spring AOP proxies. The @AspectJ style of aspect declaration is just being used here, but the AspectJ runtime is not involved.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an application's class files as they are being loaded into the Java virtual machine (JVM). The focus of this section is on configuring and using LTW in the specific context of the Spring Framework: this section is not an introduction to LTW though. For full details on the specifics of LTW and configuring LTW with just AspectJ (with Spring not being involved at all), see the LTW section of the AspectJ Development Environment Guide.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The value-add that the Spring Framework brings to AspectJ LTW is in enabling much finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected using a Java (5+) agent, which is switched on by specifying a VM argument when starting up a JVM. It is thus a JVM-wide setting, which may be fine in some situations, but often is a little too coarse. Spring-enabled LTW enables you to switch on LTW on a per-ClassLoader basis, which obviously is more fine-grained and which can make more sense in a 'single-JVM-multiple-application' environment (such as is found in a typical application server environment).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Further, in certain environments, this support enables load-time weaving without making any modifications to the application server's launch script that will be needed to add -javaagent:path/to/aspectjweaver.jar or (as we describe later in this section) -javaagent:path/to/org.springframework.instrument-{version}.jar (previously named spring-agent.jar). Developers simply modify one or more files that form the application context to enable load-time weaving instead of relying on administrators who typically are in charge of the deployment configuration such as the launch script.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Now that the sales pitch is over, let us first walk through a quick example of AspectJ LTW using Spring, followed by detailed specifics about elements introduced in the following example. For a complete example, please see the Petclinic sample application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Let us assume that you are an application developer who has been tasked with diagnosing the cause of some performance problems in a system. Rather than break out a profiling tool, what we are going to do is switch on a simple profiling aspect that will enable us to very quickly get some performance metrics, so that we can then apply a finer-grained profiling tool to that specific area immediately afterwards.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The example presented here uses XML style configuration, it is also possible to configure and use @AspectJ with Java Configuration. Specifically the @EnableLoadTimeWeaving annotation can be used as an alternative to <context:load-time-weaver/> (see below for details).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Here is the profiling aspect. Nothing too fancy, just a quick-and-dirty time-based profiler, using the @AspectJ-style of aspect declaration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"We will also need to create an 'META-INF/aop.xml' file, to inform the AspectJ weaver that we want to weave our ProfilingAspect into our classes. This file convention, namely the presence of a file (or files) on the Java classpath called ' META-INF/aop.xml' is standard AspectJ.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Now to the Spring-specific portion of the configuration. We need to configure a LoadTimeWeaver (all explained later, just take it on trust for now). This load-time weaver is the essential component responsible for weaving the aspect configuration in one or more 'META-INF/aop.xml' files into the classes in your application. The good thing is that it does not require a lot of configuration, as can be seen below (there are some more options that you can specify, but these are detailed later).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Now that all the required artifacts are in place - the aspect, the 'META-INF/aop.xml' file, and the Spring configuration -, let us create a simple driver class with a main(..) method to demonstrate the LTW in action.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"There is one last thing to do. The introduction to this section did say that one could switch on LTW selectively on a per-ClassLoader basis with Spring, and this is true. However, just for this example, we are going to use a Java agent (supplied with Spring) to switch on the LTW. This is the command line we will use to run the above Main class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The ignore-failures option can be set to NONE (the default), DROPS (ignore failed drops) or ALL (ignore all failures).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"If you need more control than you get from the XML namespace, you can simply use the DataSourceInitializer directly, and define it as a component in your application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
A large class of applications can just use the database initializer with no further complications: those that do not use the database until after the Spring context has started. If your application is not one of those then you might need to read the rest of this section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
The database initializer depends on a data source instance and runs the scripts provided in its initialization callback (c.f. init-method in an XML bean definition or InitializingBean). If other beans depend on the same data source and also use the data source in an initialization callback then there might be a problem because the data has not yet been initialized. A common example of this is a cache that initializes eagerly and loads up data from the database on application startup.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"To get round this issue you two options: change your cache initialization strategy to a later phase, or ensure that the database initializer is initialized first.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Have your cache or a separate component that initializes the cache implement Lifecycle or SmartLifecycle. When the application context starts up a SmartLifecycle can be automatically started if its autoStartup flag is set, and a Lifecycle can be started manually by calling ConfigurableApplicationContext.start() on the enclosing context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Use a Spring ApplicationEvent or similar custom observer mechanism to trigger the cache initialization. ContextRefreshedEvent is always published by the context when it is ready for use (after all beans have been initialized), so that is often a useful hook (this is how the SmartLifecycle works by default).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"Separate the datasource and the business components that use it and control their startup order by putting them in separate ApplicationContext instances (e.g. parent has the datasource and child has the business components). This structure is common in Spring web applications, but can be more generally applied.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
Use a modular runtime like SpringSource dm Server and separate the data source and the components that depend on it. E.g. specify the bundle start up order as datasource -> initializer -> business components.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/jdbc.html
"String-based values extracted from the request including request parameters, path variables, request headers, and cookie values may need to be converted to the target type of the method parameter or field (e.g., binding a request parameter to a field in an @ModelAttribute parameter) they're bound to. If the target type is not String, Spring automatically converts to the appropriate type. All simple types such as int, long, Date, etc. are supported. You can further customize the conversion process through a WebDataBinder (see the section called “Customizing WebDataBinder initialization”) or by registering Formatters with the FormattingConversionService (see Section 7.6, “Spring 3 Field Formatting”).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To customize request parameter binding with PropertyEditors through Spring's WebDataBinder, you can use @InitBinder-annotated methods within your controller, @InitBinder methods within an @ControllerAdvice class, or provide a custom WebBindingInitializer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Annotating controller methods with @InitBinder allows you to configure web data binding directly within your controller class. @InitBinder identifies methods that initialize the WebDataBinder that will be used to populate command and form object arguments of annotated handler methods.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Such init-binder methods support all arguments that @RequestMapping supports, except for command/form objects and corresponding validation result objects. Init-binder methods must not have a return value. Thus, they are usually declared as void. Typical arguments include WebDataBinder in combination with WebRequest or java.util.Locale, allowing code to register context-specific editors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following example demonstrates the use of @InitBinder to configure a CustomDateEditor for all java.util.Date form properties.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To externalize data binding initialization, you can provide a custom implementation of the WebBindingInitializer interface, which you then enable by supplying a custom bean configuration for an AnnotationMethodHandlerAdapter, thus overriding the default configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The following example from the PetClinic application shows a configuration using a custom implementation of the WebBindingInitializer interface, org.springframework.samples.petclinic.web.ClinicBindingInitializer, which configures PropertyEditors required by several of the PetClinic controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
@InitBinder methods can also be defined in an @ControllerAdvice-annotated class in which case they apply to all controllers. This provides an alternative to using a WebBindingInitializer.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The @ControllerAdvice annotation is a component annotation allowing implementation classes to be autodetected through classpath scanning.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An @RequestMapping method may wish to support 'Last-Modified' HTTP requests, as defined in the contract for the Servlet API's getLastModified method, to facilitate content caching. This involves calculating a lastModified long value for a given request, comparing it against the 'If-Modified-Since' request header value, and potentially returning a response with status code 304 (Not Modified). An annotated controller method can achieve that as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"There are two key elements to note: calling request.checkNotModified(lastModified) and returning null. The former sets the response status to 304 before it returns true. The latter, in combination with the former, causes Spring MVC to do no further processing of the request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring MVC 3.2 introduced Servlet 3 based asynchronous request processing. Instead of returning a value, as usual, a controller method can now return a java.util.concurrent.Callable and produce the return value from a separate thread. Meanwhile the main Servlet container thread is released and allowed to process other requests. Spring MVC invokes the Callable in a separate thread with the help of a TaskExecutor and when the Callable returns, the request is dispatched back to the Servlet container to resume processing with the value returned by the Callable. Here is an example controller method:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A second option is for the controller to return an instance of DeferredResult. In this case the return value will also be produced from a separate thread. However, that thread is not known to Spring MVC. For example the result may be produced in response to some external event such as a JMS message, a scheduled task, etc. Here is an example controller method:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This may be difficult to understand without any knowledge of the Servlet 3 async processing feature. It would certainly help to read up on it. At a very minimum consider the following basic facts:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A ServletRequest can be put in asynchronous mode by calling request.startAsync(). The main effect of doing so is that the Servlet, as well as any Filters, can exit but the response will remain open allowing some other thread to complete processing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The call to request.startAsync() returns an AsyncContext, which can be used for further control over async processing. For example it provides the method dispatch, which can be called from an application thread in order to ""dispatch"" the request back to the Servlet container. An async dispatch is similar to a forward except it is made from one (application) thread to another (Servlet container) thread whereas a forward occurs synchronously in the same (Servlet container) thread.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"ServletRequest provides access to the current DispatcherType, which can be used to distinguish if a Servlet or a Filter is processing on the initial request processing thread and when it is processing in an async dispatch.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"With the above in mind, the following is the sequence of events for async request processing with a Callable: (1) Controller returns a Callable, (2) Spring MVC starts async processing and submits the Callable to a TaskExecutor for processing in a separate thread, (3) the DispatcherServlet and all Filter's exit the request processing thread but the response remains open, (4) the Callable produces a result and Spring MVC dispatches the request back to the Servlet container, (5) the DispatcherServlet is invoked again and processing resumes with the asynchronously produced result from the Callable. The exact sequencing of (2), (3), and (4) may vary depending on the speed of execution of the concurrent threads.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The sequence of events for async request processing with a DeferredResult is the same in principal except it's up to the application to produce the asynchronous result from some thread: (1) Controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed, (2) Spring MVC starts async processing, (3) the DispatcherServlet and all configured Filter's exit the request processing thread but the response remains open, (4) the application sets the DeferredResult from some thread and Spring MVC dispatches the request back to the Servlet container, (5) the DispatcherServlet is invoked again and processing resumes with the asynchronously produced result.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Explaining the motivation for async request processing and when or why to use it are beyond the scope of this document. For further information you may wish to read this blog post series.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
What happens if a Callable returned from a controller method raises an Exception while being executed? The effect is similar to what happens when any controller method raises an exception. It is handled by a matching @ExceptionHandler method in the same controller or by one of the configured HandlerExceptionResolver instances.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Under the covers, when a Callable raises an Exception, Spring MVC still dispatches to the Servlet container to resume processing. The only difference is that the result of executing the Callable is an Exception that must be processed with the configured HandlerExceptionResolver instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When using a DeferredResult, you have a choice of calling its setErrorResult(Object) method and provide an Exception or any other Object you'd like to use as the result. If the result is an Exception, it will be processed with a matching @ExceptionHandler method in the same controller or with any configured HandlerExceptionResolver instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An existing HandlerInterceptor can implement AsyncHandlerInterceptor, which provides one additional method afterConcurrentHandlingStarted. It is invoked after async processing starts and when the initial request processing thread is being exited. See the Javadoc of AsyncHandlerInterceptor for more details on that.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The bottom line is that it is important to understand the deployment needs of your target portal and make sure they are met (usually by following the automated deployment process it provides). Be sure to carefully review the documentation from your portal for this process.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
"Once you have deployed your portlet, review the resulting web.xml file for sanity. Some older portals have been known to corrupt the definition of the ViewRendererServlet, thus breaking the rendering of your portlets.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/portlet.html
Suppose that your initialization callback methods are named init() and destroy callback methods are named destroy(). Your class will resemble the class in the following example.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The presence of the default-init-method attribute on the top-level <beans/> element attribute causes the Spring IoC container to recognize a method called init on beans as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You configure destroy method callbacks similarly (in XML, that is) by using the default-destroy-method attribute on the top-level <beans/> element.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name using the init-method and destroy-method attributes of the <bean/> itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created first, then an AOP proxy (for example) with its interceptor chain is applied. If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the init method, because doing so would couple the lifecycle of the target bean with its proxy/interceptors and leave strange semantics when your code interacts directly to the raw target bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As of Spring 2.5, you have three options for controlling bean lifecycle behavior: the InitializingBean and DisposableBean callback interfaces; custom init() and destroy() methods; and the @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control a given bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If multiple lifecycle mechanisms are configured for a bean, and each mechanism is configured with a different method name, then each configured method is executed in the order listed below. However, if the same method name is configured - for example, init() for an initialization method - for more than one of these lifecycle mechanisms, that method is executed once, as explained in the preceding section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Destroy methods are called in the same order:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The Lifecycle interface defines the essential methods for any object that has its own lifecycle requirements (e.g. starts and stops some background process):,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Any Spring-managed object may implement that interface. Then, when the ApplicationContext itself starts and stops, it will cascade those calls to all Lifecycle implementations defined within that context. It does this by delegating to a LifecycleProcessor:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Notice that the LifecycleProcessor is itself an extension of the Lifecycle interface. It also adds two other methods for reacting to the context being refreshed and closed.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The order of startup and shutdown invocations can be important. If a ""depends-on"" relationship exists between any two objects, the dependent side will start after its dependency, and it will stop before its dependency. However, at times the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the SmartLifecycle interface defines another option, namely the getPhase() method as defined on its super-interface, Phased.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When starting, the objects with the lowest phase start first, and when stopping, the reverse order is followed. Therefore, an object that implements SmartLifecycle and whose getPhase() method returns Integer.MIN_VALUE would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of Integer.MAX_VALUE would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it's also important to know that the default phase for any ""normal"" Lifecycle object that does not implement SmartLifecycle would be 0. Therefore, any negative phase value would indicate that an object should start before those standard components (and stop after them), and vice versa for any positive phase value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As you can see the stop method defined by SmartLifecycle accepts a callback. Any implementation must invoke that callback's run() method after that implementation's shutdown process is complete. That enables asynchronous shutdown where necessary since the default implementation of the LifecycleProcessor interface, DefaultLifecycleProcessor, will wait up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named ""lifecycleProcessor"" within the context. If you only want to modify the timeout, then defining the following would be sufficient:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As mentioned, the LifecycleProcessor interface defines callback methods for the refreshing and closing of the context as well. The latter will simply drive the shutdown process as if stop() had been called explicitly, but it will happen when the context is closing. The 'refresh' callback on the other hand enables another feature of SmartLifecycle beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback will be invoked, and at that point the default lifecycle processor will check the boolean value returned by each SmartLifecycle object's isAutoStartup() method. If ""true"", then that object will be started at that point rather than waiting for an explicit invocation of the context's or its own start() method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The ""phase"" value as well as any ""depends-on"" relationships will determine the startup order in the same way as described above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This section applies only to non-web applications. Spring's web-based ApplicationContext implementations already have code in place to shut down the Spring IoC container gracefully when the relevant web application is shut down.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you are using Spring's IoC container in a non-web application environment; for example, in a rich client desktop environment; you register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. Of course, you must still configure and implement these destroy callbacks correctly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To register a shutdown hook, you call the registerShutdownHook() method that is declared on the AbstractApplicationContext class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When an ApplicationContext creates a class that implements the org.springframework.context.ApplicationContextAware interface, the class is provided with a reference to that ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As of Spring 2.5, autowiring is another alternative to obtain reference to the ApplicationContext. The ""traditional"" constructor and byType autowiring modes (as described in Section 5.4.5, “Autowiring collaborators”) can provide a dependency of type ApplicationContext for a constructor argument or setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the new annotation-based autowiring features. If you do, the ApplicationContext is autowired into a field, constructor argument, or method parameter that is expecting the ApplicationContext type if the field, constructor, or method in question carries the @Autowired annotation. For more information, see Section 5.9.2, “@Autowired”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As far as possible, you should have exactly the same Spring configuration files in your integration tests as in the deployed environment. One likely point of difference concerns database connection pooling and transaction infrastructure. If you are deploying to a full-blown application server, you will probably use its connection pool (available through JNDI) and JTA implementation. Thus in production you will use a JndiObjectFactoryBean or <jee:jndi-lookup> for the DataSource and JtaTransactionManager. JNDI and JTA will not be available in out-of-container integration tests, so you should use a combination like the Commons DBCP BasicDataSource and DataSourceTransactionManager or HibernateTransactionManager for them. You can factor out this variant behavior into a single XML file, having the choice between application server and a 'local' configuration separated from all other configuration, which will not vary between the test and production environments. In addition, it is advisable to use properties files for connection settings. See the PetClinic application for an example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Consult the following resources for more information about testing:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
JUnit: “ A programmer-oriented testing framework for Java ”. Used by the Spring Framework in its test suite.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"TestNG: A testing framework inspired by JUnit with added support for Java 5 annotations, test groups, data-driven testing, distributed testing, etc.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"MockObjects.com: Web site dedicated to mock objects, a technique for improving the design of code within test-driven development.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"""Mock Objects"": Article in Wikipedia.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
EasyMock: Java library “ that provides Mock Objects for interfaces (and objects through the class extension) by generating them on the fly using Java's proxy mechanism. ” Used by the Spring Framework in its test suite.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
JMock: Library that supports test-driven development of Java code with mock objects.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
Mockito: Java mock library based on the test spy pattern.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"DbUnit: JUnit extension (also usable with Ant and Maven) targeted for database-driven projects that, among other things, puts your database into a known state between test runs.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
The Grinder: Java load testing framework.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/testing.html
"The '-javaagent' is a Java 5+ flag for specifying and enabling agents to instrument programs running on the JVM. The Spring Framework ships with such an agent, the InstrumentationSavingAgent, which is packaged in the spring-instrument.jar that was supplied as the value of the -javaagent argument in the above example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
The output from the execution of the Main program will look something like that below. (I have introduced a Thread.sleep(..) statement into the calculateEntitlement() implementation so that the profiler actually captures something other than 0 milliseconds - the 01234 milliseconds is not an overhead introduced by the AOP :) ),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Since this LTW is effected using full-blown AspectJ, we are not just limited to advising Spring beans; the following slight variation on the Main program will yield the same result.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Notice how in the above program we are simply bootstrapping the Spring container, and then creating a new instance of the StubEntitlementCalculationService totally outside the context of Spring... the profiling advice still gets woven in.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The example admittedly is simplistic... however the basics of the LTW support in Spring have all been introduced in the above example, and the rest of this section will explain the 'why' behind each bit of configuration and usage in detail.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The ProfilingAspect used in this example may be basic, but it is quite useful. It is a nice example of a development-time aspect that developers can use during development (of course), and then quite easily exclude from builds of the application being deployed into UAT or production.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The aspects that you use in LTW have to be AspectJ aspects. They can be written in either the AspectJ language itself or you can write your aspects in the @AspectJ-style. The latter option is of course only an option if you are using Java 5+, but it does mean that your aspects are then both valid AspectJ and Spring AOP aspects. Furthermore, the compiled aspect classes need to be available on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The AspectJ LTW infrastructure is configured using one or more 'META-INF/aop.xml' files, that are on the Java classpath (either directly, or more typically in jar files).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The structure and contents of this file is detailed in the main AspectJ reference documentation, and the interested reader is referred to that resource. (I appreciate that this section is brief, but the 'aop.xml' file is 100% AspectJ - there is no Spring-specific information or semantics that apply to it, and so there is no extra value that I can contribute either as a result), so rather than rehash the quite satisfactory section that the AspectJ developers wrote, I am just directing you there.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
At a minimum you will need the following libraries to use the Spring Framework's support for AspectJ LTW:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"spring-aop.jar (version 2.5 or later, plus all mandatory dependencies)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
aspectjweaver.jar (version 1.6.8 or later),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are using the Spring-provided agent to enable instrumentation, you will also need:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The key component in Spring's LTW support is the LoadTimeWeaver interface (in the org.springframework.instrument.classloading package), and the numerous implementations of it that ship with the Spring distribution. A LoadTimeWeaver is responsible for adding one or more java.lang.instrument.ClassFileTransformers to a ClassLoader at runtime, which opens the door to all manner of interesting applications, one of which happens to be the LTW of aspects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If you are unfamiliar with the idea of runtime class file transformation, you are encouraged to read the Javadoc API documentation for the java.lang.instrument package before continuing. This is not a huge chore because there is - rather annoyingly - precious little documentation there... the key interfaces and classes will at least be laid out in front of you for reference as you read through this section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Configuring a LoadTimeWeaver for a particular ApplicationContext can be as easy as adding one line. (Please note that you almost certainly will need to be using an ApplicationContext as your Spring container - typically a BeanFactory will not be enough because the LTW support makes use of BeanFactoryPostProcessors.),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"To enable the Spring Framework's LTW support, you need to configure a LoadTimeWeaver, which typically is done using the @EnableLoadTimeWeaving annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Alternatively, if you prefer XML based configuration, use the <context:load-time-weaver/> element. Note that the element is defined in the 'context' namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The above configuration will define and register a number of LTW-specific infrastructure beans for you automatically, such as a LoadTimeWeaver and an AspectJWeavingEnabler. The default LoadTimeWeaver is the DefaultContextLoadTimeWeaver class, which attempts to decorate an automatically detected LoadTimeWeaver: the exact type of LoadTimeWeaver that will be 'automatically detected' is dependent upon your runtime environment (summarized in the following table).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
(java -javaagent:path/to/spring-instrument.jar),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Fallback, expecting the underlying ClassLoader to follow common conventions (e.g. applicable to TomcatInstrumentableClassLoader and Resin)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Note that these are just the LoadTimeWeavers that are autodetected when using the DefaultContextLoadTimeWeaver: it is of course possible to specify exactly which LoadTimeWeaver implementation that you wish to use.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Further options for async request lifecycle callbacks are provided directly on DeferredResult, which has the methods onTimeout(Runnable) and onCompletion(Runnable). Those are called when the async request is about to time out or has completed respectively. The timeout event can be handled by setting the DeferredResult to some value. The completion callback however is final and the result can no longer be set.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Similar callbacks are also available with a Callable. However, you will need to wrap the Callable in an instance of WebAsyncTask and then use that to register the timeout and completion callbacks. Just like with DeferredResult, the timeout event can be handled and a value can be returned while the completion event is final.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can also register a CallableProcessingInterceptor or a DeferredResultProcessingInterceptor globally through the MVC Java config or the MVC namespace. Those interceptors provide a full set of callbacks and apply every time a Callable or a DeferredResult is used.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To use Servlet 3 async request processing, you need to update web.xml to version 3.0:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The DispatcherServlet and any Filter configuration need to have the <async-supported>true</async-supported> sub-element. Additionally, any Filter that also needs to get involved in async dispatches should also be configured to support the ASYNC dispatcher type. Note that it is safe to enable the ASYNC dispatcher type for all filters provided with the Spring Framework since they will not get involved in async dispatches unless needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If using Servlet 3, Java based configuration, e.g. via WebApplicationInitializer, you'll also need to set the ""asyncSupported"" flag as well as the ASYNC dispatcher type just like with web.xml. To simplify all this configuration, consider extending AbstractDispatcherServletInitializer or AbstractAnnotationConfigDispatcherServletInitializer, which automatically set those options and make it very easy to register Filter instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The MVC Java config and the MVC namespace both provide options for configuring async request processing. WebMvcConfigurer has the method configureAsyncSupport while <mvc:annotation-driven> has an <async-support> sub-element.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Those allow you to configure the default timeout value to use for async requests, which if not set depends on the underlying Servlet container (e.g. 10 seconds on Tomcat). You can also configure an AsyncTaskExecutor to use for executing Callable instances returned from controller methods. It is highly recommended to configure this property since by default Spring MVC uses SimpleAsyncTaskExecutor. The MVC Java config and the MVC namespace also allow you to register CallableProcessingInterceptor and DeferredResultProcessingInterceptor instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you need to override the default timeout value for a specific DeferredResult, you can do so by using the appropriate class constructor. Similarly, for a Callable, you can wrap it in a WebAsyncTask and use the appropriate class constructor to customize the timeout value. The class constructor of WebAsyncTask also allows providing an AsyncTaskExecutor.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The spring-test module offers first class support for testing annotated controllers. See Section 11.3.6, “Spring MVC Test Framework”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In previous versions of Spring, users were required to define one or more HandlerMapping beans in the web application context to map incoming web requests to appropriate handlers. With the introduction of annotated controllers, you generally don't need to do that because the RequestMappingHandlerMapping automatically looks for @RequestMapping annotations on all @Controller beans. However, do keep in mind that all HandlerMapping classes extending from AbstractHandlerMapping have the following properties that you can use to customize their behavior:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"List of interceptors to use. HandlerInterceptors are discussed in Section 17.4.1, “Intercepting requests with a HandlerInterceptor”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Default handler to use, when this handler mapping does not result in a matching handler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Based on the value of the order property (see the org.springframework.core.Ordered interface), Spring sorts all handler mappings available in the context and applies the first matching handler.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If true , Spring uses the full path within the current Servlet context to find an appropriate handler. If false (the default), the path within the current Servlet mapping is used. For example, if a Servlet is mapped using /testing/* and the alwaysUseFullPath property is set to true, /testing/viewPage.html is used, whereas if the property is set to false, /viewPage.html is used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Defaults to true, as of Spring 2.5. If you prefer to compare encoded paths, set this flag to false. However, the HttpServletRequest always exposes the Servlet path in decoded form. Be aware that the Servlet path will not match when compared with encoded paths.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following example shows how to configure an interceptor:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring's handler mapping mechanism includes handler interceptors, which are useful when you want to apply specific functionality to certain requests, for example, checking for a principal.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Interceptors located in the handler mapping must implement HandlerInterceptor from the org.springframework.web.servlet package. This interface defines three methods: preHandle(..) is called before the actual handler is executed; postHandle(..) is called after the handler is executed; and afterCompletion(..) is called after the complete request has finished. These three methods should provide enough flexibility to do all kinds of preprocessing and postprocessing.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The preHandle(..) method returns a boolean value. You can use this method to break or continue the processing of the execution chain. When this method returns true, the handler execution chain will continue; when it returns false, the DispatcherServlet assumes the interceptor itself has taken care of requests (and, for example, rendered an appropriate view) and does not continue executing the other interceptors and the actual handler in the execution chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Interceptors can be configured using the interceptors property, which is present on all HandlerMapping classes extending from AbstractHandlerMapping. This is shown in the example below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Any request handled by this mapping is intercepted by the TimeBasedAccessInterceptor. If the current time is outside office hours, the user is redirected to a static HTML file that says, for example, you can only access the website during office hours.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
When using the RequestMappingHandlerMapping the actual handler is an instance of HandlerMethod which identifies the specific controller method that will be invoked.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As you can see, the Spring adapter class HandlerInterceptorAdapter makes it easier to extend the HandlerInterceptor interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When an ApplicationContext creates a class that implements the org.springframework.beans.factory.BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBeans afterPropertiesSet or a custom init-method.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Besides ApplicationContextAware and BeanNameAware discussed above, Spring offers a range of Aware interfaces that allow beans to indicate to the container that they require a certain infrastructure dependency. The most important Aware interfaces are summarized below - as a general rule, the name is a good indication of the dependency type:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Class loader used to load the bean classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Configured strategy for resolving messages (with support for parametrization and internationalization),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Note again that usage of these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As such, they are recommended for infrastructure beans that require programmatic access to the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information such as initialization method, static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you work with an ApplicationContext interface programmatically, child bean definitions are represented by the ChildBeanDefinition class. Most users do not work with them on this level, instead configuring bean definitions declaratively in something like the ClassPathXmlApplicationContext. When you use XML-based configuration metadata, you indicate a child bean definition by using the parent attribute, specifying the parent bean as the value of this attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A child bean definition uses the bean class from the parent definition if none is specified, but can also override it. In the latter case, the child bean class must be compatible with the parent, that is, it must accept the parent's property values.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A child bean definition inherits scope, constructor argument values, property values, and method overrides from the parent, with the option to add new values. Any scope, initialization method, destroy method, and/or static factory method settings that you specify will override the corresponding parent settings.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The remaining settings are always taken from the child definition: depends on, autowire mode, dependency check, singleton, lazy init.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The preceding example explicitly marks the parent bean definition as abstract by using the abstract attribute. If the parent definition does not specify a class, explicitly marking the parent bean definition as abstract is required, as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as abstract. When a definition is abstract like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions. Trying to use such an abstract parent bean on its own, by referring to it as a ref property of another bean or doing an explicit getBean() call with the parent bean id, returns an error. Similarly, the container's internal preInstantiateSingletons() method ignores bean definitions that are defined as abstract.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"ApplicationContext pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the abstract attribute to true, otherwise the application context will actually (attempt to) pre-instantiate the abstract bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Typically, an application developer does not need to subclass ApplicationContext implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The BeanPostProcessor interface defines callback methods that you can implement to provide your own (or override the container's default) instantiation logic, dependency-resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more BeanPostProcessor implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"BeanPostProcessors operate on bean (or object) instances; that is to say, the Spring IoC container instantiates a bean instance and then BeanPostProcessors do their work.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"BeanPostProcessors are scoped per-container. This is only relevant if you are using container hierarchies. If you define a BeanPostProcessor in one container, it will only post-process the beans in that container. In other words, beans that are defined in one container are not post-processed by a BeanPostProcessor defined in another container, even if both containers are part of the same hierarchy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To change the actual bean definition (i.e., the blueprint that defines the bean), you instead need to use a BeanFactoryPostProcessor as described in Section 5.8.2, “Customizing configuration metadata with a BeanFactoryPostProcessor”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The org.springframework.beans.factory.config.BeanPostProcessor interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as InitializingBean's afterPropertiesSet() and any declared init method) are called as well as after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
An ApplicationContext automatically detects any beans that are defined in the configuration metadata which implement the BeanPostProcessor interface. The ApplicationContext registers these beans as post-processors so that they can be called later upon bean creation. Bean post-processors can be deployed in the container just like any other beans.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"While the recommended approach for BeanPostProcessor registration is through ApplicationContext auto-detection (as described above), it is also possible to register them programmatically against a ConfigurableBeanFactory using the addBeanPostProcessor method. This can be useful when needing to evaluate conditional logic before registration, or even for copying bean post processors across contexts in a hierarchy. Note however that BeanPostProcessors added programmatically do not respect the Ordered interface. Here it is the order of registration that dictates the order of execution. Note also that BeanPostProcessors registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Classes that implement the BeanPostProcessor interface are special and are treated differently by the container. All BeanPostProcessors and beans that they reference directly are instantiated on startup, as part of the special startup phase of the ApplicationContext. Next, all BeanPostProcessors are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a BeanPostProcessor itself, neither BeanPostProcessors nor the beans they reference directly are eligible for auto-proxying, and thus do not have aspects woven into them.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
To specify a specific LoadTimeWeaver with Java configuration implement the LoadTimeWeavingConfigurer interface and override the getLoadTimeWeaver() method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
If you are using XML based configuration you can specify the fully-qualified classname as the value of the 'weaver-class' attribute on the <context:load-time-weaver/> element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The LoadTimeWeaver that is defined and registered by the configuration can be later retrieved from the Spring container using the well-known name 'loadTimeWeaver'. Remember that the LoadTimeWeaver exists just as a mechanism for Spring's LTW infrastructure to add one or more ClassFileTransformers. The actual ClassFileTransformer that does the LTW is the ClassPreProcessorAgentAdapter (from the org.aspectj.weaver.loadtime package) class. See the class-level Javadoc for the ClassPreProcessorAgentAdapter class for further details, because the specifics of how the weaving is actually effected is beyond the scope of this section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"There is one final attribute of the configuration left to discuss: the 'aspectjWeaving' attribute (or 'aspectj-weaving' if you are using XML). This is a simple attribute that controls whether LTW is enabled or not, it is as simple as that. It accepts one of three possible values, summarized below, with the default value if the attribute is not present being 'autodetect'",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"AspectJ weaving is on, and aspects will be woven at load-time as appropriate.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
LTW is off... no aspect will be woven at load-time.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"If the Spring LTW infrastructure can find at least one 'META-INF/aop.xml' file, then AspectJ weaving is on, else it is off. This is the default value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
This last section contains any additional settings and configuration that you will need when using Spring's LTW support in environments such as application servers and web containers.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Apache Tomcat's default class loader does not support class transformation which is why Spring provides an enhanced implementation that addresses this need. Named TomcatInstrumentableClassLoader, the loader works on Tomcat 5.0 and above and can be registered individually for each web application as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Copy org.springframework.instrument.tomcat.jar into $CATALINA_HOME/lib, where $CATALINA_HOME represents the root of the Tomcat installation)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Instruct Tomcat to use the custom class loader (instead of the default) by editing the web application context file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Apache Tomcat 6.0.x (similar to 5.0.x/5.5.x) series supports several context locations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"For efficiency, the embedded per-web-app configuration style is recommended because it will impact only applications that use the custom class loader and does not require any changes to the server configuration. See the Tomcat 6.0.x documentation for more details about available context locations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Copy org.springframework.instrument.tomcat.jar into $CATALINA_HOME/server/lib, where $CATALINA_HOME represents the root of the Tomcat installation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Instruct Tomcat to use the custom class loader instead of the default one by editing the web application context file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
Tomcat 5.0.x and 5.5.x series supports several context locations:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"For efficiency, the embedded web-app configuration style is recommended recommended because it will impact only applications that use the class loader. See the Tomcat 5.x documentation for more details about available context locations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Tomcat versions prior to 5.5.20 contained a bug in the XML configuration parsing that prevented usage of the Loader tag inside server.xml configuration, regardless of whether a class loader is specified or whether it is the official or a custom one. See Tomcat's bugzilla for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In Tomcat 5.5.x, versions 5.5.20 or later, you should set useSystemClassLoaderAsParent to false to fix this problem:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
This setting is not needed on Tomcat 6 or higher.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Alternatively, consider the use of the Spring-provided generic VM agent, to be specified in Tomcat's launch script (see above). This will make instrumentation available to all deployed web applications, no matter what ClassLoader they happen to run on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Recent versions of BEA WebLogic (version 10 and above), IBM WebSphere Application Server (version 7 and above), Oracle Containers for Java EE (OC4J 10.1.3.1 and above), Resin (3.1 and above) and JBoss (5.x or above) provide a ClassLoader that is capable of local instrumentation. Spring's native LTW leverages such ClassLoaders to enable AspectJ weaving. You can enable LTW by simply activating load-time weaving as described earlier. Specifically, you do not need to modify the launch script to add -javaagent:path/to/spring-instrument.jar.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR environment. For GlassFish web applications, follow the Tomcat setup instructions as outlined above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from loading the classes before the application actually starts. A quick workaround is to add to your artifact a file named WEB-INF/jboss-scanning.xml with the following content:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"When class instrumentation is required in environments that do not support or are not supported by the existing LoadTimeWeaver implementations, a JDK agent can be the only solution. For such cases, Spring provides InstrumentationLoadTimeWeaver, which requires a Spring-specific (but very general) VM agent, org.springframework.instrument-{version}.jar (previously named spring-agent.jar).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"In the example above, the configured interceptor will apply to all requests handled with annotated controller methods. If you want to narrow down the URL paths to which an interceptor applies, you can use the MVC namespace or the MVC Java config, or declare bean instances of type MappedInterceptor to do that. See Enabling the MVC Java Config or the MVC XML Namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"All MVC frameworks for web applications provide a way to address views. Spring provides view resolvers, which enable you to render models in a browser without tying you to a specific view technology. Out of the box, Spring enables you to use JSPs, Velocity templates and XSLT views, for example. See Chapter 18, View technologies for a discussion of how to integrate and use a number of disparate view technologies.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The two interfaces that are important to the way Spring handles views are ViewResolver and View. The ViewResolver provides a mapping between view names and actual views. The View interface addresses the preparation of the request and hands the request over to one of the view technologies.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As discussed in Section 17.3, “Implementing Controllers”, all handler methods in the Spring Web MVC controllers must resolve to a logical view name, either explicitly (e.g., by returning a String, View, or ModelAndView) or implicitly (i.e., based on conventions). Views in Spring are addressed by a logical view name and are resolved by a view resolver. Spring comes with quite a few view resolvers. This table lists most of them; a couple of examples follow.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As an example, with JSP as a view technology, you can use the UrlBasedViewResolver. This view resolver translates a view name to a URL and hands the request over to the RequestDispatcher to render the view.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When returning test as a logical view name, this view resolver forwards the request to the RequestDispatcher that will send the request to /WEB-INF/jsp/test.jsp.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When you combine different view technologies in a web application, you can use the ResourceBundleViewResolver:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The ResourceBundleViewResolver inspects the ResourceBundle identified by the basename, and for each view it is supposed to resolve, it uses the value of the property [viewname].(class) as the view class and the value of the property [viewname].url as the view url. Examples can be found in the next chapter which covers view technologies. As you can see, you can identify a parent view, from which all views in the properties file “extend”. This way you can specify a default view class, for example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Subclasses of AbstractCachingViewResolver cache view instances that they resolve. Caching improves performance of certain view technologies. It's possible to turn off the cache by setting the cache property to false. Furthermore, if you must refresh a certain view at runtime (for example when a Velocity template is modified), you can use the removeFromCache(String viewName, Locale loc) method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring supports multiple view resolvers. Thus you can chain resolvers and, for example, override specific views in certain circumstances. You chain view resolvers by adding more than one resolver to your application context and, if necessary, by setting the order property to specify ordering. Remember, the higher the order property, the later the view resolver is positioned in the chain.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the following example, the chain of view resolvers consists of two resolvers, an InternalResourceViewResolver, which is always automatically positioned as the last resolver in the chain, and an XmlViewResolver for specifying Excel views. Excel views are not supported by the InternalResourceViewResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If a specific view resolver does not result in a view, Spring examines the context for other view resolvers. If additional view resolvers exist, Spring continues to inspect them until a view is resolved. If no view resolver returns a view, Spring throws a ServletException.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The contract of a view resolver specifies that a view resolver can return null to indicate the view could not be found. Not all view resolvers do this, however, because in some cases, the resolver simply cannot detect whether or not the view exists. For example, the InternalResourceViewResolver uses the RequestDispatcher internally, and dispatching is the only way to figure out if a JSP exists, but this action can only execute once. The same holds for the VelocityViewResolver and some others. Check the Javadoc for the view resolver to see whether it reports non-existing views. Thus, putting an InternalResourceViewResolver in the chain in a place other than the last, results in the chain not being fully inspected, because the InternalResourceViewResolver will always return a view!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As mentioned previously, a controller typically returns a logical view name, which a view resolver resolves to a particular view technology. For view technologies such as JSPs that are processed through the Servlet or JSP engine, this resolution is usually handled through the combination of InternalResourceViewResolver and InternalResourceView, which issues an internal forward or include via the Servlet API's RequestDispatcher.forward(..) method or RequestDispatcher.include() method. For other view technologies, such as Velocity, XSLT, and so on, the view itself writes the content directly to the response stream.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"It is sometimes desirable to issue an HTTP redirect back to the client, before the view is rendered. This is desirable, for example, when one controller has been called with POSTed data, and the response is actually a delegation to another controller (for example on a successful form submission). In this case, a normal internal forward will mean that the other controller will also see the same POST data, which is potentially problematic if it can confuse it with other expected data. Another reason to perform a redirect before displaying the result is to eliminate the possibility of the user submitting the form data multiple times. In this scenario, the browser will first send an initial POST; it will then receive a response to redirect to a different URL; and finally the browser will perform a subsequent GET for the URL named in the redirect response. Thus, from the perspective of the browser, the current page does not reflect the result of a POST but rather of a GET. The end effect is that there is no way the user can accidentally re-POST the same data by performing a refresh. The refresh forces a GET of the result page, not a resend of the initial POST data.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"One way to force a redirect as the result of a controller response is for the controller to create and return an instance of Spring's RedirectView. In this case, DispatcherServlet does not use the normal view resolution mechanism. Rather because it has been given the (redirect) view already, the DispatcherServlet simply instructs the view to do its work.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The RedirectView issues an HttpServletResponse.sendRedirect() call that returns to the client browser as an HTTP redirect. By default all model attributes are considered to be exposed as URI template variables in the redirect URL. Of the remaining attributes those that are primitive types or collections/arrays of primitive types are automatically appended as query parameters.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Appending primitive type attributes as query parameters may be the desired result if a model instance was prepared specifically for the redirect. However, in annotated controllers the model may contain additional attributes added for rendering purposes (e.g. drop-down field values). To avoid the possibility of having such attributes appear in the URL an annotated controller can declare an argument of type RedirectAttributes and use it to specify the exact attributes to make available to RedirectView. If the controller method decides to redirect, the content of RedirectAttributes is used. Otherwise the content of the model is used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Note that URI template variables from the present request are automatically made available when expanding a redirect URL and do not need to be added explicitly neither through Model nor RedirectAttributes. For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you use RedirectView and the view is created by the controller itself, it is recommended that you configure the redirect URL to be injected into the controller so that it is not baked into the controller but configured in the context along with the view names. The next section discusses this process.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"While the use of RedirectView works fine, if the controller itself creates the RedirectView, there is no avoiding the fact that the controller is aware that a redirection is happening. This is really suboptimal and couples things too tightly. The controller should not really care about how the response gets handled. In general it should operate only in terms of view names that have been injected into it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The special redirect: prefix allows you to accomplish this. If a view name is returned that has the prefix redirect:, the UrlBasedViewResolver (and all subclasses) will recognize this as a special indication that a redirect is needed. The rest of the view name will be treated as the redirect URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The net effect is the same as if the controller had returned a RedirectView, but now the controller itself can simply operate in terms of logical view names. A logical view name such as redirect:/myapp/some/resource will redirect relative to the current Servlet context, while a name such as redirect:http://myhost.com/some/arbitrary/path will redirect to an absolute URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"It is also possible to use a special forward: prefix for view names that are ultimately resolved by UrlBasedViewResolver and subclasses. This creates an InternalResourceView (which ultimately does a RequestDispatcher.forward()) around the rest of the view name, which is considered a URL. Therefore, this prefix is not useful with InternalResourceViewResolver and InternalResourceView (for JSPs for example). But the prefix can be helpful when you are primarily using another view technology, but still want to force a forward of a resource to be handled by the Servlet/JSP engine. (Note that you may also chain multiple view resolvers, instead.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"For any such bean, you should see an informational log message: “Bean foo is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Note that if you have beans wired into your BeanPostProcessor using autowiring or @Resource (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates, and therefore make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with @Resource where the field/setter name does not directly correspond to the declared name of a bean and no name attribute is used, then Spring will access other beans for matching them by type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following examples show how to write, register, and use BeanPostProcessors in an ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This first example illustrates basic usage. The example shows a custom BeanPostProcessor implementation that invokes the toString() method of each bean as it is created by the container and prints the resulting string to the system console.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Find below the custom BeanPostProcessor implementation class definition:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Notice how the InstantiationTracingBeanPostProcessor is simply defined. It does not even have a name, and because it is a bean it can be dependency-injected just like any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring 2.0 dynamic language support is detailed in the chapter entitled Chapter 28, Dynamic language support.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following simple Java application executes the preceding code and configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The output of the preceding application resembles the following:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Using callback interfaces or annotations in conjunction with a custom BeanPostProcessor implementation is a common means of extending the Spring IoC container. An example is Spring's RequiredAnnotationBeanPostProcessor  a BeanPostProcessor implementation that ships with the Spring distribution which ensures that JavaBean properties on beans that are marked with an (arbitrary) annotation are actually (configured to be) dependency-injected with a value.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The next extension point that we will look at is the org.springframework.beans.factory.config.BeanFactoryPostProcessor. The semantics of this interface are similar to those of the BeanPostProcessor, with one major difference: BeanFactoryPostProcessors operate on the bean configuration metadata; that is, the Spring IoC container allows BeanFactoryPostProcessors to read the configuration metadata and potentially change it before the container instantiates any beans other than BeanFactoryPostProcessors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can configure multiple BeanFactoryPostProcessors, and you can control the order in which these BeanFactoryPostProcessors execute by setting the order property. However, you can only set this property if the BeanFactoryPostProcessor implements the Ordered interface. If you write your own BeanFactoryPostProcessor, you should consider implementing the Ordered interface too. Consult the Javadoc for the BeanFactoryPostProcessor and Ordered interfaces for more details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you want to change the actual bean instances (i.e., the objects that are created from the configuration metadata), then you instead need to use a BeanPostProcessor (described above in Section 5.8.1, “Customizing beans using a BeanPostProcessor”). While it is technically possible to work with bean instances within a BeanFactoryPostProcessor (e.g., using BeanFactory.getBean()), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects such as bypassing bean post processing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Also, BeanFactoryPostProcessors are scoped per-container. This is only relevant if you are using container hierarchies. If you define a BeanFactoryPostProcessor in one container, it will only be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by BeanFactoryPostProcessors in another container, even if both containers are part of the same hierarchy.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A bean factory post-processor is executed automatically when it is declared inside an ApplicationContext, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and PropertyPlaceholderConfigurer. A custom BeanFactoryPostProcessor can also be used, for example, to register custom property editors.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"An ApplicationContext automatically detects any beans that are deployed into it that implement the BeanFactoryPostProcessor interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As with BeanPostProcessors, you typically do not want to configure BeanFactoryPostProcessors for lazy initialization. If no other bean references a Bean(Factory)PostProcessor, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the Bean(Factory)PostProcessor will be instantiated eagerly even if you set the default-lazy-init attribute to true on the declaration of your <beans /> element.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You use the PropertyPlaceholderConfigurer to externalize property values from a bean definition in a separate file using the standard Java Properties format. Doing so enables the person deploying an application to customize environment-specific properties such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Consider the following XML-based configuration metadata fragment, where a DataSource with placeholder values is defined. The example shows properties configured from an external Properties file. At runtime, a PropertyPlaceholderConfigurer is applied to the metadata that will replace some properties of the DataSource. The values to replace are specified as placeholders of the form ${property-name} which follows the Ant / log4j / JSP EL style.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The actual values come from another file in the standard Java Properties format:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Therefore, the string ${jdbc.username} is replaced at runtime with the value 'sa', and the same applies for other placeholder values that match keys in the properties file. The PropertyPlaceholderConfigurer checks for placeholders in most properties and attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be customized.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With the context namespace introduced in Spring 2.5, it is possible to configure property placeholders with a dedicated configuration element. One or more locations can be provided as a comma-separated list in the location attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The PropertyPlaceholderConfigurer not only looks for properties in the Properties file you specify. By default it also checks against the Java System properties if it cannot find a property in the specified properties files. You can customize this behavior by setting the systemPropertiesMode property of the configurer with one of the following three supported integer values:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To use it, you must start the virtual machine with the Spring agent, by supplying the following JVM options:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"Note that this requires modification of the VM launch script which may prevent you from using this in application server environments (depending on your operation policies). Additionally, the JDK agent will instrument the entire VM which can prove expensive.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"For performance reasons, it is recommended to use this configuration only if your target environment (such as Jetty) does not have (or does not support) a dedicated LTW.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
More information on AspectJ can be found on the AspectJ website.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The book Eclipse AspectJ by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a comprehensive introduction and reference for the AspectJ language.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"The book AspectJ in Action by Ramnivas Laddad (Manning, 2003) comes highly recommended; the focus of the book is on AspectJ, but a lot of general AOP themes are explored (in some depth).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html
"As with the redirect: prefix, if the view name with the forward: prefix is injected into the controller, the controller does not detect that anything special is happening in terms of handling the response.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The ContentNegotiatingViewResolver does not resolve views itself but rather delegates to other view resolvers, selecting the view that resembles the representation requested by the client. Two strategies exist for a client to request a representation from the server:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Use a distinct URI for each resource, typically by using a different file extension in the URI. For example, the URI http://www.example.com/users/fred.pdf requests a PDF representation of the user fred, and http://www.example.com/users/fred.xml requests an XML representation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Use the same URI for the client to locate the resource, but set the Accept HTTP request header to list the media types that it understands. For example, an HTTP request for http://www.example.com/users/fred with an Accept header set to application/pdf requests a PDF representation of the user fred, while http://www.example.com/users/fred with an Accept header set to text/xml requests an XML representation. This strategy is known as content negotiation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"One issue with the Accept header is that it is impossible to set it in a web browser within HTML. For example, in Firefox, it is fixed to:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
For this reason it is common to see the use of a distinct URI for each representation when developing browser based web applications.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To support multiple representations of a resource, Spring provides the ContentNegotiatingViewResolver to resolve a view based on the file extension or Accept header of the HTTP request. ContentNegotiatingViewResolver does not perform the view resolution itself but instead delegates to a list of view resolvers that you specify through the bean property ViewResolvers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The ContentNegotiatingViewResolver selects an appropriate View to handle the request by comparing the request media type(s) with the media type (also known as Content-Type) supported by the View associated with each of its ViewResolvers. The first View in the list that has a compatible Content-Type returns the representation to the client. If a compatible view cannot be supplied by the ViewResolver chain, then the list of views specified through the DefaultViews property will be consulted. This latter option is appropriate for singleton Views that can render an appropriate representation of the current resource regardless of the logical view name. The Accept header may include wild cards, for example text/*, in which case a View whose Content-Type was text/xml is a compatible match.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To support the resolution of a view based on a file extension, use the ContentNegotiatingViewResolver bean property mediaTypes to specify a mapping of file extensions to media types. For more information on the algorithm used to determine the request media type, refer to the API documentation for ContentNegotiatingViewResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Here is an example configuration of a ContentNegotiatingViewResolver:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The InternalResourceViewResolver handles the translation of view names and JSP pages, while the BeanNameViewResolver returns a view based on the name of a bean. (See ""Resolving views with the ViewResolver interface"" for more details on how Spring looks up and instantiates a view.) In this example, the content bean is a class that inherits from AbstractAtomFeedView, which returns an Atom RSS feed. For more information on creating an Atom Feed representation, see the section Atom Views.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the above configuration, if a request is made with an .html extension, the view resolver looks for a view that matches the text/html media type. The InternalResourceViewResolver provides the matching view for text/html. If the request is made with the file extension .atom, the view resolver looks for a view that matches the application/atom+xml media type. This view is provided by the BeanNameViewResolver that maps to the SampleContentAtomView if the view name returned is content. If the request is made with the file extension .json, the MappingJackson2JsonViewinstance from the DefaultViews list will be selected regardless of the view name. Alternatively, client requests can be made without a file extension but with the Accept header set to the preferred media-type, and the same resolution of request to views would occur.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If ContentNegotiatingViewResolver's list of ViewResolvers is not configured explicitly, it automatically uses any ViewResolvers defined in the application context.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The corresponding controller code that returns an Atom RSS feed for a URI of the form http://localhost/content.atom or http://localhost/content with an Accept header of application/atom+xml is shown below.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Flash attributes provide a way for one request to store attributes intended for use in another. This is most commonly needed when redirecting — for example, the Post/Redirect/Get pattern. Flash attributes are saved temporarily before the redirect (typically in the session) to be made available to the request after the redirect and removed immediately.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring MVC has two main abstractions in support of flash attributes. FlashMap is used to hold flash attributes while FlashMapManager is used to store, retrieve, and manage FlashMap instances.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Flash attribute support is always ""on"" and does not need to enabled explicitly although if not used, it never causes HTTP session creation. On each request there is an ""input"" FlashMap with attributes passed from a previous request (if any) and an ""output"" FlashMap with attributes to save for a subsequent request. Both FlashMap instances are accessible from anywhere in Spring MVC through static methods in RequestContextUtils.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Annotated controllers typically do not need to work with FlashMap directly. Instead an @RequestMapping method can accept an argument of type RedirectAttributes and use it to add flash attributes for a redirect scenario. Flash attributes added via RedirectAttributes are automatically propagated to the ""output"" FlashMap. Similarly after the redirect attributes from the ""input"" FlashMap are automatically added to the Model of the controller serving the target URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The concept of flash attributes exists in many other Web frameworks and has proven to be exposed sometimes to concurrency issues. This is because by definition flash attributes are to be stored until the next request. However the very ""next"" request may not be the intended recipient but another asynchronous request (e.g. polling or resource requests) in which case the flash attributes are removed too early.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To reduce the possibility of such issues, RedirectView automatically ""stamps"" FlashMap instances with the path and query parameters of the target redirect URL. In turn the default FlashMapManager matches that information to incoming requests when looking up the ""input"" FlashMap.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This does not eliminate the possibility of a concurrency issue entirely but nevertheless reduces it greatly with information that is already available in the redirect URL. Therefore the use of flash attributes is recommended mainly for redirect scenarios .,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring MVC provides a mechanism for building and encoding a URI using UriComponentsBuilder and UriComponents.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
For example you can expand and encode a URI template string:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Note that UriComponents is immutable and the expand() and encode() operations return new instances if necessary.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
fallback (1): Check system properties if not resolvable in the specified properties files. This is the default.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"override (2): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Consult the Javadoc for the PropertyPlaceholderConfigurer for more information.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can use the PropertyPlaceholderConfigurer to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the preInstantiateSingletons() phase of an ApplicationContext for a non-lazy-init bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The PropertyOverrideConfigurer, another bean factory post-processor, resembles the PropertyPlaceholderConfigurer, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding Properties file does not have an entry for a certain bean property, the default context definition is used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple PropertyOverrideConfigurer instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Properties file configuration lines take this format:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
For example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This example file can be used with a container definition that contains a bean called dataSource, which has driver and url properties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In this example...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
... the sammy property of the bob property of the fred property of the foo bean is set to the scalar value 123.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Specified override values are always literal values; they are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With the context namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Implement the org.springframework.beans.factory.FactoryBean interface for objects that are themselves factories.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The FactoryBean interface is a point of pluggability into the Spring IoC container's instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The FactoryBean interface provides three methods:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Object getObject(): returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"boolean isSingleton(): returns true if this FactoryBean returns singletons, false otherwise.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Class getObjectType(): returns the object type returned by the getObject() method or null if the type is not known in advance.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The FactoryBean concept and interface is used in a number of places within the Spring Framework; more than 50 implementations of the FactoryBean interface ship with Spring itself.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you need to ask a container for an actual FactoryBean instance itself instead of the bean it produces, preface the bean's id with the ampersand symbol (&) when calling the getBean() method of the ApplicationContext. So for a given FactoryBean with an id of myBean, invoking getBean(""myBean"") on the container returns the product of the FactoryBean; whereas, invoking getBean(""&myBean"") returns the FactoryBean instance itself.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Are annotations better than XML for configuring Spring?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The introduction of annotation-based configurations raised the question of whether this approach is 'better' than XML. The short answer is it depends. The long answer is that each approach has its pros and cons, and usually it is up to the developer to decide which strategy suits her better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"No matter the choice, Spring can accommodate both styles and even mix them together. It's worth pointing out that through its JavaConfig option, Spring allows annotations to be used in a non-invasive way, without touching the target components source code and that in terms of tooling, all configuration styles are supported by the SpringSource Tool Suite.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"An alternative to XML setups is provided by annotation-based configuration which rely on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in the section called “Example: The RequiredAnnotationBeanPostProcessor”, using a BeanPostProcessor in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the @Required annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring's dependency injection. Essentially, the @Autowired annotation provides the same capabilities as described in Section 5.4.5, “Autowiring collaborators” but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations such as @PostConstruct, and @PreDestroy. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the javax.inject package such as @Inject and @Named. Details about those annotations can be found in the relevant section.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Annotation injection is performed before XML injection, thus the latter configuration will override the former for properties wired through both approaches.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As always, you can register them as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the context namespace):",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also expand and encode using individual URI components:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
In a Servlet environment the ServletUriComponentsBuilder sub-class provides static factory methods to copy available URL information from a Servlet requests:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Alternatively, you may choose to copy a subset of the available information up to and including the context path:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Or in cases where the DispatcherServlet is mapped by name (e.g. /main/*), you can also have the literal part of the servlet mapping included:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Most parts of Spring's architecture support internationalization, just as the Spring web MVC framework does. DispatcherServlet enables you to automatically resolve messages using the client's locale. This is done with LocaleResolver objects.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When a request comes in, the DispatcherServlet looks for a locale resolver, and if it finds one it tries to use it to set the locale. Using the RequestContext.getLocale() method, you can always retrieve the locale that was resolved by the locale resolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In addition to automatic locale resolution, you can also attach an interceptor to the handler mapping (see Section 17.4.1, “Intercepting requests with a HandlerInterceptor” for more information on handler mapping interceptors) to change the locale under specific circumstances, for example, based on a parameter in the request.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Locale resolvers and interceptors are defined in the org.springframework.web.servlet.i18n package and are configured in your application context in the normal way. Here is a selection of the locale resolvers included in Spring.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This locale resolver inspects the accept-language header in the request that was sent by the client (e.g., a web browser). Usually this header field contains the locale of the client's operating system.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This locale resolver inspects a Cookie that might exist on the client to see if a locale is specified. If so, it uses the specified locale. Using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. Find below an example of defining a CookieLocaleResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The SessionLocaleResolver allows you to retrieve locales from the session that might be associated with the user's request.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can enable changing of locales by adding the LocaleChangeInterceptor to one of the handler mappings (see Section 17.4, “Handler mappings”). It will detect a parameter in the request and change the locale. It calls setLocale() on the LocaleResolver that also exists in the context. The following example shows that calls to all *.view resources containing a parameter named siteLanguage will now change the locale. So, for example, a request for the following URL, http://www.sf.net/home.view?siteLanguage=nl will change the site language to Dutch.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can apply Spring Web MVC framework themes to set the overall look-and-feel of your application, thereby enhancing user experience. A theme is a collection of static resources, typically style sheets and images, that affect the visual style of the application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"To use themes in your web application, you must set up an implementation of the org.springframework.ui.context.ThemeSource interface. The WebApplicationContext interface extends ThemeSource but delegates its responsibilities to a dedicated implementation. By default the delegate will be an org.springframework.ui.context.support.ResourceBundleThemeSource implementation that loads properties files from the root of the classpath. To use a custom ThemeSource implementation or to configure the base name prefix of the ResourceBundleThemeSource, you can register a bean in the application context with the reserved name themeSource. The web application context automatically detects a bean with that name and uses it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When using the ResourceBundleThemeSource, a theme is defined in a simple properties file. The properties file lists the resources that make up the theme. Here is an example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The keys of the properties are the names that refer to the themed elements from view code. For a JSP, you typically do this using the spring:theme custom tag, which is very similar to the spring:message tag. The following JSP fragment uses the theme defined in the previous example to customize the look and feel:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"By default, the ResourceBundleThemeSource uses an empty base name prefix. As a result, the properties files are loaded from the root of the classpath. Thus you would put the cool.properties theme definition in a directory at the root of the classpath, for example, in /WEB-INF/classes. The ResourceBundleThemeSource uses the standard Java resource bundle loading mechanism, allowing for full internationalization of themes. For example, we could have a /WEB-INF/classes/cool_nl.properties that references a special background image with Dutch text on it.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"After you define themes, as in the preceding section, you decide which theme to use. The DispatcherServlet will look for a bean named themeResolver to find out which ThemeResolver implementation to use. A theme resolver works in much the same way as a LocaleResolver. It detects the theme to use for a particular request and can also alter the request's theme. The following theme resolvers are provided by Spring:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring also provides a ThemeChangeInterceptor that allows theme changes on every request with a simple request parameter.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring's built-in multipart support handles file uploads in web applications. You enable this multipart support with pluggable MultipartResolver objects, defined in the org.springframework.web.multipart package. Spring provides one MultipartResolver implementation for use with Commons FileUpload and another for use with Servlet 3.0 multipart request parsing.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"By default, Spring does no multipart handling, because some developers want to handle multiparts themselves. You enable Spring multipart handling by adding a multipart resolver to the web application's context. Each request is inspected to see if it contains a multipart. If no multipart is found, the request continues as expected. If a multipart is found in the request, the MultipartResolver that has been declared in your context is used. After that, the multipart attribute in your request is treated like any other attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The following example shows how to use the CommonsMultipartResolver:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Of course you also need to put the appropriate jars in your classpath for the multipart resolver to work. In the case of the CommonsMultipartResolver, you need to use commons-fileupload.jar.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When the Spring DispatcherServlet detects a multi-part request, it activates the resolver that has been declared in your context and hands over the request. The resolver then wraps the current HttpServletRequest into a MultipartHttpServletRequest that supports multipart file uploads. Using the MultipartHttpServletRequest, you can get information about the multiparts contained by this request and actually get access to the multipart files themselves in your controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"(The implicitly registered post-processors include AutowiredAnnotationBeanPostProcessor, CommonAnnotationBeanPostProcessor, PersistenceAnnotationBeanPostProcessor, as well as the aforementioned RequiredAnnotationBeanPostProcessor.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"<context:annotation-config/> only looks for annotations on beans in the same application context in which it is defined. This means that, if you put <context:annotation-config/> in a WebApplicationContext for a DispatcherServlet, it only checks for @Autowired beans in your controllers, and not your services. See Section 17.2, “The DispatcherServlet” for more information.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Required annotation applies to bean property setter methods, as in the following example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated; this allows for eager and explicit failure, avoiding NullPointerExceptions or the like later on. It is still recommended that you put assertions into the bean class itself, for example, into an init method. Doing so enforces those required references and values even when you use the class outside of a container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As expected, you can apply the @Autowired annotation to ""traditional"" setter methods:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also apply the annotation to methods with arbitrary names and/or multiple arguments:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can apply @Autowired to constructors and fields:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
It is also possible to provide all beans of a particular type from the ApplicationContext by adding the annotation to a field or method that expects an array of that type:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The same applies for typed collections:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Even typed Maps can be autowired as long as the expected key type is String. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"By default, the autowiring fails whenever zero candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating required dependencies. This behavior can be changed as demonstrated below.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Only one annotated constructor per-class can be marked as required, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the greediest constructor whose dependencies can be satisfied, that is the constructor that has the largest number of arguments.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Autowired's required attribute is recommended over the @Required annotation. The required attribute indicates that the property is not required for autowiring purposes, the property is ignored if it cannot be autowired. @Required, on the other hand, is stronger in that it enforces the property that was set by any means supported by the container. If no value is injected, a corresponding exception is raised.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Autowired, @Inject, @Resource, and @Value annotations are handled by a Spring BeanPostProcessor implementations which in turn means that you cannot apply these annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types (if any). These types must be 'wired up' explicitly via XML or using a Spring @Bean method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring's @Qualifier annotation. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The @Qualifier annotation can also be specified on individual constructor arguments or method parameters:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The corresponding bean definitions appear as follows. The bean with qualifier value ""main"" is wired with the constructor argument that is qualified with the same value.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For a fallback match, the bean name is considered a default qualifier value. Thus you can define the bean with an id ""main"" instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, @Autowired is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches; they do not semantically express a reference to a unique bean id. Good qualifier values are ""main"" or ""EMEA"" or ""persistent"", expressing characteristics of a specific component that are independent from the bean id, which may be auto-generated in case of an anonymous bean definition like the one in the preceding example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Qualifiers also apply to typed collections, as discussed above, for example, to Set<MovieCatalog>. In this case, all matching beans according to the declared qualifiers are injected as a collection. This implies that qualifiers do not have to be unique; they rather simply constitute filtering criteria. For example, you can define multiple MovieCatalog beans with the same qualifier value ""action""; all of which would be injected into a Set<MovieCatalog> annotated with @Qualifier(""action"").",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you intend to express annotation-driven injection by name, do not primarily use @Autowired, even if is technically capable of referring to a bean name through @Qualifier values. Instead, use the JSR-250 @Resource annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As a specific consequence of this semantic difference, beans that are themselves defined as a collection or map type cannot be injected through @Autowired, because type matching is not properly applicable to them. Use @Resource for such beans, referring to the specific collection or map bean by unique name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. By contrast, @Resource is supported only for fields and bean property setter methods with a single argument. As a consequence, stick with qualifiers if your injection target is a constructor or a multi-argument method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In order to use Servlet 3.0 based multipart parsing, you need to mark the DispatcherServlet with a ""multipart-config"" section in web.xml, or with a javax.servlet.MultipartConfigElement in programmatic Servlet registration, or in case of a custom Servlet class possibly with a javax.servlet.annotation.MultipartConfig annotation on your Servlet class. Configuration settings such as maximum sizes or storage locations need to be applied at that Servlet registration level as Servlet 3.0 does not allow for those settings to be done from the MultipartResolver.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Once Servlet 3.0 multipart parsing has been enabled in one of the above mentioned ways you can add the StandardServletMultipartResolver to your Spring configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"After the MultipartResolver completes its job, the request is processed like any other. First, create a form with a file input that will allow the user to upload a form. The encoding attribute (enctype=""multipart/form-data"") lets the browser know how to encode the form as multipart request:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The next step is to create a controller that handles the file upload. This controller is very similar to a normal annotated @Controller, except that we use MultipartHttpServletRequest or MultipartFile in the method parameters:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note how the @RequestParam method parameters map to the input elements declared in the form. In this example, nothing is done with the byte[], but in practice you can save it in a database, store it on the file system, and so on.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
When using Servlet 3.0 multipart parsing you can also use javax.servlet.http.Part for the method parameter:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Multipart requests can also be submitted from non-browser clients in a RESTful service scenario. All of the above examples and configuration apply here as well. However, unlike browsers that typically submit files and simple form fields, a programmatic client can also send more complex data of a specific content type — for example a multipart request with a file and second part with JSON formatted data:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You could access the part named ""meta-data"" with a @RequestParam(""meta-data"") String metadata controller method argument. However, you would probably prefer to accept a strongly typed object initialized from the JSON formatted data in the body of the request part, very similar to the way @RequestBody converts the body of a non-multipart request to a target object with the help of an HttpMessageConverter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can use the @RequestPart annotation instead of the @RequestParam annotation for this purpose. It allows you to have the content of a specific multipart passed through an HttpMessageConverter taking into consideration the 'Content-Type' header of the multipart:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Notice how MultipartFile method arguments can be accessed with @RequestParam or with @RequestPart interchangeably. However, the @RequestPart(""meta-data"") MetaData method argument in this case is read as JSON content based on its 'Content-Type' header and converted with the help of the MappingJackson2HttpMessageConverter.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring HandlerExceptionResolver implementations deal with unexpected exceptions that occur during controller execution. A HandlerExceptionResolver somewhat resembles the exception mappings you can define in the web application descriptor web.xml. However, they provide a more flexible way to do so. For example they provide information about which handler was executing when the exception was thrown. Furthermore, a programmatic way of handling exceptions gives you more options for responding appropriately before the request is forwarded to another URL (the same end result as when you use the Servlet specific exception mappings).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Besides implementing the HandlerExceptionResolver interface, which is only a matter of implementing the resolveException(Exception, Handler) method and returning a ModelAndView, you may also use the provided SimpleMappingExceptionResolver or create @ExceptionHandler methods. The SimpleMappingExceptionResolver enables you to take the class name of any exception that might be thrown and map it to a view name. This is functionally equivalent to the exception mapping feature from the Servlet API, but it is also possible to implement more finely grained mappings of exceptions from different handlers. The @ExceptionHandler annotation on the other hand can be used on methods that should be invoked to handle an exception. Such methods may be defined locally within an @Controller or may apply globally to all @RequestMapping methods when defined within an @ControllerAdvice class. The following sections explain this in more detail.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The HandlerExceptionResolver interface and the SimpleMappingExceptionResolver implementations allow you to map Exceptions to specific views declaratively along with some optional Java logic before forwarding to those views. However, in some cases, especially when relying on @ResponseBody methods rather than on view resolution, it may be more convenient to directly set the status of the response and optionally write error content to the body of the response.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can do that with @ExceptionHandler methods. When declared within a controller such methods apply to exceptions raised by @RequestMapping methods of that contoroller (or any of its sub-classes). You can also declare an @ExceptionHandler method within an @ControllerAdvice class in which case it handles exceptions from @RequestMapping methods from any controller. The @ControllerAdvice annotation is a component annotation, which can be used with classpath scanning. It is automatically enabled when using the MVC namespace and the MVC Java config, or otherwise depending on whether the ExceptionHandlerExceptionResolver is configured or not. Below is an example of a controller-local @ExceptionHandler method:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The @ExceptionHandler value can be set to an array of Exception types. If an exception is thrown that matches one of the types in the list, then the method annotated with the matching @ExceptionHandler will be invoked. If the annotation value is not set then the exception types listed as method arguments are used.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Much like standard controller methods annotated with a @RequestMapping annotation, the method arguments and return values of @ExceptionHandler methods can be flexible. For example, the HttpServletRequest can be accessed in Servlet environments and the PortletRequest in Portlet environments. The return type can be a String, which is interpreted as a view name, a ModelAndView object, a ResponseEntity, or you can also add the @ResponseBody to have the method return value converted with message converters and written to the response stream.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring MVC may raise a number of exceptions while processing a request. The SimpleMappingExceptionResolver can easily map any exception to a default error view as needed. However, when working with clients that interpret responses in an automated way you will want to set specific status code on the response. Depending on the exception raised the status code may indicate a client error (4xx) or a server error (5xx).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The DefaultHandlerExceptionResolver translates Spring MVC exceptions to specific error status codes. It is registered by default with the MVC namespace, the MVC Java config, and also by the the DispatcherServlet (i.e. when not using the MVC namespace or Java config). Listed below are some of the exceptions handled by this resolver and the corresponding status codes:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The DefaultHandlerExceptionResolver works transparently by setting the status of the response. However, it stops short of writing any error content to the body of the response while your application may need to add developer-friendly content to every error response for example when providing a REST API. You can prepare a ModelAndView and render error content through view resolution -- i.e. by configuring a ContentNegotiatingViewResolver, MappingJacksonJsonView, and so on. However, you may prefer to use @ExceptionHandler methods instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
If you prefer to write error content via @ExceptionHandler methods you can extend ResponseEntityExceptionHandler instead. This is a convenient base for @ControllerAdvice classes providing an @ExceptionHandler method to handle standard Spring MVC exceptions and return ResponseEntity. That allows you to customize the response and write error content with message converters. See the Javadoc of ResponseEntityExceptionHandler for more details.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"A business exception can be annotated with @ResponseStatus. When the exception is raised, the ResponseStatusExceptionResolver handles it by setting the status of the response accordingly. By default the DispatcherServlet registers the ResponseStatusExceptionResolver and it is available for use.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When the status of the response is set to an error status code and the body of the response is empty, Servlet containers commonly render an HTML formatted error page. To customize the default error page of the container, you can declare an <error-page> element in web.xml. Up until Servlet 3, that element had to be mapped to a specific status code or exception type. Starting with Servlet 3 an error page does not need to be mapped, which effectively means the specified location customizes the default Servlet container error page.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Note that the actual location for the error page can be a JSP page or some other URL within the container including one handled through an @Controller method:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When writing error information, the status code and the error message set on the HttpServletResponse can be accessed through request attributes in a controller:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
or in a JSP:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"For a lot of projects, sticking to established conventions and having reasonable defaults is just what they (the projects) need, and Spring Web MVC now has explicit support for convention over configuration. What this means is that if you establish a set of naming conventions and suchlike, you can substantially cut down on the amount of configuration that is required to set up handler mappings, view resolvers, ModelAndView instances, etc. This is a great boon with regards to rapid prototyping, and can also lend a degree of (always good-to-have) consistency across a codebase should you choose to move forward with it into production.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Convention-over-configuration support addresses the three core areas of MVC: models, views, and controllers.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can create your own custom qualifier annotations. Simply define an annotation and provide the @Qualifier annotation within your definition:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Then you can provide the custom qualifier on autowired fields and parameters:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Next, provide the information for the candidate bean definitions. You can add <qualifier/> tags as sub-elements of the <bean/> tag and then specify the type and value to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Or, as a convenience if no risk of conflicting names exists, you can use the short class name. Both approaches are demonstrated in the following example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Section 5.10, “Classpath scanning and managed components”, you will see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see Section 5.10.7, “Providing qualifier metadata with annotations”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that would be searched when no Internet connection is available. First define the simple annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Then add the annotation to the field or property to be autowired:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Now the bean definition only needs a qualifier type:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
In this case Format is an enum:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The fields to be autowired are annotated with the custom qualifier and include values for both attributes: genre and format.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that bean meta attributes may be used instead of the <qualifier/> sub-elements. If available, the <qualifier/> and its attributes take precedence, but the autowiring mechanism falls back on the values provided within the <meta/> tags if no such qualifier is present, as in the last two bean definitions in the following example.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The CustomAutowireConfigurer is a BeanFactoryPostProcessor that enables you to register your own custom qualifier annotation types even if they are not annotated with Spring's @Qualifier annotation.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The particular implementation of AutowireCandidateResolver that is activated for the application context depends on the Java version. In versions earlier than Java 5, the qualifier annotations are not supported, and therefore autowire candidates are solely determined by the autowire-candidate value of each bean definition as well as by any default-autowire-candidates pattern(s) available on the <beans/> element. In Java 5 or later, the presence of @Qualifier annotations and any custom annotations registered with the CustomAutowireConfigurer will also play a role.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Regardless of the Java version, when multiple beans qualify as autowire candidates, the determination of a ""primary"" candidate is the same: if exactly one bean definition among the candidates has a primary attribute set to true, it will be selected.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring also supports injection using the JSR-250 @Resource annotation on fields or bean property setter methods. This is a common pattern in Java EE 5 and 6, for example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports this pattern for Spring-managed objects as well.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Resource takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in this example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name ""movieFinder"" injected into its setter method:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The name provided with the annotation is resolved as a bean name by the ApplicationContext of which the CommonAnnotationBeanPostProcessor is aware. The names can be resolved through JNDI if you configure Spring's SimpleJndiBeanFactory explicitly. However, it is recommended that you rely on the default behavior and simply use Spring's JNDI lookup capabilities to preserve the level of indirection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the exclusive case of @Resource usage with no explicit name specified, and similar to @Autowired, @Resource finds a primary type match instead of a specific named bean and resolves well-known resolvable dependencies: the BeanFactory, ApplicationContext, ResourceLoader, ApplicationEventPublisher, and MessageSource interfaces.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Thus in the following example, the customerPreferenceDao field first looks for a bean named customerPreferenceDao, then falls back to a primary type match for the type CustomerPreferenceDao. The ""context"" field is injected based on the known resolvable dependency type ApplicationContext.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The CommonAnnotationBeanPostProcessor not only recognizes the @Resource annotation but also the JSR-250 lifecycle annotations. Introduced in Spring 2.5, the support for these annotations offers yet another alternative to those described in initialization callbacks and destruction callbacks. Provided that the CommonAnnotationBeanPostProcessor is registered within the Spring ApplicationContext, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the example below, the cache will be pre-populated upon initialization and cleared upon destruction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For details about the effects of combining various lifecycle mechanisms, see the section called “Combining lifecycle mechanisms”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Most examples in this chapter use XML to specify the configuration metadata that produces each BeanDefinition within the Spring container. The previous section (Section 5.9, “Annotation-based container configuration”) demonstrates how to provide a lot of the configuration metadata through source-level annotations. Even in those examples, however, the ""base"" bean definitions are explicitly defined in the XML file, while the annotations only drive the dependency injection. This section describes an option for implicitly detecting the candidate components by scanning the classpath. Candidate components are classes that match against a filter criteria and have a corresponding bean definition registered with the container. This removes the need to use XML to perform bean registration, instead you can use annotations (for example @Component), AspectJ type expressions, or your own custom filter criteria to select which classes will have bean definitions registered with the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the @Configuration, @Bean, @Import, and @DependsOn annotations for examples of how to use these new features.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Spring 2.0 and later, the @Repository annotation is a marker for any class that fulfills the role or stereotype (also known as Data Access Object or DAO) of a repository. Among the uses of this marker is the automatic translation of exceptions as described in Section 15.2.2, “Exception translation”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring 2.5 introduces further stereotype annotations: @Component, @Service, and @Controller. @Component is a generic stereotype for any Spring-managed component. @Repository, @Service, and @Controller are specializations of @Component for more specific use cases, for example, in the persistence, service, and presentation layers, respectively. Therefore, you can annotate your component classes with @Component, but by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. It is also possible that @Repository, @Service, and @Controller may carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice. Similarly, as stated above, @Repository is already supported as a marker for automatic exception translation in your persistence layer.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring can automatically detect stereotyped classes and register corresponding BeanDefinitions with the ApplicationContext. For example, the following two classes are eligible for such autodetection:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To autodetect these classes and register the corresponding beans, you need to include the following element in XML, where the base-package element is a common parent package for the two classes. (Alternatively, you can specify a comma-separated list that includes the parent package of each class.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The ControllerClassNameHandlerMapping class is a HandlerMapping implementation that uses a convention to determine the mapping between request URLs and the Controller instances that are to handle those requests.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Consider the following simple Controller implementation. Take special notice of the name of the class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Here is a snippet from the corresponding Spring Web MVC configuration file:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The ControllerClassNameHandlerMapping finds all of the various handler (or Controller) beans defined in its application context and strips Controller off the name to define its handler mappings. Thus, ViewShoppingCartController maps to the /viewshoppingcart* request URL.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Let's look at some more examples so that the central idea becomes immediately familiar. (Notice all lowercase in the URLs, in contrast to camel-cased Controller class names.)",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the case of MultiActionController handler classes, the mappings generated are slightly more complex. The Controller names in the following examples are assumed to be MultiActionController implementations:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you follow the convention of naming your Controller implementations as xxxController, the ControllerClassNameHandlerMapping saves you the tedium of defining and maintaining a potentially looooong SimpleUrlHandlerMapping (or suchlike).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The ControllerClassNameHandlerMapping class extends the AbstractHandlerMapping base class so you can define HandlerInterceptor instances and everything else just as you would with many other HandlerMapping implementations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The ModelMap class is essentially a glorified Map that can make adding objects that are to be displayed in (or on) a View adhere to a common naming convention. Consider the following Controller implementation; notice that objects are added to the ModelAndView without any associated name specified.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The ModelAndView class uses a ModelMap class that is a custom Map implementation that automatically generates a key for an object when an object is added to it. The strategy for determining the name for an added object is, in the case of a scalar object such as User, to use the short class name of the object's class. The following examples are names that are generated for scalar objects put into a ModelMap instance.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An x.y.User instance added will have the name user generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An x.y.Registration instance added will have the name registration generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An x.y.Foo instance added will have the name foo generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A java.util.HashMap instance added will have the name hashMap generated. You probably want to be explicit about the name in this case because hashMap is less than intuitive.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Adding null will result in an IllegalArgumentException being thrown. If the object (or objects) that you are adding could be null, then you will also want to be explicit about the name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"What, no automatic pluralization?",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Spring Web MVC's convention-over-configuration support does not support automatic pluralization. That is, you cannot add a List of Person objects to a ModelAndView and have the generated name be people.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This decision was made after some debate, with the “Principle of Least Surprise” winning out in the end.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The strategy for generating a name after adding a Set or a List is to peek into the collection, take the short class name of the first object in the collection, and use that with List appended to the name. The same applies to arrays although with arrays it is not necessary to peek into the array contents. A few examples will make the semantics of name generation for collections clearer:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An x.y.User[] array with zero or more x.y.User elements added will have the name userList generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An x.y.Foo[] array with zero or more x.y.User elements added will have the name fooList generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A java.util.ArrayList with one or more x.y.User elements added will have the name userList generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
A java.util.HashSet with one or more x.y.Foo elements added will have the name fooList generated.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The use of <context:component-scan> implicitly enables the functionality of <context:annotation-config>. There is usually no need to include the <context:annotation-config> element when using <context:component-scan>.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, make sure that you do not activate the files-only switch of the JAR task.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Furthermore, the AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor are both included implicitly when you use the component-scan element. That means that the two components are autodetected and wired together - all without any bean configuration metadata provided in XML.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can disable the registration of AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor by including the annotation-config attribute with a value of false.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"By default, classes annotated with @Component, @Repository, @Service, @Controller, or a custom annotation that itself is annotated with @Component are the only detected candidate components. However, you can modify and extend this behavior simply by applying custom filters. Add them as include-filter or exclude-filter sub-elements of the component-scan element. Each filter element requires the type and expression attributes. The following table describes the filtering options.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The following example shows the XML configuration ignoring all @Repository annotations and using ""stub"" repositories instead.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can also disable the default filters by providing use-default-filters=""false"" as an attribute of the <component-scan/> element. This will in effect disable automatic detection of classes annotated with @Component, @Repository, @Service, or @Controller.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Spring components can also contribute bean definition metadata to the container. You do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes. Here is a simple example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This class is a Spring component that has application-specific code contained in its doWork() method. However, it also contributes a bean definition that has a factory method referring to the method publicInstance(). The @Bean annotation identifies the factory method and other bean definition properties, such as a qualifier value through the @Qualifier annotation. Other method level annotations that can be specified are @Scope, @Lazy, and custom qualifier annotations. Autowired fields and methods are supported as previously discussed, with additional support for autowiring of @Bean methods:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The example autowires the String method parameter country to the value of the Age property on another bean named privateInstance. A Spring Expression Language element defines the value of the property through the notation #{ <expression> }. For @Value annotations, an expression resolver is preconfigured to look for bean names when resolving expression text.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Bean methods in a Spring component are processed differently than their counterparts inside a Spring @Configuration class. The difference is that @Component classes are not enhanced with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which invoking methods or fields within @Configuration classes @Bean methods create bean metadata references to collaborating objects. Methods are not invoked with normal Java semantics. In contrast, calling a method or field within a @Component classes @Bean method has standard Java semantics.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value will thereby provide that name to the corresponding bean definition.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following two components were detected, the names would be myMovieLister and movieFinderImpl:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully-qualified class name when configuring the scanner:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As a general rule, consider specifying the name with the annotation whenever other components may be making explicit references to it. On the other hand, the auto-generated names are adequate whenever the container is responsible for wiring.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As with Spring-managed components in general, the default and most common scope for autodetected components is singleton. However, sometimes you need other scopes, which Spring 2.5 provides with a new @Scope annotation. Simply provide the name of the scope within the annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, implement the ScopeMetadataResolver interface, and be sure to include a default no-arg constructor. Then, provide the fully-qualified class name when configuring the scanner:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped objects. The reasoning is described in the section called “Scoped beans as dependencies”. For this purpose, a scoped-proxy attribute is available on the component-scan element. The three possible values are: no, interfaces, and targetClass. For example, the following configuration will result in standard JDK dynamic proxies:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Qualifier annotation is discussed in Section 5.9.3, “Fine-tuning annotation-based autowiring with qualifiers”. The examples in that section demonstrate the use of the @Qualifier annotation and custom qualifier annotations to provide fine-grained control when you resolve autowire candidates. Because those examples were based on XML bean definitions, the qualifier metadata was provided on the candidate bean definitions using the qualifier or meta sub-elements of the bean element in the XML. When relying upon classpath scanning for autodetection of components, you provide the qualifier metadata with type-level annotations on the candidate class. The following three examples demonstrate this technique:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As with most annotation-based alternatives, keep in mind that the annotation metadata is bound to the class definition itself, while the use of XML allows for multiple beans of the same type to provide variations in their qualifier metadata, because that metadata is provided per-instance rather than per-class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency Injection). Those annotations are scanned in the same way as the Spring annotations. You just need to have the relevant jars in your classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you are using Maven, the javax.inject artifact is available in the standard Maven repository (http://repo1.maven.org/maven2/javax/inject/javax.inject/1/). You can add the following dependency to your file pom.xml:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Instead of @Autowired, @javax.inject.Inject may be used as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As with @Autowired, it is possible to use @Inject at the class-level, field-level, method-level and constructor-argument level. If you would like to use a qualified name for the dependency that should be injected, you should use the @Named annotation as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Instead of @Component, @javax.inject.Named may be used as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
It is very common to use @Component without specifying a name for the component. @Named can be used in a similar fashion:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When using @Named, it is possible to use component-scanning in the exact same way as when using Spring annotations:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"An empty java.util.ArrayList will not be added at all (in effect, the addObject(..) call will essentially be a no-op).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The RequestToViewNameTranslator interface determines a logical View name when no such logical view name is explicitly supplied. It has just one implementation, the DefaultRequestToViewNameTranslator class.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The DefaultRequestToViewNameTranslator maps request URLs to logical view names, as with this example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Notice how in the implementation of the handleRequest(..) method no View or logical view name is ever set on the ModelAndView that is returned. The DefaultRequestToViewNameTranslator is tasked with generating a logical view name from the URL of the request. In the case of the above RegistrationController, which is used in conjunction with the ControllerClassNameHandlerMapping, a request URL of http://localhost/registration.html results in a logical view name of registration being generated by the DefaultRequestToViewNameTranslator. This logical view name is then resolved into the /WEB-INF/jsp/registration.jsp view by the InternalResourceViewResolver bean.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You do not need to define a DefaultRequestToViewNameTranslator bean explicitly. If you like the default settings of the DefaultRequestToViewNameTranslator, you can rely on the Spring Web MVC DispatcherServlet to instantiate an instance of this class if one is not explicitly configured.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Of course, if you need to change the default settings, then you do need to configure your own DefaultRequestToViewNameTranslator bean explicitly. Consult the comprehensive Javadoc for the DefaultRequestToViewNameTranslator class for details of the various properties that can be configured.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An ETag (entity tag) is an HTTP response header returned by an HTTP/1.1 compliant web server used to determine change in content at a given URL. It can be considered to be the more sophisticated successor to the Last-Modified header. When a server returns a representation with an ETag header, the client can use this header in subsequent GETs, in an If-None-Match header. If the content has not changed, the server returns 304: Not Modified.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Support for ETags is provided by the Servlet filter ShallowEtagHeaderFilter. It is a plain Servlet Filter, and thus can be used in combination with any web framework. The ShallowEtagHeaderFilter filter creates so-called shallow ETags (as opposed to deep ETags, more about that later).The filter caches the content of the rendered JSP (or other content), generates an MD5 hash over that, and returns that as an ETag header in the response. The next time a client sends a request for the same resource, it uses that hash as the If-None-Match value. The filter detects this, renders the view again, and compares the two hashes. If they are equal, a 304 is returned. This filter will not save processing power, as the view is still rendered. The only thing it saves is bandwidth, as the rendered response is not sent back over the wire.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You configure the ShallowEtagHeaderFilter in web.xml:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In a Servlet 3.0+ environment, you have the option of configuring the Servlet container programmatically as an alternative or in combination with a web.xml file. Below is an example of registering a DispatcherServlet:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
WebApplicationInitializer is an interface provided by Spring MVC that ensures your implementation is detected and automatically used to initialize any Servlet 3 container. An abstract base class implementation of WebApplicationInitializer named AbstractDispatcherServletInitializer makes it even easier to register the DispatcherServlet by simply overriding methods to specify the servlet mapping and the location of the DispatcherServlet configuration:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The above example is for an application that uses Java-based Spring configuration. If using XML-based Spring configuration, extend directly from AbstractDispatcherServletInitializer:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
AbstractDispatcherServletInitializer also provides a convenient way to add Filter instances and have them automatically mapped to the DispatcherServlet:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Each filter is added with a default name based on its concrete type and automatically mapped to the DispatcherServlet.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The isAsyncSupported protected method of AbstractDispatcherServletInitializer provides a single place to enable async support on the DispatcherServlet and all filters mapped to it. By default this flag is set to true.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Section 17.2.1, “Special Bean Types In the WebApplicationContext” and Section 17.2.2, “Default DispatcherServlet Configuration” explained about Spring MVC's special beans and the default implementations used by the DispatcherServlet. In this section you'll learn about two additional ways of configuring Spring MVC. Namely the MVC Java config and the MVC XML namespace.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The MVC Java config and the MVC namespace provide similar default configuration that overrides the DispatcherServlet defaults. The goal is to spare most applications from having to having to create the same configuration and also to provide higher-level constructs for configuring Spring MVC that serve as a simple starting point and require little or no prior knowledge of the underlying configuration.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"You can choose either the MVC Java config or the MVC namespace depending on your preference. Also as you will see further below, with the MVC Java config it is easier to see the underlying configuration as well as to make fine-grained customizations directly to the created Spring MVC beans. But let's start from the beginning.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To enable MVC Java config add the annotation @EnableWebMvc to one of your @Configuration classes:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To achieve the same in XML use the mvc:annotation-driven element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The above registers a RequestMappingHandlerMapping, a RequestMappingHandlerAdapter, and an ExceptionHandlerExceptionResolver (among others) in support of processing requests with annotated controller methods using annotations such as @RequestMapping , @ExceptionHandler, and others.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
It also enables the following:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Spring 3 style type conversion through a ConversionService instance in addition to the JavaBeans PropertyEditors used for Data Binding.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Support for formatting Number fields using the @NumberFormat annotation through the ConversionService.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When working with standard annotations, it is important to know that some significant features are not available as shown in the table below:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The JSR-330 default scope is like Spring's prototype. However, in order to keep it consistent with Spring's general defaults, a JSR-330 bean declared in the Spring container is a singleton by default. In order to use a scope other than singleton, you should use Spring's @Scope annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"javax.inject also provides a @Scope annotation. Nevertheless, this one is only intended to be used for creating your own annotations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Full @Configuration vs 'lite' @Beans mode?,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When @Bean methods are declared within classes that are not annotated with @Configuration they are referred to as being processed in a 'lite' mode. For example, bean methods declared in a @Component or even in a plain old class will be considered 'lite'.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Unlike full @Configuration, lite @Bean methods cannot easily declare inter-bean dependencies. Usually one @Bean method should not invoke another @Bean method when operating in 'lite' mode.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Only using @Bean methods within @Configuration classes is a recommended approach of ensuring that 'full' mode is always used. This will prevent the same @Bean method from accidentally being invoked multiple times and helps to reduce subtle bugs that can be hard to track down when operating in 'lite' mode.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The central artifacts in Spring's new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Bean annotation is used to indicate that a method instantiates, configures and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring's <beans/> XML configuration the @Bean annotation plays the same role as the <bean/> element. You can use @Bean annotated methods with any Spring @Component, however, they are most often used with @Configuration beans.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes allow inter-bean dependencies to be defined by simply calling other @Bean methods in the same class. The simplest possible @Configuration class would read as follows:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The AppConfig class above would be equivalent to the following Spring <beans/> XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Bean and @Configuration annotations will be discussed in depth in the sections below. First, however, we'll cover the various ways of creating a spring container using Java-based configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The sections below document Spring's AnnotationConfigApplicationContext, new in Spring 3.0. This versatile ApplicationContext implementation is capable of accepting not only @Configuration classes as input, but also plain @Component classes and classes annotated with JSR-330 metadata.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When @Configuration classes are provided as input, the @Configuration class itself is registered as a bean definition, and all declared @Bean methods within the class are also registered as bean definitions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When @Component and JSR-330 classes are provided, they are registered as bean definitions, and it is assumed that DI metadata such as @Autowired or @Inject are used within those classes where necessary.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In much the same way that Spring XML files are used as input when instantiating a ClassPathXmlApplicationContext, @Configuration classes may be used as input when instantiating an AnnotationConfigApplicationContext. This allows for completely XML-free usage of the Spring container:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As mentioned above, AnnotationConfigApplicationContext is not limited to working only with @Configuration classes. Any @Component or JSR-330 annotated class may be supplied as input to the constructor. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The above assumes that MyServiceImpl, Dependency1 and Dependency2 use Spring dependency injection annotations such as @Autowired.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
An AnnotationConfigApplicationContext may be instantiated using a no-arg constructor and then configured using the register() method. This approach is particularly useful when programmatically building an AnnotationConfigApplicationContext.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the example above, the com.acme package will be scanned, looking for any @Component-annotated classes, and those classes will be registered as Spring bean definitions within the container. AnnotationConfigApplicationContext exposes the scan(String...) method to allow for the same component-scanning functionality:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Remember that @Configuration classes are meta-annotated with @Component, so they are candidates for component-scanning! In the example above, assuming that AppConfig is declared within the com.acme package (or any package underneath), it will be picked up during the call to scan(), and upon refresh() all its @Bean methods will be processed and registered as bean definitions within the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"A WebApplicationContext variant of AnnotationConfigApplicationContext is available with AnnotationConfigWebApplicationContext. This implementation may be used when configuring the Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, etc. What follows is a web.xml snippet that configures a typical Spring MVC web application. Note the use of the contextClass context-param and init-param:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports some of the attributes offered by <bean/>, such as: init-method, destroy-method, autowiring and name.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To declare a bean, simply annotate a method with the @Bean annotation. You use this method to register a bean definition within an ApplicationContext of the type specified as the method's return value. By default, the bean name will be the same as the method name. The following is a simple example of a @Bean method declaration:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The preceding configuration is exactly equivalent to the following Spring XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Support for formatting Date, Calendar, Long, and Joda Time fields using the @DateTimeFormat annotation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Support for validating @Controller inputs with @Valid, if a JSR-303 Provider is present on the classpath.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
HttpMessageConverter support for @RequestBody method parameters and @ResponseBody method return values from @RequestMapping or @ExceptionHandler methods.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This is the complete list of HttpMessageConverters set up by mvc:annotation-driven:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
ByteArrayHttpMessageConverter converts byte arrays.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
StringHttpMessageConverter converts strings.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
ResourceHttpMessageConverter converts to/from org.springframework.core.io.Resource for all media types.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
SourceHttpMessageConverter converts to/from a javax.xml.transform.Source.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"FormHttpMessageConverter converts form data to/from a MultiValueMap<String, String>.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Jaxb2RootElementHttpMessageConverter converts Java objects to/from XML — added if JAXB2 is present on the classpath.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
MappingJackson2HttpMessageConverter (or MappingJacksonHttpMessageConverter) converts to/from JSON — added if Jackson 2 (or Jackson) is present on the classpath.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
AtomFeedHttpMessageConverter converts Atom feeds — added if Rome is present on the classpath.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
RssChannelHttpMessageConverter converts RSS feeds — added if Rome is present on the classpath.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To customize the default configuration in Java you simply implement the WebMvcConfigurer interface or more likely extend the class WebMvcConfigurerAdapter and override the methods you need. Below is an example of some of the available methods to override. See WebMvcConifgurer for a list of all methods and the Javadoc for further details:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To customize the default configuration of <mvc:annotation-driven /> check what attributes and sub-elements it supports. You can view the Spring MVC XML schema or use the code completion feature of your IDE to discover what attributes and sub-elements are available. The sample below shows a subset of what is available:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
You can configure HandlerInterceptors or WebRequestInterceptors to be applied to all incoming requests or restricted to specific URL path patterns.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
An example of registering interceptors in Java:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
And in XML use the <mvc:interceptors> element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Staring with Spring Framework 3.2, you can configure how Spring MVC determines the requested media types from the client for request mapping as well as for content negotiation purposes. The available options are to check the file extension in the request URI, the ""Accept"" header, a request parameter, as well as to fall back on a default content type. By default, file extension in the request URI is checked first and the ""Accept"" header is checked next.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"For file extensions in the request URI, the MVC Java config and the MVC namespace, automatically register extensions such as .json, .xml, .rss, and .atom if the corresponding dependencies such as Jackson, JAXB2, or Rome are present on the classpath. Additional extensions may be not need to be registered explicitly if they can be discovered via ServletContext.getMimeType(String) or the Java Activation Framework (see javax.activation.MimetypesFileTypeMap).",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Below is an example of customizing content negotiation options through the MVC Java config:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the MVC namespace, the <mvc:annotation-driven> element has a content-negotiation-manager attribute, which expects a ContentNegotiationManager that in turn can be created with a ContentNegotiationManagerFactoryBean:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If not using the MVC Java config or the MVC namespace, you'll need to create an instance of ContentNegotiationManager and use it to configure RequestMappingHandlerMapping for request mapping purposes, and RequestMappingHandlerAdapter and ExceptionHandlerExceptionResolver for content negotiation purposes.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Note that ContentNegotiatingViewResolver now can also be configured with a ContentNegotiationManager, so you can use one instance throughout Spring MVC.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In more advanced cases, it may be useful to configure multiple ContentNegotiationManager instances that in turn may contain custom ContentNegotiationStrategy implementations. For example you could configure ExceptionHandlerExceptionResolver with a ContentNegotiationManager that always resolves the requested media type to ""application/json"". Or you may want to plug a custom strategy that has some logic to select a default content type (e.g. either XML or JSON) if no content types were requested.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
This is a shortcut for defining a ParameterizableViewController that immediately forwards to a view when invoked. Use it in static cases when there is no Java controller logic to execute before the view generates the response.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"An example of forwarding a request for ""/"" to a view called ""home"" in Java:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
And the same in XML use the <mvc:view-controller> element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This option allows static resource requests following a particular URL pattern to be served by a ResourceHttpRequestHandler from any of a list of Resource locations. This provides a convenient way to serve static resources from locations other than the web application root, including locations on the classpath. The cache-period property may be used to set far future expiration headers (1 year is the recommendation of optimization tools such as Page Speed and YSlow) so that they will be more efficiently utilized by the client. The handler also properly evaluates the Last-Modified header (if present) so that a 304 status code will be returned as appropriate, avoiding unnecessary overhead for resources that are already cached by the client. For example, to serve resource requests with a URL pattern of /resources/** from a public-resources directory within the web application root you would use:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"Both declarations make a bean named transferService available in the ApplicationContext, bound to an object instance of type TransferServiceImpl:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Any classes defined with the @Bean annotation support the regular lifecycle callbacks and can use the @PostConstruct and @PreDestroy annotations from JSR-250, see JSR-250 annotations for further details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The regular Spring lifecycle callbacks are fully supported as well. If a bean implements InitializingBean, DisposableBean, or Lifecycle, their respective methods are called by the container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The standard set of *Aware interfaces such as BeanFactoryAware, BeanNameAware, MessageSourceAware, ApplicationContextAware, and so on are also fully supported.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML's init-method and destroy-method attributes on the bean element:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Of course, in the case of Foo above, it would be equally as valid to call the init() method directly during construction:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When you work directly in Java, you can do anything you like with your objects and do not always need to rely on the container lifecycle!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can specify that your beans defined with the @Bean annotation should have a specific scope. You can use any of the standard scopes specified in the Bean Scopes section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The default scope is singleton, but you can override this with the @Scope annotation:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring offers a convenient way of working with scoped dependencies through scoped proxies. The easiest way to create such a proxy when using the XML configuration is the <aop:scoped-proxy/> element. Configuring your beans in Java with a @Scope annotation offers equivalent support with the proxyMode attribute. The default is no proxy (ScopedProxyMode.NO), but you can specify ScopedProxyMode.TARGET_CLASS or ScopedProxyMode.INTERFACES.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"If you port the scoped proxy example from the XML reference documentation (see preceding link) to our @Bean using Java, it would look like the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"By default, configuration classes use a @Bean method's name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As discussed in Section 5.3.1, “Naming beans”, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"@Configuration is a class-level annotation indicating that an object is a source of bean definitions. @Configuration classes declare beans via public @Bean annotated methods. Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies. See Section 5.12.1, “Basic concepts: @Bean and @Configuration” for a general introduction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When @Beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the example above, the foo bean receives a reference to bar via constructor injection.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This method of declaring inter-bean dependencies only works when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies using plain @Component classes.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As noted earlier, lookup method injection is an advanced feature that you should use rarely. It is useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this type of configuration provides a natural means for implementing this pattern.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Using Java-configuration support , you can create a subclass of CommandManager where the abstract createCommand() method is overridden in such a way that it looks up a new (prototype) command object:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows a @Bean annotated method being called twice:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"clientDao() has been called once in clientService1() and once in clientService2(). Since this method creates a new instance of ClientDaoImpl and returns it, you would normally expect having 2 instances (one for each service). That definitely would be problematic: in Spring, instantiated beans have a singleton scope by default. This is where the magic comes in: All @Configuration classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance. Note that as of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under org.springframework and included directly within the spring-core JAR.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The behavior could be different according to the scope of your bean. We are talking about singletons here.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Much as the <import/> element is used within Spring XML files to aid in modularizing configurations, the @Import annotation allows for loading @Bean definitions from another configuration class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the context, only ConfigB needs to be supplied explicitly:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"This approach simplifies container instantiation, as only one class needs to be dealt with, rather than requiring the developer to remember a potentially large number of @Configuration classes during construction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The example above works, but is simplistic. In most practical scenarios, beans will have dependencies on one another across configuration classes. When using XML, this is not an issue, per se, because there is no compiler involved, and one can simply declare ref=""someBean"" and trust that Spring will work it out during container initialization. Of course, when using @Configuration classes, the Java compiler places constraints on the configuration model, in that references to other beans must be valid Java syntax.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Fortunately, solving this problem is simple. Remember that @Configuration classes are ultimately just another bean in the container - this means that they can take advantage of @Autowired injection metadata just like any other bean!",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Let's consider a more real-world scenario with several @Configuration classes, each depending on beans declared in the others:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
And the same in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To serve these resources with a 1-year future expiration to ensure maximum use of the browser cache and a reduction in HTTP requests made by the browser:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
And in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The mapping attribute must be an Ant pattern that can be used by SimpleUrlHandlerMapping, and the location attribute must specify one or more valid resource directory locations. Multiple resource locations may be specified using a comma-separated list of values. The locations specified will be checked in the specified order for the presence of the resource for any given request. For example, to enable the serving of resources from both the web application root and from a known path of /META-INF/public-web-resources/ in any jar on the classpath use:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
And in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"When serving resources that may change when a new version of the application is deployed, it is recommended that you incorporate a version string into the mapping pattern used to request the resources, so that you may force clients to request the newly deployed version of your application's resources. Such a version string can be parameterized and accessed using SpEL so that it may be easily managed in a single place when deploying new versions.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As an example, let's consider an application that uses a performance-optimized custom build (as recommended) of the Dojo JavaScript library in production, and that the build is generally deployed within the web application at a path of /public-resources/dojo/dojo.js. Since different parts of Dojo may be incorporated into the custom build for each new version of the application, the client web browsers need to be forced to re-download that custom-built dojo.js resource any time a new version of the application is deployed. A simple way to achieve this would be to manage the version of the application in a properties file, such as:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
and then to make the properties file's values accessible to SpEL as a bean using the util:properties tag:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"With the application version now accessible via SpEL, we can incorporate this into the use of the resources tag:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In Java, you can use the @PropertySouce annotation and then inject the Environment abstraction for access to all defined properties:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"and finally, to request the resource with the proper URL, we can take advantage of the Spring JSP tags:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This tag allows for mapping the DispatcherServlet to ""/"" (thus overriding the mapping of the container's default Servlet), while still allowing static resource requests to be handled by the container's default Servlet. It configures a DefaultServletHttpRequestHandler with a URL mapping of ""/**"" and the lowest priority relative to other URL mappings.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"This handler will forward all requests to the default Servlet. Therefore it is important that it remains last in the order of all other URL HandlerMappings. That will be the case if you use <mvc:annotation-driven> or alternatively if you are setting up your own customized HandlerMapping instance be sure to set its order property to a value lower than that of the DefaultServletHttpRequestHandler, which is Integer.MAX_VALUE.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
To enable the feature using the default setup use:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Or in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"The caveat to overriding the ""/"" Servlet mapping is that the RequestDispatcher for the default Servlet must be retrieved by name rather than by path. The DefaultServletHttpRequestHandler will attempt to auto-detect the default Servlet for the container at startup time, using a list of known names for most of the major Servlet containers (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere). If the default Servlet has been custom configured with a different name, or if a different Servlet container is being used where the default Servlet name is unknown, then the default Servlet's name must be explicitly provided as in the following example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Or in XML:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
See the following links and pointers for more resources about Spring Web MVC:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
There are many excellent articles and tutorials that show how to build web applications with Spring MVC. Read them at the Spring Documentation page.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
“Expert Spring Web MVC and Web Flow” by Seth Ladd and others (published by Apress) is an excellent hard copy source of Spring Web MVC goodness.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"As you can see from the above examples, MVC Java config and the MVC namespace provide higher level constructs that do not require deep knowledge of the underlying beans created for you. Instead it helps you to focus on your application needs. However, at some point you may need more fine-grained control or you may simply wish to understand the underlying configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The first step towards more fine-grained control is to see the underlying beans created for you. In MVC Java config you can see the Javadoc and the @Bean methods in WebMvcConfigurationSupport. The configuration in this class is automatically imported through the @EnableWebMvc annotation. In fact if you open @EnableWebMvc you can see the @Import statement.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
The next step towards more fine-grained control is to customize a property on one of the beans created in WebMvcConfigurationSupport or perhaps to provide your own instance. This requires two things -- remove the @EnableWebMvc annotation in order to prevent the import and then extend directly from WebMvcConfigurationSupport. Here is an example:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Note that modifying beans in this way does not prevent you from using any of the higher-level constructs shown earlier in this section.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Fine-grained control over the configuration created for you is a bit harder with the MVC namespace.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"If you do need to do that, rather than replicating the configuration it provides, consider configuring a BeanPostProcessor that detects the bean you want to customize by type and then modifying its properties as necessary. For example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
Note that MyPostProcessor needs to be included in an <component scan /> in order for it to be detected or if you prefer you can declare it explicitly with an XML bean declaration.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html
"In the scenario above, using @Autowired works well and provides the desired modularity, but determining exactly where the autowired bean definitions are declared is still somewhat ambiguous. For example, as a developer looking at ServiceConfig, how do you know exactly where the @Autowired AccountRepository bean is declared? It's not explicit in the code, and this may be just fine. Remember that the SpringSource Tool Suite provides tooling that can render graphs showing how everything is wired up - that may be all you need. Also, your Java IDE can easily find all declarations and uses of the AccountRepository type, and will quickly show you the location of @Bean methods that return that type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one @Configuration class to another, consider autowiring the configuration classes themselves:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the situation above, it is completely explicit where AccountRepository is defined. However, ServiceConfig is now tightly coupled to RepositoryConfig; that's the tradeoff. This tight coupling can be somewhat mitigated by using interface-based or abstract class-based @Configuration classes. Consider the following:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Now ServiceConfig is loosely coupled with respect to the concrete DefaultRepositoryConfig, and built-in IDE tooling is still useful: it will be easy for the developer to get a type hierarchy of RepositoryConfig implementations. In this way, navigating @Configuration classes and their dependencies becomes no different than the usual process of navigating interface-based code.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring's @Configuration class support does not aim to be a 100% complete replacement for Spring XML. Some facilities such as Spring XML namespaces remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an ""XML-centric"" way using, for example, ClassPathXmlApplicationContext, or in a ""Java-centric"" fashion using AnnotationConfigApplicationContext and the @ImportResource annotation to import XML as needed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It may be preferable to bootstrap the Spring container from XML and include @Configuration classes in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it will be easier to create @Configuration classes on an as-needed basis and include them from the existing XML files. Below you'll find the options for using @Configuration classes in this kind of ""XML-centric"" situation.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Remember that @Configuration classes are ultimately just bean definitions in the container. In this example, we create a @Configuration class named AppConfig and include it within system-test-config.xml as a <bean/>definition. Because <context:annotation-config/> is switched on, the container will recognize the @Configuration annotation, and process the @Bean methods declared in AppConfig properly.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In system-test-config.xml above, the AppConfig<bean/> does not declare an id element. While it would be acceptable to do so, it is unnecessary given that no other bean will ever refer to it, and it is unlikely that it will be explicitly fetched from the container by name. Likewise with the DataSource bean - it is only ever autowired by type, so an explicit bean id is not strictly required.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Because @Configuration is meta-annotated with @Component, @Configuration-annotated classes are automatically candidates for component scanning. Using the same scenario as above, we can redefine system-test-config.xml to take advantage of component-scanning. Note that in this case, we don't need to explicitly declare <context:annotation-config/>, because <context:component-scan/> enables all the same functionality.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In applications where @Configuration classes are the primary mechanism for configuring the container, it will still likely be necessary to use at least some XML. In these scenarios, simply use @ImportResource and define only as much XML as is needed. Doing so achieves a ""Java-centric"" approach to configuring the container and keeps XML to a bare minimum.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The LoadTimeWeaver is used by Spring to dynamically transform classes as they are loaded into the Java virtual machine (JVM).,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
To enable load-time weaving add the @EnableLoadTimeWeaving to one of your @Configuration classes:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Alternatively for XML configuration use the context:load-time-weaver element:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Once configured for the ApplicationContext. Any bean within that ApplicationContext may implement LoadTimeWeaverAware, thereby receiving a reference to the load-time weaver instance. This is particularly useful in combination with Spring's JPA support where load-time weaving may be necessary for JPA class transformation. Consult the LocalContainerEntityManagerFactoryBean Javadoc for more detail. For more on AspectJ load-time weaving, see Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework”.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As was discussed in the chapter introduction, the org.springframework.beans.factory package provides basic functionality for managing and manipulating beans, including in a programmatic way. The org.springframework.context package adds the ApplicationContext interface, which extends the BeanFactory interface, in addition to extending other interfaces to provide additional functionality in a more application framework-oriented style. Many people use the ApplicationContext in a completely declarative fashion, not even creating it programmatically, but instead relying on support classes such as ContextLoader to automatically instantiate an ApplicationContext as part of the normal startup process of a J2EE web application.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
To enhance BeanFactory functionality in a more framework-oriented style the context package also provides the following functionality:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Access to messages in i18n-style, through the MessageSource interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Access to resources, such as URLs and files, through the ResourceLoader interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Event publication to beans implementing the ApplicationListener interface, through the use of the ApplicationEventPublisher interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Loading of multiple (hierarchical) contexts, allowing each to be focused on one particular layer, such as the web layer of an application, through the HierarchicalBeanFactory interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The ApplicationContext interface extends an interface called MessageSource, and therefore provides internationalization (i18n) functionality. Spring also provides the interface HierarchicalMessageSource, which can resolve messages hierarchically. Together these interfaces provide the foundation upon which Spring effects message resolution. The methods defined on these interfaces include:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"String getMessage(String code, Object[] args, String default, Locale loc): The basic method used to retrieve a message from the MessageSource. When no message is found for the specified locale, the default message is used. Any arguments passed in become replacement values, using the MessageFormat functionality provided by the standard library.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"String getMessage(String code, Object[] args, Locale loc): Essentially the same as the previous method, but with one difference: no default message can be specified; if the message cannot be found, a NoSuchMessageException is thrown.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"String getMessage(MessageSourceResolvable resolvable, Locale locale): All properties used in the preceding methods are also wrapped in a class named MessageSourceResolvable, which you can use with this method.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"When an ApplicationContext is loaded, it automatically searches for a MessageSource bean defined in the context. The bean must have the name messageSource. If such a bean is found, all calls to the preceding methods are delegated to the message source. If no message source is found, the ApplicationContext attempts to find a parent containing a bean with the same name. If it does, it uses that bean as the MessageSource. If the ApplicationContext cannot find any source for messages, an empty DelegatingMessageSource is instantiated in order to be able to accept calls to the methods defined above.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring provides two MessageSource implementations, ResourceBundleMessageSource and StaticMessageSource. Both implement HierarchicalMessageSource in order to do nested messaging. The StaticMessageSource is rarely used but provides programmatic ways to add messages to the source. The ResourceBundleMessageSource is shown in the following example:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In the example it is assumed you have three resource bundles defined in your classpath called format, exceptions and windows. Any request to resolve a message will be handled in the JDK standard way of resolving messages through ResourceBundles. For the purposes of the example, assume the contents of two of the above resource bundle files are...",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
A program to execute the MessageSource functionality is shown in the next example. Remember that all ApplicationContext implementations are also MessageSource implementations and so can be cast to the MessageSource interface.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The resulting output from the above program will be...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"So to summarize, the MessageSource is defined in a file called beans.xml, which exists at the root of your classpath. The messageSource bean definition refers to a number of resource bundles through its basenames property. The three files that are passed in the list to the basenames property exist as files at the root of your classpath and are called format.properties, exceptions.properties, and windows.properties respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The next example shows arguments passed to the message lookup; these arguments will be converted into Strings and inserted into placeholders in the lookup message.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The resulting output from the invocation of the execute() method will be...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"With regard to internationalization (i18n), Spring's various MessageSource implementations follow the same locale resolution and fallback rules as the standard JDK ResourceBundle. In short, and continuing with the example messageSource defined previously, if you want to resolve messages against the British (en-GB) locale, you would create files called format_en_GB.properties, exceptions_en_GB.properties, and windows_en_GB.properties respectively.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Typically, locale resolution is managed by the surrounding environment of the application. In this example, the locale against which (British) messages will be resolved is specified manually.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The resulting output from the running of the above program will be...,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also use the MessageSourceAware interface to acquire a reference to any MessageSource that has been defined. Any bean that is defined in an ApplicationContext that implements the MessageSourceAware interface is injected with the application context's MessageSource when the bean is created and configured.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"As an alternative to ResourceBundleMessageSource, Spring provides a ReloadableResourceBundleMessageSource class. This variant supports the same bundle file format but is more flexible than the standard JDK based ResourceBundleMessageSource implementation. In particular, it allows for reading files from any Spring resource location (not just from the classpath) and supports hot reloading of bundle property files (while efficiently caching them in between). Check out the ReloadableResourceBundleMessageSource javadoc for details.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface. If a bean that implements the ApplicationListener interface is deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext, that bean is notified. Essentially, this is the standard Observer design pattern. Spring provides the following standard events:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can also create and publish your own custom events. This example demonstrates a simple class that extends Spring's ApplicationEvent base class:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To publish a custom ApplicationEvent, call the publishEvent() method on an ApplicationEventPublisher. Typically this is done by creating a class that implements ApplicationEventPublisherAware and registering it as a Spring bean. The following example demonstrates such a class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"At configuration time, the Spring container will detect that EmailService implements ApplicationEventPublisherAware and will automatically call setApplicationEventPublisher(). In reality, the parameter passed in will be the Spring container itself; you're simply interacting with the application context via its ApplicationEventPublisher interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To receive the custom ApplicationEvent, create a class that implements ApplicationListener and register it as a Spring bean. The following example demonstrates such a class:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Notice that ApplicationListener is generically parameterized with the type of your custom event, BlackListEvent. This means that the onApplicationEvent() method can remain type-safe, avoiding any need for downcasting. You may register as many event listeners as you wish, but note that by default event listeners receive events synchronously. This means the publishEvent() method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, refer to the JavaDoc for Spring's ApplicationEventMulticaster interface.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following example shows the bean definitions used to register and configure each of the classes above:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Putting it all together, when the sendEmail() method of the emailService bean is called, if there are any emails that should be blacklisted, a custom event of type BlackListEvent is published. The blackListNotifier bean is registered as an ApplicationListener and thus receives the BlackListEvent, at which point it can notify appropriate parties.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Spring's eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately-maintained Spring Integration project provides complete support for building lightweight, pattern-oriented, event-driven architectures that build upon the well-known Spring programming model.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For optimal usage and understanding of application contexts, users should generally familiarize themselves with Spring's Resource abstraction, as described in the chapter Chapter 6, Resources.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"An application context is a ResourceLoader, which can be used to load Resources. A Resource is essentially a more feature rich version of the JDK class java.net.URL, in fact, the implementations of the Resource wrap an instance of java.net.URL where appropriate. A Resource can obtain low-level resources from almost any location in a transparent fashion, including from the classpath, a filesystem location, anywhere describable with a standard URL, and some other variations. If the resource location string is a simple path without any special prefixes, where those resources come from is specific and appropriate to the actual application context type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can configure a bean deployed into the application context to implement the special callback interface, ResourceLoaderAware, to be automatically called back at initialization time with the application context itself passed in as the ResourceLoader. You can also expose properties of type Resource, to be used to access static resources; they will be injected into it like any other properties. You can specify those Resource properties as simple String paths, and rely on a special JavaBean PropertyEditor that is automatically registered by the context, to convert those text strings to actual Resource objects when the bean is deployed.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The location path or paths supplied to an ApplicationContext constructor are actually resource strings, and in simple form are treated appropriately to the specific context implementation. ClassPathXmlApplicationContext treats a simple location path as a classpath location. You can also use location paths (resource strings) with special prefixes to force loading of definitions from the classpath or a URL, regardless of the actual context type.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"You can create ApplicationContext instances declaratively by using, for example, a ContextLoader. Of course you can also create ApplicationContext instances programmatically by using one of the ApplicationContext implementations.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
You can register an ApplicationContext using the ContextLoaderListener as follows:,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The listener inspects the contextConfigLocation parameter. If the parameter does not exist, the listener uses /WEB-INF/applicationContext.xml as a default. When the parameter does exist, the listener separates the String by using predefined delimiters (comma, semicolon and whitespace) and uses the values as locations where application contexts will be searched. Ant-style path patterns are supported as well. Examples are /WEB-INF/*Context.xml for all files with names ending with ""Context.xml"", residing in the ""WEB-INF"" directory, and /WEB-INF/**/*Context.xml, for all such files in any subdirectory of ""WEB-INF"".",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In Spring 2.5 and later, it is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the context and all of its required bean classes and library JARs in a J2EE RAR deployment unit. This is the equivalent of bootstrapping a standalone ApplicationContext, just hosted in J2EE environment, being able to access the J2EE servers facilities. RAR deployment is a more natural alternative to scenario of deploying a headless WAR file, in effect, a WAR file without any HTTP entry points that is used only for bootstrapping a Spring ApplicationContext in a J2EE environment.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"RAR deployment is ideal for application contexts that do not need HTTP entry points but rather consist only of message endpoints and scheduled jobs. Beans in such a context can use application server resources such as the JTA transaction manager and JNDI-bound JDBC DataSources and JMS ConnectionFactory instances, and may also register with the platform's JMX server - all through Spring's standard transaction management and JNDI and JMX support facilities. Application components can also interact with the application server's JCA WorkManager through Spring's TaskExecutor abstraction.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Check out the JavaDoc of the SpringContextResourceAdapter class for the configuration details involved in RAR deployment.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"For a simple deployment of a Spring ApplicationContext as a J2EE RAR file: package all application classes into a RAR file, which is a standard JAR file with a different file extension. Add all required library JARs into the root of the RAR archive. Add a ""META-INF/ra.xml"" deployment descriptor (as shown in SpringContextResourceAdapters JavaDoc) and the corresponding Spring XML bean definition file(s) (typically ""META-INF/applicationContext.xml""), and drop the resulting RAR file into your application server's deployment directory.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Such RAR deployment units are usually self-contained; they do not expose components to the outside world, not even to other modules of the same application. Interaction with a RAR-based ApplicationContext usually occurs through JMS destinations that it shares with other modules. A RAR-based ApplicationContext may also, for example, schedule some jobs, reacting to new files in the file system (or the like). If it needs to allow synchronous access from the outside, it could for example export RMI endpoints, which of course may be used by other application modules on the same machine.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"The BeanFactory provides the underlying basis for Spring's IoC functionality but it is only used directly in integration with other third-party frameworks and is now largely historical in nature for most users of Spring. The BeanFactory and related interfaces, such as BeanFactoryAware, InitializingBean, DisposableBean, are still present in Spring for the purposes of backward compatibility with the large number of third-party frameworks that integrate with Spring. Often third-party components that can not use more modern equivalents such as @PostConstruct or @PreDestroy in order to remain compatible with JDK 1.4 or to avoid a dependency on JSR-250.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
This section provides additional background into the differences between the BeanFactory and ApplicationContext and how one might access the IoC container directly through a classic singleton lookup.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Use an ApplicationContext unless you have a good reason for not doing so.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Because the ApplicationContext includes all functionality of the BeanFactory, it is generally recommended over the BeanFactory, except for a few situations such as in an Applet where memory consumption might be critical and a few extra kilobytes might make a difference. However, for most typical enterprise applications and systems, the ApplicationContext is what you will want to use. Spring 2.0 and later makes heavy use of the BeanPostProcessor extension point (to effect proxying and so on). If you use only a plain BeanFactory, a fair amount of support such as transactions and AOP will not take effect, at least not without some extra steps on your part. This situation could be confusing because nothing is actually wrong with the configuration.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
The following table lists features provided by the BeanFactory and ApplicationContext interfaces and implementations.,https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
Convenient MessageSource access (for i18n),https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To explicitly register a bean post-processor with a BeanFactory implementation, you must write code like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"To explicitly register a BeanFactoryPostProcessor when using a BeanFactory implementation, you must write code like this:",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"In both cases, the explicit registration step is inconvenient, which is one reason why the various ApplicationContext implementations are preferred above plain BeanFactory implementations in the vast majority of Spring-backed applications, especially when using BeanFactoryPostProcessors and BeanPostProcessors. These mechanisms implement important functionality such as property placeholder replacement and AOP.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"It is best to write most application code in a dependency-injection (DI) style, where that code is served out of a Spring IoC container, has its own dependencies supplied by the container when it is created, and is completely unaware of the container. However, for the small glue layers of code that are sometimes needed to tie other code together, you sometimes need a singleton (or quasi-singleton) style access to a Spring IoC container. For example, third-party code may try to construct new objects directly (Class.forName() style), without the ability to get these objects out of a Spring IoC container. If the object constructed by the third-party code is a small stub or proxy, which then uses a singleton style access to a Spring IoC container to get a real object to delegate to, then inversion of control has still been achieved for the majority of the code (the object coming out of the container). Thus most code is still unaware of the container or how it is accessed, and remains decoupled from other code, with all ensuing benefits. EJBs may also use this stub/proxy approach to delegate to a plain Java implementation object, retrieved from a Spring IoC container. While the Spring IoC container itself ideally does not have to be a singleton, it may be unrealistic in terms of memory usage or initialization times (when using beans in the Spring IoC container such as a Hibernate SessionFactory) for each bean to use its own, non-singleton Spring IoC container.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
"Looking up the application context in a service locator style is sometimes the only option for accessing shared Spring-managed components, such as in an EJB 2.1 environment, or when you want to share a single ApplicationContext as a parent to WebApplicationContexts across WAR files. In this case you should look into using the utility class ContextSingletonBeanFactoryLocator locator that is described in this SpringSource team blog entry.",https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html
